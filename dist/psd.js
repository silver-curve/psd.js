require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./image_exports/png.coffee":[function(require,module,exports){
var RSVP;

RSVP = require('rsvp');

module.exports = {
  toBase64: function() {
    var canvas, context, i, imageData, j, len, pixel, pixelData, ref;
    canvas = document.createElement('canvas');
    canvas.width = this.width();
    canvas.height = this.height();
    context = canvas.getContext('2d');
    imageData = context.getImageData(0, 0, this.width(), this.height());
    pixelData = imageData.data;
    ref = this.pixelData;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      pixel = ref[i];
      pixelData[i] = pixel;
    }
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL('image/png');
  },
  toPng: function() {
    var dataUrl, image;
    dataUrl = this.toBase64();
    image = new Image();
    image.width = this.width();
    image.height = this.height();
    image.src = dataUrl;
    return image;
  },
  saveAsPng: function() {
    throw "Not available in the browser. Use toPng() instead.";
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9zaGltcy9wbmcuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9zaGltcy9wbmcuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxNQUFSOztBQUVQLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxRQUFBLEVBQVUsU0FBQTtBQUVSLFFBQUE7SUFBQSxNQUFBLEdBQVMsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsUUFBdkI7SUFDVCxNQUFNLENBQUMsS0FBUCxHQUFlLElBQUMsQ0FBQSxLQUFELENBQUE7SUFDZixNQUFNLENBQUMsTUFBUCxHQUFnQixJQUFDLENBQUEsTUFBRCxDQUFBO0lBQ2hCLE9BQUEsR0FBVSxNQUFNLENBQUMsVUFBUCxDQUFrQixJQUFsQjtJQUVWLFNBQUEsR0FBWSxPQUFPLENBQUMsWUFBUixDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixJQUFDLENBQUEsS0FBRCxDQUFBLENBQTNCLEVBQXFDLElBQUMsQ0FBQSxNQUFELENBQUEsQ0FBckM7SUFDWixTQUFBLEdBQVksU0FBUyxDQUFDO0FBRXRCO0FBQUEsU0FBQSw2Q0FBQTs7TUFBQSxTQUFVLENBQUEsQ0FBQSxDQUFWLEdBQWU7QUFBZjtJQUVBLE9BQU8sQ0FBQyxZQUFSLENBQXFCLFNBQXJCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DO1dBRUEsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsV0FBakI7RUFkUSxDQUFWO0VBZ0JBLEtBQUEsRUFBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLE9BQUEsR0FBVSxJQUFDLENBQUEsUUFBRCxDQUFBO0lBR1YsS0FBQSxHQUFRLElBQUksS0FBSixDQUFBO0lBQ1IsS0FBSyxDQUFDLEtBQU4sR0FBYyxJQUFDLENBQUEsS0FBRCxDQUFBO0lBQ2QsS0FBSyxDQUFDLE1BQU4sR0FBZSxJQUFDLENBQUEsTUFBRCxDQUFBO0lBQ2YsS0FBSyxDQUFDLEdBQU4sR0FBWTtXQUVaO0VBVEssQ0FoQlA7RUEyQkEsU0FBQSxFQUFXLFNBQUE7QUFDVCxVQUFNO0VBREcsQ0EzQlgifQ==

},{"rsvp":96}],"./psd/init.coffee":[function(require,module,exports){
var RSVP;

RSVP = require('rsvp');

module.exports = {
  extended: function(PSD) {
    this.fromURL = function(url) {
      return new RSVP.Promise(function(resolve, reject) {
        var xhr;
        xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          var data, psd;
          data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
          psd = new PSD(data);
          psd.parse();
          return resolve(psd);
        };
        return xhr.send(null);
      });
    };
    this.fromEvent = function(e) {
      return new RSVP.Promise(function(resolve, reject) {
        var file, reader;
        file = e.dataTransfer.files[0];
        reader = new FileReader();
        reader.onload = function(e) {
          var psd;
          psd = new PSD(new Uint8Array(e.target.result));
          psd.parse();
          return resolve(psd);
        };
        reader.onerror = reject;
        return reader.readAsArrayBuffer(file);
      });
    };
    return this.fromDroppedFile = function(file) {
      return new RSVP.Promise(function(resolve, reject) {
        var reader;
        reader = new FileReader();
        reader.onload = function(e) {
          var psd;
          psd = new PSD(new Uint8Array(e.target.result));
          psd.parse();
          return resolve(psd);
        };
        reader.onerror = reject;
        return reader.readAsArrayBuffer(file);
      });
    };
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9zaGltcy9pbml0LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvc2hpbXMvaW5pdC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxJQUFBLEdBQU8sT0FBQSxDQUFRLE1BQVI7O0FBRVAsTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLFFBQUEsRUFBVSxTQUFDLEdBQUQ7SUFDUixJQUFDLENBQUEsT0FBRCxHQUFXLFNBQUMsR0FBRDthQUNULElBQUksSUFBSSxDQUFDLE9BQVQsQ0FBaUIsU0FBQyxPQUFELEVBQVUsTUFBVjtBQUNmLFlBQUE7UUFBQSxHQUFBLEdBQU0sSUFBSSxjQUFKLENBQUE7UUFDTixHQUFHLENBQUMsSUFBSixDQUFTLEtBQVQsRUFBZ0IsR0FBaEIsRUFBcUIsSUFBckI7UUFDQSxHQUFHLENBQUMsWUFBSixHQUFtQjtRQUNuQixHQUFHLENBQUMsTUFBSixHQUFhLFNBQUE7QUFDWCxjQUFBO1VBQUEsSUFBQSxHQUFPLElBQUksVUFBSixDQUFlLEdBQUcsQ0FBQyxRQUFKLElBQWdCLEdBQUcsQ0FBQyxzQkFBbkM7VUFDUCxHQUFBLEdBQU0sSUFBSSxHQUFKLENBQVEsSUFBUjtVQUNOLEdBQUcsQ0FBQyxLQUFKLENBQUE7aUJBRUEsT0FBQSxDQUFRLEdBQVI7UUFMVztlQU9iLEdBQUcsQ0FBQyxJQUFKLENBQVMsSUFBVDtNQVhlLENBQWpCO0lBRFM7SUFjWCxJQUFDLENBQUEsU0FBRCxHQUFhLFNBQUMsQ0FBRDthQUNYLElBQUksSUFBSSxDQUFDLE9BQVQsQ0FBaUIsU0FBQyxPQUFELEVBQVUsTUFBVjtBQUNmLFlBQUE7UUFBQSxJQUFBLEdBQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFNLENBQUEsQ0FBQTtRQUM1QixNQUFBLEdBQVMsSUFBSSxVQUFKLENBQUE7UUFDVCxNQUFNLENBQUMsTUFBUCxHQUFnQixTQUFDLENBQUQ7QUFDZCxjQUFBO1VBQUEsR0FBQSxHQUFNLElBQUksR0FBSixDQUFRLElBQUksVUFBSixDQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBeEIsQ0FBUjtVQUNOLEdBQUcsQ0FBQyxLQUFKLENBQUE7aUJBRUEsT0FBQSxDQUFRLEdBQVI7UUFKYztRQU1oQixNQUFNLENBQUMsT0FBUCxHQUFpQjtlQUNqQixNQUFNLENBQUMsaUJBQVAsQ0FBeUIsSUFBekI7TUFWZSxDQUFqQjtJQURXO1dBYWIsSUFBQyxDQUFBLGVBQUQsR0FBbUIsU0FBQyxJQUFEO2FBQ2pCLElBQUksSUFBSSxDQUFDLE9BQVQsQ0FBaUIsU0FBQyxPQUFELEVBQVUsTUFBVjtBQUNmLFlBQUE7UUFBQSxNQUFBLEdBQVMsSUFBSSxVQUFKLENBQUE7UUFDVCxNQUFNLENBQUMsTUFBUCxHQUFnQixTQUFDLENBQUQ7QUFDZCxjQUFBO1VBQUEsR0FBQSxHQUFNLElBQUksR0FBSixDQUFRLElBQUksVUFBSixDQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBeEIsQ0FBUjtVQUNOLEdBQUcsQ0FBQyxLQUFKLENBQUE7aUJBRUEsT0FBQSxDQUFRLEdBQVI7UUFKYztRQU1oQixNQUFNLENBQUMsT0FBUCxHQUFpQjtlQUNqQixNQUFNLENBQUMsaUJBQVAsQ0FBeUIsSUFBekI7TUFUZSxDQUFqQjtJQURpQjtFQTVCWCxDQUFWIn0=

},{"rsvp":96}],1:[function(require,module,exports){
var BlendMode, Module,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Module = require('coffeescript-module').Module;

module.exports = BlendMode = (function(superClass) {
  var BLEND_MODES;

  extend(BlendMode, superClass);

  BlendMode.aliasProperty('blendingMode', 'mode');

  BLEND_MODES = {
    norm: 'normal',
    dark: 'darken',
    lite: 'lighten',
    hue: 'hue',
    sat: 'saturation',
    colr: 'color',
    lum: 'luminosity',
    mul: 'multiply',
    scrn: 'screen',
    diss: 'dissolve',
    over: 'overlay',
    hLit: 'hard_light',
    sLit: 'soft_light',
    diff: 'difference',
    smud: 'exclusion',
    div: 'color_dodge',
    idiv: 'color_burn',
    lbrn: 'linear_burn',
    lddg: 'linear_dodge',
    vLit: 'vivid_light',
    lLit: 'linear_light',
    pLit: 'pin_light',
    hMix: 'hard_mix',
    pass: 'passthru',
    dkCl: 'darker_color',
    lgCl: 'lighter_color',
    fsub: 'subtract',
    fdiv: 'divide'
  };

  function BlendMode(file) {
    this.file = file;
    this.blendKey = null;
    this.opacity = null;
    this.clipping = null;
    this.clipped = null;
    this.flags = null;
    this.mode = null;
    this.visible = null;
  }

  BlendMode.prototype.parse = function() {
    this.file.seek(4, true);
    this.blendKey = this.file.readString(4).trim();
    this.opacity = this.file.readByte();
    this.clipping = this.file.readByte();
    this.flags = this.file.readByte();
    this.mode = BLEND_MODES[this.blendKey];
    this.clipped = this.clipping === 1;
    this.visible = !((this.flags & (0x01 << 1)) > 0);
    return this.file.seek(1, true);
  };

  BlendMode.prototype.opacityPercentage = function() {
    return this.opacity * 100 / 255;
  };

  return BlendMode;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2JsZW5kX21vZGUuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2JsZW5kX21vZGUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsaUJBQUE7RUFBQTs7O0FBQUMsU0FBVSxPQUFBLENBQVEscUJBQVI7O0FBSVgsTUFBTSxDQUFDLE9BQVAsR0FBdUI7QUFDckIsTUFBQTs7OztFQUFBLFNBQUMsQ0FBQSxhQUFELENBQWUsY0FBZixFQUErQixNQUEvQjs7RUFJQSxXQUFBLEdBQWM7SUFDWixJQUFBLEVBQU0sUUFETTtJQUVaLElBQUEsRUFBTSxRQUZNO0lBR1osSUFBQSxFQUFNLFNBSE07SUFJWixHQUFBLEVBQU0sS0FKTTtJQUtaLEdBQUEsRUFBTSxZQUxNO0lBTVosSUFBQSxFQUFNLE9BTk07SUFPWixHQUFBLEVBQU0sWUFQTTtJQVFaLEdBQUEsRUFBTSxVQVJNO0lBU1osSUFBQSxFQUFNLFFBVE07SUFVWixJQUFBLEVBQU0sVUFWTTtJQVdaLElBQUEsRUFBTSxTQVhNO0lBWVosSUFBQSxFQUFNLFlBWk07SUFhWixJQUFBLEVBQU0sWUFiTTtJQWNaLElBQUEsRUFBTSxZQWRNO0lBZVosSUFBQSxFQUFNLFdBZk07SUFnQlosR0FBQSxFQUFNLGFBaEJNO0lBaUJaLElBQUEsRUFBTSxZQWpCTTtJQWtCWixJQUFBLEVBQU0sYUFsQk07SUFtQlosSUFBQSxFQUFNLGNBbkJNO0lBb0JaLElBQUEsRUFBTSxhQXBCTTtJQXFCWixJQUFBLEVBQU0sY0FyQk07SUFzQlosSUFBQSxFQUFNLFdBdEJNO0lBdUJaLElBQUEsRUFBTSxVQXZCTTtJQXdCWixJQUFBLEVBQU0sVUF4Qk07SUF5QlosSUFBQSxFQUFNLGNBekJNO0lBMEJaLElBQUEsRUFBTSxlQTFCTTtJQTJCWixJQUFBLEVBQU0sVUEzQk07SUE0QlosSUFBQSxFQUFNLFFBNUJNOzs7RUErQkQsbUJBQUMsSUFBRDtJQUFDLElBQUMsQ0FBQSxPQUFEO0lBRVosSUFBQyxDQUFBLFFBQUQsR0FBWTtJQUdaLElBQUMsQ0FBQSxPQUFELEdBQVc7SUFHWCxJQUFDLENBQUEsUUFBRCxHQUFZO0lBR1osSUFBQyxDQUFBLE9BQUQsR0FBVztJQUNYLElBQUMsQ0FBQSxLQUFELEdBQVM7SUFHVCxJQUFDLENBQUEsSUFBRCxHQUFRO0lBR1IsSUFBQyxDQUFBLE9BQUQsR0FBVztFQWxCQTs7c0JBcUJiLEtBQUEsR0FBTyxTQUFBO0lBQ0wsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7SUFFQSxJQUFDLENBQUEsUUFBRCxHQUFZLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFpQixDQUFqQixDQUFtQixDQUFDLElBQXBCLENBQUE7SUFDWixJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBO0lBQ1gsSUFBQyxDQUFBLFFBQUQsR0FBWSxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQTtJQUNaLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUE7SUFFVCxJQUFDLENBQUEsSUFBRCxHQUFRLFdBQVksQ0FBQSxJQUFDLENBQUEsUUFBRDtJQUNwQixJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxRQUFELEtBQWE7SUFFeEIsSUFBQyxDQUFBLE9BQUQsR0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFDLENBQUEsS0FBRCxHQUFTLENBQUMsSUFBQSxJQUFRLENBQVQsQ0FBVixDQUFBLEdBQXlCLENBQTFCO1dBRVosSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7RUFiSzs7c0JBZ0JQLGlCQUFBLEdBQW1CLFNBQUE7V0FBRyxJQUFDLENBQUEsT0FBRCxHQUFXLEdBQVgsR0FBaUI7RUFBcEI7Ozs7R0F6RW9CIn0=

},{"coffeescript-module":70}],2:[function(require,module,exports){
var ChannelImage, Image, ImageFormat, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Image = require('./image.coffee');

ImageFormat = require('./image_format.coffee');

module.exports = ChannelImage = (function(superClass) {
  extend(ChannelImage, superClass);

  ChannelImage.includes(ImageFormat.LayerRAW);

  ChannelImage.includes(ImageFormat.LayerRLE);

  function ChannelImage(file, header, layer) {
    this.layer = layer;
    this._width = this.layer.width;
    this._height = this.layer.height;
    ChannelImage.__super__.constructor.call(this, file, header);
    this.channelsInfo = this.layer.channelsInfo;
    this.hasMask = _.any(this.channelsInfo, function(c) {
      return c.id < -1;
    });
    this.opacity = this.layer.opacity / 255.0;
  }

  ChannelImage.prototype.skip = function() {
    var chan, i, len, ref, results;
    ref = this.channelsInfo;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      chan = ref[i];
      results.push(this.file.seek(chan.length, true));
    }
    return results;
  };

  ChannelImage.prototype.width = function() {
    return this._width;
  };

  ChannelImage.prototype.height = function() {
    return this._height;
  };

  ChannelImage.prototype.channels = function() {
    return this.layer.channels;
  };

  ChannelImage.prototype.parse = function() {
    var chan, finish, i, len, ref, start;
    this.chanPos = 0;
    ref = this.channelsInfo;
    for (i = 0, len = ref.length; i < len; i++) {
      chan = ref[i];
      if (chan.length <= 0) {
        this.parseCompression();
        continue;
      }
      this.chan = chan;
      if (chan.id < -1) {
        this._width = this.layer.mask.width;
        this._height = this.layer.mask.height;
      } else {
        this._width = this.layer.width;
        this._height = this.layer.height;
      }
      this.length = this._width * this._height;
      start = this.file.tell();
      this.parseImageData();
      finish = this.file.tell();
      if (finish !== start + this.chan.length) {
        this.file.seek(start + this.chan.length);
      }
    }
    this._width = this.layer.width;
    this._height = this.layer.height;
    return this.processImageData();
  };

  ChannelImage.prototype.parseImageData = function() {
    this.compression = this.parseCompression();
    switch (this.compression) {
      case 0:
        return this.parseRaw();
      case 1:
        return this.parseRLE();
      case 2:
      case 3:
        return this.parseZip();
      default:
        return this.file.seek(this.endPos);
    }
  };

  return ChannelImage;

})(Image);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2NoYW5uZWxfaW1hZ2UuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2NoYW5uZWxfaW1hZ2UuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsbUNBQUE7RUFBQTs7O0FBQUEsQ0FBQSxHQUFjLE9BQUEsQ0FBUSxRQUFSOztBQUNkLEtBQUEsR0FBYyxPQUFBLENBQVEsZ0JBQVI7O0FBQ2QsV0FBQSxHQUFjLE9BQUEsQ0FBUSx1QkFBUjs7QUFRZCxNQUFNLENBQUMsT0FBUCxHQUF1Qjs7O0VBQ3JCLFlBQUMsQ0FBQSxRQUFELENBQVUsV0FBVyxDQUFDLFFBQXRCOztFQUNBLFlBQUMsQ0FBQSxRQUFELENBQVUsV0FBVyxDQUFDLFFBQXRCOztFQUdhLHNCQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsS0FBZjtJQUFlLElBQUMsQ0FBQSxRQUFEO0lBRzFCLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLEtBQUssQ0FBQztJQUNqQixJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFFbEIsOENBQU0sSUFBTixFQUFZLE1BQVo7SUFFQSxJQUFDLENBQUEsWUFBRCxHQUFnQixJQUFDLENBQUEsS0FBSyxDQUFDO0lBQ3ZCLElBQUMsQ0FBQSxPQUFELEdBQVcsQ0FBQyxDQUFDLEdBQUYsQ0FBTSxJQUFDLENBQUEsWUFBUCxFQUFxQixTQUFDLENBQUQ7YUFBTyxDQUFDLENBQUMsRUFBRixHQUFPLENBQUM7SUFBZixDQUFyQjtJQUNYLElBQUMsQ0FBQSxPQUFELEdBQVcsSUFBQyxDQUFBLEtBQUssQ0FBQyxPQUFQLEdBQWlCO0VBVmpCOzt5QkFhYixJQUFBLEdBQU0sU0FBQTtBQUNKLFFBQUE7QUFBQTtBQUFBO1NBQUEscUNBQUE7O21CQUNFLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLElBQUksQ0FBQyxNQUFoQixFQUF3QixJQUF4QjtBQURGOztFQURJOzt5QkFLTixLQUFBLEdBQU8sU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOzt5QkFHUCxNQUFBLEdBQVEsU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOzt5QkFHUixRQUFBLEdBQVUsU0FBQTtXQUFHLElBQUMsQ0FBQSxLQUFLLENBQUM7RUFBVjs7eUJBSVYsS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsSUFBQyxDQUFBLE9BQUQsR0FBVztBQUNYO0FBQUEsU0FBQSxxQ0FBQTs7TUFDRSxJQUFHLElBQUksQ0FBQyxNQUFMLElBQWUsQ0FBbEI7UUFDRSxJQUFDLENBQUEsZ0JBQUQsQ0FBQTtBQUNBLGlCQUZGOztNQUlBLElBQUMsQ0FBQSxJQUFELEdBQVE7TUFJUixJQUFHLElBQUksQ0FBQyxFQUFMLEdBQVUsQ0FBQyxDQUFkO1FBQ0UsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQztRQUN0QixJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BRnpCO09BQUEsTUFBQTtRQUlFLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLEtBQUssQ0FBQztRQUNqQixJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxLQUFLLENBQUMsT0FMcEI7O01BT0EsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQTtNQUNyQixLQUFBLEdBQVEsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUE7TUFFUixJQUFDLENBQUEsY0FBRCxDQUFBO01BRUEsTUFBQSxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFBO01BRVQsSUFBRyxNQUFBLEtBQVksS0FBQSxHQUFRLElBQUMsQ0FBQSxJQUFJLENBQUMsTUFBN0I7UUFDRSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxLQUFBLEdBQVEsSUFBQyxDQUFBLElBQUksQ0FBQyxNQUF6QixFQURGOztBQXZCRjtJQTBCQSxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFDakIsSUFBQyxDQUFBLE9BQUQsR0FBVyxJQUFDLENBQUEsS0FBSyxDQUFDO1dBRWxCLElBQUMsQ0FBQSxnQkFBRCxDQUFBO0VBL0JLOzt5QkFvQ1AsY0FBQSxHQUFnQixTQUFBO0lBQ2QsSUFBQyxDQUFBLFdBQUQsR0FBZSxJQUFDLENBQUEsZ0JBQUQsQ0FBQTtBQUVmLFlBQU8sSUFBQyxDQUFBLFdBQVI7QUFBQSxXQUNPLENBRFA7ZUFDYyxJQUFDLENBQUEsUUFBRCxDQUFBO0FBRGQsV0FFTyxDQUZQO2VBRWMsSUFBQyxDQUFBLFFBQUQsQ0FBQTtBQUZkLFdBR08sQ0FIUDtBQUFBLFdBR1UsQ0FIVjtlQUdpQixJQUFDLENBQUEsUUFBRCxDQUFBO0FBSGpCO2VBSU8sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsSUFBQyxDQUFBLE1BQVo7QUFKUDtFQUhjOzs7O0dBckUwQiJ9

},{"./image.coffee":7,"./image_format.coffee":9,"lodash":93}],3:[function(require,module,exports){
var Util;

Util = require('./util.coffee');

module.exports = {
  cmykToRgb: function(c, m, y, k) {
    var b, g, r;
    r = Util.clamp((65535 - (c * (255 - k) + (k << 8))) >> 8, 0, 255);
    g = Util.clamp((65535 - (m * (255 - k) + (k << 8))) >> 8, 0, 255);
    b = Util.clamp((65535 - (y * (255 - k) + (k << 8))) >> 8, 0, 255);
    return [r, g, b];
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2NvbG9yLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9jb2xvci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxJQUFBLEdBQU8sT0FBQSxDQUFRLGVBQVI7O0FBRVAsTUFBTSxDQUFDLE9BQVAsR0FHRTtFQUFBLFNBQUEsRUFBVyxTQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVY7QUFDVCxRQUFBO0lBQUEsQ0FBQSxHQUFJLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxLQUFBLEdBQVEsQ0FBQyxDQUFBLEdBQUksQ0FBQyxHQUFBLEdBQU0sQ0FBUCxDQUFKLEdBQWdCLENBQUMsQ0FBQSxJQUFLLENBQU4sQ0FBakIsQ0FBVCxDQUFBLElBQXdDLENBQW5ELEVBQXNELENBQXRELEVBQXlELEdBQXpEO0lBQ0osQ0FBQSxHQUFJLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxLQUFBLEdBQVEsQ0FBQyxDQUFBLEdBQUksQ0FBQyxHQUFBLEdBQU0sQ0FBUCxDQUFKLEdBQWdCLENBQUMsQ0FBQSxJQUFLLENBQU4sQ0FBakIsQ0FBVCxDQUFBLElBQXdDLENBQW5ELEVBQXNELENBQXRELEVBQXlELEdBQXpEO0lBQ0osQ0FBQSxHQUFJLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxLQUFBLEdBQVEsQ0FBQyxDQUFBLEdBQUksQ0FBQyxHQUFBLEdBQU0sQ0FBUCxDQUFKLEdBQWdCLENBQUMsQ0FBQSxJQUFLLENBQU4sQ0FBakIsQ0FBVCxDQUFBLElBQXdDLENBQW5ELEVBQXNELENBQXRELEVBQXlELEdBQXpEO1dBQ0osQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVA7RUFKUyxDQUFYIn0=

},{"./util.coffee":65}],4:[function(require,module,exports){
var Descriptor;

module.exports = Descriptor = (function() {
  function Descriptor(file) {
    this.file = file;
    this.data = {};
  }

  Descriptor.prototype.parse = function() {
    var i, id, j, numItems, ref, ref1, value;
    this.data["class"] = this.parseClass();
    numItems = this.file.readInt();
    for (i = j = 0, ref = numItems; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      ref1 = this.parseKeyItem(), id = ref1[0], value = ref1[1];
      this.data[id] = value;
    }
    return this.data;
  };

  Descriptor.prototype.parseClass = function() {
    return {
      name: this.file.readUnicodeString(),
      id: this.parseId()
    };
  };

  Descriptor.prototype.parseId = function() {
    var len;
    len = this.file.readInt();
    if (len === 0) {
      return this.file.readString(4);
    } else {
      return this.file.readString(len);
    }
  };

  Descriptor.prototype.parseKeyItem = function() {
    var id, value;
    id = this.parseId();
    value = this.parseItem();
    return [id, value];
  };

  Descriptor.prototype.parseItem = function(type) {
    if (type == null) {
      type = null;
    }
    if (type == null) {
      type = this.file.readString(4);
    }
    switch (type) {
      case 'bool':
        return this.parseBoolean();
      case 'type':
      case 'GlbC':
        return this.parseClass();
      case 'Objc':
      case 'GlbO':
        return new Descriptor(this.file).parse();
      case 'doub':
        return this.parseDouble();
      case 'enum':
        return this.parseEnum();
      case 'alis':
        return this.parseAlias();
      case 'Pth':
        return this.parseFilePath();
      case 'long':
        return this.parseInteger();
      case 'comp':
        return this.parseLargeInteger();
      case 'VlLs':
        return this.parseList();
      case 'ObAr':
        return this.parseObjectArray();
      case 'tdta':
        return this.parseRawData();
      case 'obj ':
        return this.parseReference();
      case 'TEXT':
        return this.file.readUnicodeString();
      case 'UntF':
        return this.parseUnitDouble();
      case 'UnFl':
        return this.parseUnitFloat();
    }
  };

  Descriptor.prototype.parseBoolean = function() {
    return this.file.readBoolean();
  };

  Descriptor.prototype.parseDouble = function() {
    return this.file.readDouble();
  };

  Descriptor.prototype.parseInteger = function() {
    return this.file.readInt();
  };

  Descriptor.prototype.parseLargeInteger = function() {
    return this.file.readLongLong();
  };

  Descriptor.prototype.parseIdentifier = function() {
    return this.file.readInt();
  };

  Descriptor.prototype.parseIndex = function() {
    return this.file.readInt();
  };

  Descriptor.prototype.parseOffset = function() {
    return this.file.readInt();
  };

  Descriptor.prototype.parseProperty = function() {
    return {
      "class": this.parseClass(),
      id: this.parseId()
    };
  };

  Descriptor.prototype.parseEnum = function() {
    return {
      type: this.parseId(),
      value: this.parseId()
    };
  };

  Descriptor.prototype.parseEnumReference = function() {
    return {
      "class": this.parseClass(),
      type: this.parseId(),
      value: this.parseId()
    };
  };

  Descriptor.prototype.parseAlias = function() {
    var len;
    len = this.file.readInt();
    return this.file.readString(len);
  };

  Descriptor.prototype.parseFilePath = function() {
    var len, numChars, path, pathSize, sig;
    len = this.file.readInt();
    sig = this.file.readString(4);
    pathSize = this.file.read('<i');
    numChars = this.file.read('<i');
    path = this.file.readUnicodeString(numChars);
    return {
      sig: sig,
      path: path
    };
  };

  Descriptor.prototype.parseList = function() {
    var count, i, items, j, ref;
    count = this.file.readInt();
    items = [];
    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      items.push(this.parseItem());
    }
    return items;
  };

  Descriptor.prototype.parseObjectArray = function() {
    throw "Descriptor object array not implemented yet @ " + (this.file.tell());
  };

  Descriptor.prototype.parseRawData = function() {
    var len;
    len = this.file.readInt();
    return this.file.read(len);
  };

  Descriptor.prototype.parseReference = function() {
    var i, items, j, numItems, ref, type, value;
    numItems = this.file.readInt();
    items = [];
    for (i = j = 0, ref = numItems; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      type = this.file.readString(4);
      value = (function() {
        switch (type) {
          case 'prop':
            return this.parseProperty();
          case 'Clss':
            return this.parseClass();
          case 'Enmr':
            return this.parseEnumReference();
          case 'Idnt':
            return this.parseIdentifier();
          case 'indx':
            return this.parseIndex();
          case 'name':
            return this.file.readUnicodeString();
          case 'rele':
            return this.parseOffset();
        }
      }).call(this);
      items.push({
        type: type,
        value: value
      });
    }
    return items;
  };

  Descriptor.prototype.parseUnitDouble = function() {
    var unit, unitId, value;
    unitId = this.file.readString(4);
    unit = (function() {
      switch (unitId) {
        case '#Ang':
          return 'Angle';
        case '#Rsl':
          return 'Density';
        case '#Rlt':
          return 'Distance';
        case '#Nne':
          return 'None';
        case '#Prc':
          return 'Percent';
        case '#Pxl':
          return 'Pixels';
        case '#Mlm':
          return 'Millimeters';
        case '#Pnt':
          return 'Points';
      }
    })();
    value = this.file.readDouble();
    return {
      id: unitId,
      unit: unit,
      value: value
    };
  };

  Descriptor.prototype.parseUnitFloat = function() {
    var unit, unitId, value;
    unitId = this.file.readString(4);
    unit = (function() {
      switch (unitId) {
        case '#Ang':
          return 'Angle';
        case '#Rsl':
          return 'Density';
        case '#Rlt':
          return 'Distance';
        case '#Nne':
          return 'None';
        case '#Prc':
          return 'Percent';
        case '#Pxl':
          return 'Pixels';
        case '#Mlm':
          return 'Millimeters';
        case '#Pnt':
          return 'Points';
      }
    })();
    value = this.file.readFloat();
    return {
      id: unitId,
      unit: unit,
      value: value
    };
  };

  return Descriptor;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2Rlc2NyaXB0b3IuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2Rlc2NyaXB0b3IuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBLElBQUE7O0FBQUEsTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFFUixvQkFBQyxJQUFEO0lBQUMsSUFBQyxDQUFBLE9BQUQ7SUFFWixJQUFDLENBQUEsSUFBRCxHQUFRO0VBRkc7O3VCQUtiLEtBQUEsR0FBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLElBQUMsQ0FBQSxJQUFJLEVBQUMsS0FBRCxFQUFMLEdBQWMsSUFBQyxDQUFBLFVBQUQsQ0FBQTtJQUdkLFFBQUEsR0FBVyxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtBQUlYLFNBQVMsaUZBQVQ7TUFDRSxPQUFjLElBQUMsQ0FBQSxZQUFELENBQUEsQ0FBZCxFQUFDLFlBQUQsRUFBSztNQUNMLElBQUMsQ0FBQSxJQUFLLENBQUEsRUFBQSxDQUFOLEdBQVk7QUFGZDtXQUlBLElBQUMsQ0FBQTtFQVpJOzt1QkFtQlAsVUFBQSxHQUFZLFNBQUE7V0FDVjtNQUFBLElBQUEsRUFBTSxJQUFDLENBQUEsSUFBSSxDQUFDLGlCQUFOLENBQUEsQ0FBTjtNQUNBLEVBQUEsRUFBSSxJQUFDLENBQUEsT0FBRCxDQUFBLENBREo7O0VBRFU7O3VCQUtaLE9BQUEsR0FBUyxTQUFBO0FBQ1AsUUFBQTtJQUFBLEdBQUEsR0FBTSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNOLElBQUcsR0FBQSxLQUFPLENBQVY7YUFBaUIsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQWlCLENBQWpCLEVBQWpCO0tBQUEsTUFBQTthQUEwQyxJQUFDLENBQUEsSUFBSSxDQUFDLFVBQU4sQ0FBaUIsR0FBakIsRUFBMUM7O0VBRk87O3VC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

},{}],5:[function(require,module,exports){
(function (Buffer){
var Color, File, Util, iconv, jspack,
  hasProp = {}.hasOwnProperty;

jspack = require('jspack').jspack;

iconv = require('iconv-lite');

Color = require('./color.coffee');

Util = require('./util.coffee');

module.exports = File = (function() {
  var FORMATS, fn, format, info;

  FORMATS = {
    Int: {
      code: '>i',
      length: 4
    },
    UInt: {
      code: '>I',
      length: 4
    },
    Short: {
      code: '>h',
      length: 2
    },
    UShort: {
      code: '>H',
      length: 2
    },
    Float: {
      code: '>f',
      length: 4
    },
    Double: {
      code: '>d',
      length: 8
    },
    LongLong: {
      code: '>q',
      length: 8
    }
  };

  fn = function(format, info) {
    return File.prototype["read" + format] = function() {
      return this.readf(info.code, info.length)[0];
    };
  };
  for (format in FORMATS) {
    if (!hasProp.call(FORMATS, format)) continue;
    info = FORMATS[format];
    fn(format, info);
  }

  File.prototype.pos = 0;

  function File(data) {
    this.data = data;
  }

  File.prototype.tell = function() {
    return this.pos;
  };

  File.prototype.read = function(length) {
    var i, j, ref, results;
    results = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(this.data[this.pos++]);
    }
    return results;
  };

  File.prototype.readf = function(format, len) {
    if (len == null) {
      len = null;
    }
    return jspack.Unpack(format, this.read(len || jspack.CalcLength(format)));
  };

  File.prototype.seek = function(amt, rel) {
    if (rel == null) {
      rel = false;
    }
    if (rel) {
      return this.pos += amt;
    } else {
      return this.pos = amt;
    }
  };

  File.prototype.readString = function(length) {
    return String.fromCharCode.apply(null, this.read(length)).replace(/\u0000/g, "");
  };

  File.prototype.readUnicodeString = function(length) {
    if (length == null) {
      length = null;
    }
    length || (length = this.readInt());
    return iconv.decode(new Buffer(this.read(length * 2)), 'utf-16be').replace(/\u0000/g, "");
  };

  File.prototype.readByte = function() {
    return this.read(1)[0];
  };

  File.prototype.readBoolean = function() {
    return this.readByte() !== 0;
  };

  File.prototype.readSpaceColor = function() {
    var colorComponent, colorSpace, i, j;
    colorSpace = this.readShort();
    for (i = j = 0; j < 4; i = ++j) {
      colorComponent = this.readShort() >> 8;
    }
    return {
      colorSpace: colorSpace,
      components: colorComponent
    };
  };

  File.prototype.readPathNumber = function() {
    var a, arr, b, b1, b2, b3;
    a = this.readByte();
    arr = this.read(3);
    b1 = arr[0] << 16;
    b2 = arr[1] << 8;
    b3 = arr[2];
    b = b1 | b2 | b3;
    return parseFloat(a, 10) + parseFloat(b / Math.pow(2, 24), 10);
  };

  return File;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ZpbGUuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ZpbGUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsZ0NBQUE7RUFBQTs7QUFBQyxTQUFVLE9BQUEsQ0FBUSxRQUFSOztBQUNYLEtBQUEsR0FBUSxPQUFBLENBQVEsWUFBUjs7QUFDUixLQUFBLEdBQVEsT0FBQSxDQUFRLGdCQUFSOztBQUNSLElBQUEsR0FBTyxPQUFBLENBQVEsZUFBUjs7QUFJUCxNQUFNLENBQUMsT0FBUCxHQUF1QjtBQUNyQixNQUFBOztFQUFBLE9BQUEsR0FDRTtJQUFBLEdBQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FERjtJQUdBLElBQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FKRjtJQU1BLEtBQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FQRjtJQVNBLE1BQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FWRjtJQVlBLEtBQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FiRjtJQWVBLE1BQUEsRUFDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsTUFBQSxFQUFRLENBRFI7S0FoQkY7SUFrQkEsUUFBQSxFQUNFO01BQUEsSUFBQSxFQUFNLElBQU47TUFDQSxNQUFBLEVBQVEsQ0FEUjtLQW5CRjs7O09Bc0JzQyxTQUFDLE1BQUQsRUFBUyxJQUFUO1dBQ3RDLElBQUMsQ0FBQSxTQUFHLENBQUEsTUFBQSxHQUFPLE1BQVAsQ0FBSixHQUF1QixTQUFBO2FBQUcsSUFBQyxDQUFBLEtBQUQsQ0FBTyxJQUFJLENBQUMsSUFBWixFQUFrQixJQUFJLENBQUMsTUFBdkIsQ0FBK0IsQ0FBQSxDQUFBO0lBQWxDO0VBRGU7QUFBeEMsT0FBQSxpQkFBQTs7O09BQXlDLFFBQVE7QUFBakQ7O2lCQUlBLEdBQUEsR0FBSzs7RUFHUSxjQUFDLElBQUQ7SUFBQyxJQUFDLENBQUEsT0FBRDtFQUFEOztpQkFHYixJQUFBLEdBQU0sU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOztpQkFHTixJQUFBLEdBQU0sU0FBQyxNQUFEO0FBQVksUUFBQTtBQUFDO1NBQXVCLCtFQUF2QjttQkFBQSxJQUFDLENBQUEsSUFBSyxDQUFBLElBQUMsQ0FBQSxHQUFELEVBQUE7QUFBTjs7RUFBYjs7aUJBSU4sS0FBQSxHQUFPLFNBQUMsTUFBRCxFQUFTLEdBQVQ7O01BQVMsTUFBTTs7V0FBUyxNQUFNLENBQUMsTUFBUCxDQUFjLE1BQWQsRUFBc0IsSUFBQyxDQUFBLElBQUQsQ0FBTSxHQUFBLElBQU8sTUFBTSxDQUFDLFVBQVAsQ0FBa0IsTUFBbEIsQ0FBYixDQUF0QjtFQUF4Qjs7aUJBS1AsSUFBQSxHQUFNLFNBQUMsR0FBRCxFQUFNLEdBQU47O01BQU0sTUFBTTs7SUFBVSxJQUFHLEdBQUg7YUFBWSxJQUFDLENBQUEsR0FBRCxJQUFRLElBQXBCO0tBQUEsTUFBQTthQUE2QixJQUFDLENBQUEsR0FBRCxHQUFPLElBQXBDOztFQUF0Qjs7aUJBR04sVUFBQSxHQUFZLFNBQUMsTUFBRDtXQUFZLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBcEIsQ0FBMEIsSUFBMUIsRUFBZ0MsSUFBQyxDQUFBLElBQUQsQ0FBTSxNQUFOLENBQWhDLENBQThDLENBQUMsT0FBL0MsQ0FBdUQsU0FBdkQsRUFBa0UsRUFBbEU7RUFBWjs7aUJBR1osaUJBQUEsR0FBbUIsU0FBQyxNQUFEOztNQUFDLFNBQVM7O0lBQzNCLFdBQUEsU0FBVyxJQUFDLENBQUEsT0FBRCxDQUFBO1dBQ1gsS0FBSyxDQUFDLE1BQU4sQ0FBYSxJQUFJLE1BQUosQ0FBVyxJQUFDLENBQUEsSUFBRCxDQUFNLE1BQUEsR0FBUyxDQUFmLENBQVgsQ0FBYixFQUEyQyxVQUEzQyxDQUFzRCxDQUFDLE9BQXZELENBQStELFNBQS9ELEVBQTBFLEVBQTFFO0VBRmlCOztpQkFLbkIsUUFBQSxHQUFVLFNBQUE7V0FBRyxJQUFDLENBQUEsSUFBRCxDQUFNLENBQU4sQ0FBUyxDQUFBLENBQUE7RUFBWjs7aUJBR1YsV0FBQSxHQUFhLFNBQUE7V0FBRyxJQUFDLENBQUEsUUFBRCxDQUFBLENBQUEsS0FBaUI7RUFBcEI7O2lCQUdiLGNBQUEsR0FBZ0IsU0FBQTtBQUNkLFFBQUE7SUFBQSxVQUFBLEdBQWEsSUFBQyxDQUFBLFNBQUQsQ0FBQTtBQUNiLFNBQThDLHlCQUE5QztNQUFBLGNBQUEsR0FBa0IsSUFBQyxDQUFBLFNBQUQsQ0FBQSxDQUFBLElBQWdCO0FBQWxDO1dBRUE7TUFBQSxVQUFBLEVBQVksVUFBWjtNQUF3QixVQUFBLEVBQVksY0FBcEM7O0VBSmM7O2lCQVFoQixjQUFBLEdBQWdCLFNBQUE7QUFDZCxRQUFBO0lBQUEsQ0FBQSxHQUFJLElBQUMsQ0FBQSxRQUFELENBQUE7SUFFSixHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUQsQ0FBTSxDQUFOO0lBQ04sRUFBQSxHQUFLLEdBQUksQ0FBQSxDQUFBLENBQUosSUFBVTtJQUNmLEVBQUEsR0FBSyxHQUFJLENBQUEsQ0FBQSxDQUFKLElBQVU7SUFDZixFQUFBLEdBQUssR0FBSSxDQUFBLENBQUE7SUFDVCxDQUFBLEdBQUksRUFBQSxHQUFLLEVBQUwsR0FBVTtXQUVkLFVBQUEsQ0FBVyxDQUFYLEVBQWMsRUFBZCxDQUFBLEdBQW9CLFVBQUEsQ0FBVyxDQUFBLEdBQUksSUFBSSxDQUFDLEdBQUwsQ0FBUyxDQUFULEVBQVksRUFBWixDQUFmLEVBQWdDLEVBQWhDO0VBVE4ifQ==

}).call(this,require("buffer").Buffer)
},{"./color.coffee":3,"./util.coffee":65,"buffer":68,"iconv-lite":90,"jspack":92}],6:[function(require,module,exports){
var Header, Module,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Module = require('coffeescript-module').Module;

module.exports = Header = (function(superClass) {
  var MODES;

  extend(Header, superClass);

  Header.aliasProperty('height', 'rows');

  Header.aliasProperty('width', 'cols');

  MODES = ['Bitmap', 'GrayScale', 'IndexedColor', 'RGBColor', 'CMYKColor', 'HSLColor', 'HSBColor', 'Multichannel', 'Duotone', 'LabColor', 'Gray16', 'RGB48', 'Lab48', 'CMYK64', 'DeepMultichannel', 'Duotone16'];

  Header.prototype.sig = null;

  Header.prototype.version = null;

  Header.prototype.channels = null;

  Header.prototype.rows = null;

  Header.prototype.cols = null;

  Header.prototype.depth = null;

  Header.prototype.mode = null;

  function Header(file) {
    this.file = file;
  }

  Header.prototype.parse = function() {
    var colorDataLen;
    this.sig = this.file.readString(4);
    if (this.sig !== '8BPS') {
      throw new Error('Invalid file signature detected. Got: ' + this.sig + '. Expected 8BPS.');
    }
    this.version = this.file.readUShort();
    this.file.seek(6, true);
    this.channels = this.file.readUShort();
    this.rows = this.height = this.file.readUInt();
    this.cols = this.width = this.file.readUInt();
    this.depth = this.file.readUShort();
    this.mode = this.file.readUShort();
    colorDataLen = this.file.readUInt();
    return this.file.seek(colorDataLen, true);
  };

  Header.prototype.modeName = function() {
    return MODES[this.mode];
  };

  Header.prototype["export"] = function() {
    var data, i, key, len, ref;
    data = {};
    ref = ['sig', 'version', 'channels', 'rows', 'cols', 'depth', 'mode'];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      data[key] = this[key];
    }
    return data;
  };

  return Header;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2hlYWRlci5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvaGVhZGVyLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBLGNBQUE7RUFBQTs7O0FBQUMsU0FBVSxPQUFBLENBQVEscUJBQVI7O0FBS1gsTUFBTSxDQUFDLE9BQVAsR0FBdUI7QUFDckIsTUFBQTs7OztFQUFBLE1BQUMsQ0FBQSxhQUFELENBQWUsUUFBZixFQUF5QixNQUF6Qjs7RUFDQSxNQUFDLENBQUEsYUFBRCxDQUFlLE9BQWYsRUFBd0IsTUFBeEI7O0VBSUEsS0FBQSxHQUFRLENBQ04sUUFETSxFQUVOLFdBRk0sRUFHTixjQUhNLEVBSU4sVUFKTSxFQUtOLFdBTE0sRUFNTixVQU5NLEVBT04sVUFQTSxFQVFOLGNBUk0sRUFTTixTQVRNLEVBVU4sVUFWTSxFQVdOLFFBWE0sRUFZTixPQVpNLEVBYU4sT0FiTSxFQWNOLFFBZE0sRUFlTixrQkFmTSxFQWdCTixXQWhCTTs7bUJBb0JSLEdBQUEsR0FBSzs7bUJBR0wsT0FBQSxHQUFTOzttQkFHVCxRQUFBLEdBQVU7O21CQUdWLElBQUEsR0FBTTs7bUJBR04sSUFBQSxHQUFNOzttQkFHTixLQUFBLEdBQU87O21CQUdQLElBQUEsR0FBTTs7RUFJTyxnQkFBQyxJQUFEO0lBQUMsSUFBQyxDQUFBLE9BQUQ7RUFBRDs7bUJBR2IsS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsSUFBQyxDQUFBLEdBQUQsR0FBTyxJQUFDLENBQUEsSUFBSSxDQUFDLFVBQU4sQ0FBaUIsQ0FBakI7SUFDUCxJQUFHLElBQUMsQ0FBQSxHQUFELEtBQVEsTUFBWDtBQUNFLFlBQU0sSUFBSSxLQUFKLENBQVUsd0NBQUEsR0FBeUMsSUFBQyxDQUFBLEdBQTFDLEdBQThDLGtCQUF4RCxFQURSOztJQUVBLElBQUMsQ0FBQSxPQUFELEdBQVcsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQUE7SUFFWCxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtJQUVBLElBQUMsQ0FBQSxRQUFELEdBQVksSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQUE7SUFDWixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUE7SUFDbEIsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBO0lBQ2pCLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQUE7SUFDVCxJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFBO0lBRVIsWUFBQSxHQUFlLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBO1dBQ2YsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsWUFBWCxFQUF5QixJQUF6QjtFQWZLOzttQkFrQlAsUUFBQSxHQUFVLFNBQUE7V0FBRyxLQUFNLENBQUEsSUFBQyxDQUFBLElBQUQ7RUFBVDs7b0JBR1YsUUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO0lBQUEsSUFBQSxHQUFPO0FBQ1A7QUFBQSxTQUFBLHFDQUFBOztNQUNFLElBQUssQ0FBQSxHQUFBLENBQUwsR0FBWSxJQUFFLENBQUEsR0FBQTtBQURoQjtXQUdBO0VBTE07Ozs7R0F4RTRCIn0=

},{"coffeescript-module":70}],7:[function(require,module,exports){
var Export, Image, ImageFormat, ImageMode, Module,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Module = require('coffeescript-module').Module;

ImageFormat = require('./image_format.coffee');

ImageMode = require('./image_mode.coffee');

Export = require('./image_export.coffee');

module.exports = Image = (function(superClass) {
  var COMPRESSIONS, attr, fn, i, len, ref;

  extend(Image, superClass);

  Image.includes(ImageFormat.RAW);

  Image.includes(ImageFormat.RLE);

  Image.includes(ImageMode.Greyscale);

  Image.includes(ImageMode.RGB);

  Image.includes(ImageMode.CMYK);

  Image.includes(Export.PNG);

  COMPRESSIONS = ['Raw', 'RLE', 'ZIP', 'ZIPPrediction'];

  function Image(file, header) {
    this.file = file;
    this.header = header;
    this.numPixels = this.width() * this.height();
    if (this.depth() === 16) {
      this.numPixels *= 2;
    }
    this.calculateLength();
    this.pixelData = new Uint8Array(this.channelLength * 4);
    this.maskData = new Uint8Array(this.maskLength * 4);
    this.channelData = new Uint8Array(this.length + this.maskLength);
    this.opacity = 1.0;
    this.hasMask = false;
    this.startPos = this.file.tell();
    this.endPos = this.startPos + this.length;
    this.setChannelsInfo();
  }

  ref = ['width', 'height', 'channels', 'depth', 'mode'];
  fn = function(attr) {
    return Image.prototype[attr] = function() {
      return this.header[attr];
    };
  };
  for (i = 0, len = ref.length; i < len; i++) {
    attr = ref[i];
    fn(attr);
  }

  Image.prototype.setChannelsInfo = function() {
    switch (this.mode()) {
      case 1:
        return this.setGreyscaleChannels();
      case 3:
        return this.setRgbChannels();
      case 4:
        return this.setCmykChannels();
    }
  };

  Image.prototype.calculateLength = function() {
    this.length = (function() {
      switch (this.depth()) {
        case 1:
          return (this.width() + 7) / 8 * this.height();
        case 16:
          return this.width() * this.height() * 2;
        default:
          return this.width() * this.height();
      }
    }).call(this);
    this.channelLength = this.length;
    this.length *= this.channels();
    if (this.layer && this.layer.mask.size) {
      return this.maskLength = this.layer.mask.width * this.layer.mask.height;
    } else {
      return this.maskLength = 0;
    }
  };

  Image.prototype.parse = function() {
    var ref1;
    this.compression = this.parseCompression();
    if ((ref1 = this.compression) === 2 || ref1 === 3) {
      this.file.seek(this.endPos);
      return;
    }
    return this.parseImageData();
  };

  Image.prototype.parseCompression = function() {
    return this.file.readShort();
  };

  Image.prototype.parseImageData = function() {
    switch (this.compression) {
      case 0:
        this.parseRaw();
        break;
      case 1:
        this.parseRLE();
        break;
      case 2:
      case 3:
        this.parseZip();
        break;
      default:
        this.file.seek(this.endPos);
    }
    return this.processImageData();
  };

  Image.prototype.processImageData = function() {
    switch (this.mode()) {
      case 1:
        this.combineGreyscaleChannel();
        break;
      case 3:
        this.combineRgbChannel();
        break;
      case 4:
        this.combineCmykChannel();
    }
    return this.channelData = null;
  };

  return Image;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9pbWFnZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSw2Q0FBQTtFQUFBOzs7QUFBQyxTQUFhLE9BQUEsQ0FBUSxxQkFBUjs7QUFFZCxXQUFBLEdBQWMsT0FBQSxDQUFRLHVCQUFSOztBQUNkLFNBQUEsR0FBYyxPQUFBLENBQVEscUJBQVI7O0FBQ2QsTUFBQSxHQUFjLE9BQUEsQ0FBUSx1QkFBUjs7QUFLZCxNQUFNLENBQUMsT0FBUCxHQUF1QjtBQUVyQixNQUFBOzs7O0VBQUEsS0FBQyxDQUFBLFFBQUQsQ0FBVSxXQUFXLENBQUMsR0FBdEI7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxXQUFXLENBQUMsR0FBdEI7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxTQUFTLENBQUMsU0FBcEI7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxTQUFTLENBQUMsR0FBcEI7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxTQUFTLENBQUMsSUFBcEI7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxNQUFNLENBQUMsR0FBakI7O0VBSUEsWUFBQSxHQUFlLENBQ2IsS0FEYSxFQUViLEtBRmEsRUFHYixLQUhhLEVBSWIsZUFKYTs7RUFPRixlQUFDLElBQUQsRUFBUSxNQUFSO0lBQUMsSUFBQyxDQUFBLE9BQUQ7SUFBTyxJQUFDLENBQUEsU0FBRDtJQUVuQixJQUFDLENBQUEsU0FBRCxHQUFhLElBQUMsQ0FBQSxLQUFELENBQUEsQ0FBQSxHQUFXLElBQUMsQ0FBQSxNQUFELENBQUE7SUFDeEIsSUFBbUIsSUFBQyxDQUFBLEtBQUQsQ0FBQSxDQUFBLEtBQVksRUFBL0I7TUFBQSxJQUFDLENBQUEsU0FBRCxJQUFjLEVBQWQ7O0lBRUEsSUFBQyxD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

},{"./image_export.coffee":8,"./image_format.coffee":9,"./image_mode.coffee":14,"coffeescript-module":70}],8:[function(require,module,exports){
module.exports = {
  PNG: require('./image_exports/png.coffee')
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2V4cG9ydC5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvaW1hZ2VfZXhwb3J0LmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsR0FBQSxFQUFLLE9BQUEsQ0FBUSw0QkFBUixDQUFMIn0=

},{"./image_exports/png.coffee":"./image_exports/png.coffee"}],9:[function(require,module,exports){
module.exports = {
  RAW: require('./image_formats/raw.coffee'),
  RLE: require('./image_formats/rle.coffee'),
  LayerRLE: require('./image_formats/layer_rle.coffee'),
  LayerRAW: require('./image_formats/layer_raw.coffee')
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2Zvcm1hdC5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvaW1hZ2VfZm9ybWF0LmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsR0FBQSxFQUFLLE9BQUEsQ0FBUSw0QkFBUixDQUFMO0VBQ0EsR0FBQSxFQUFLLE9BQUEsQ0FBUSw0QkFBUixDQURMO0VBRUEsUUFBQSxFQUFVLE9BQUEsQ0FBUSxrQ0FBUixDQUZWO0VBR0EsUUFBQSxFQUFVLE9BQUEsQ0FBUSxrQ0FBUixDQUhWIn0=

},{"./image_formats/layer_raw.coffee":10,"./image_formats/layer_rle.coffee":11,"./image_formats/raw.coffee":12,"./image_formats/rle.coffee":13}],10:[function(require,module,exports){
module.exports = {
  parseRaw: function() {
    var i, j, ref, ref1;
    for (i = j = ref = this.chanPos, ref1 = this.chanPos + this.chan.length - 2; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      this.channelData[i] = this.file.readByte();
    }
    return this.chanPos += this.chan.length - 2;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2Zvcm1hdHMvbGF5ZXJfcmF3LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9pbWFnZV9mb3JtYXRzL2xheWVyX3Jhdy5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLFFBQUEsRUFBVSxTQUFBO0FBQ1IsUUFBQTtBQUFBLFNBQVMsc0lBQVQ7TUFDRSxJQUFDLENBQUEsV0FBWSxDQUFBLENBQUEsQ0FBYixHQUFrQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQTtBQURwQjtXQUdBLElBQUMsQ0FBQSxPQUFELElBQWEsSUFBQyxDQUFBLElBQUksQ0FBQyxNQUFOLEdBQWU7RUFKcEIsQ0FBViJ9

},{}],11:[function(require,module,exports){
module.exports = {
  parseByteCounts: function() {
    var i, j, ref, results;
    results = [];
    for (i = j = 0, ref = this.height(); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(this.file.readShort());
    }
    return results;
  },
  parseChannelData: function() {
    this.lineIndex = 0;
    return this.decodeRLEChannel();
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2Zvcm1hdHMvbGF5ZXJfcmxlLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9pbWFnZV9mb3JtYXRzL2xheWVyX3JsZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLGVBQUEsRUFBaUIsU0FBQTtBQUNmLFFBQUE7QUFBQTtTQUEyQixzRkFBM0I7bUJBQUEsSUFBQyxDQUFBLElBQUksQ0FBQyxTQUFOLENBQUE7QUFBQTs7RUFEZSxDQUFqQjtFQUdBLGdCQUFBLEVBQWtCLFNBQUE7SUFDaEIsSUFBQyxDQUFBLFNBQUQsR0FBYTtXQUNiLElBQUMsQ0FBQSxnQkFBRCxDQUFBO0VBRmdCLENBSGxCIn0=

},{}],12:[function(require,module,exports){
module.exports = {
  parseRaw: function() {
    return this.channelData.set(this.file.read(this.length));
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2Zvcm1hdHMvcmF3LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9pbWFnZV9mb3JtYXRzL3Jhdy5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLFFBQUEsRUFBVSxTQUFBO1dBQ1IsSUFBQyxDQUFBLFdBQVcsQ0FBQyxHQUFiLENBQWlCLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLElBQUMsQ0FBQSxNQUFaLENBQWpCO0VBRFEsQ0FBViJ9

},{}],13:[function(require,module,exports){
module.exports = {
  parseRLE: function() {
    this.byteCounts = this.parseByteCounts();
    return this.parseChannelData();
  },
  parseByteCounts: function() {
    var i, k, ref, results;
    results = [];
    for (i = k = 0, ref = this.channels() * this.height(); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      results.push(this.file.readShort());
    }
    return results;
  },
  parseChannelData: function() {
    var i, k, ref, results;
    this.chanPos = 0;
    this.lineIndex = 0;
    results = [];
    for (i = k = 0, ref = this.channels(); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      this.decodeRLEChannel();
      results.push(this.lineIndex += this.height());
    }
    return results;
  },
  decodeRLEChannel: function() {
    var byteCount, data, finish, j, k, len, ref, results, val;
    results = [];
    for (j = k = 0, ref = this.height(); 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
      byteCount = this.byteCounts[this.lineIndex + j];
      finish = this.file.tell() + byteCount;
      results.push((function() {
        var results1;
        results1 = [];
        while (this.file.tell() < finish) {
          len = this.file.read(1)[0];
          if (len < 128) {
            len += 1;
            data = this.file.read(len);
            this.channelData.set(data, this.chanPos);
            results1.push(this.chanPos += len);
          } else if (len > 128) {
            len ^= 0xff;
            len += 2;
            val = this.file.read(1)[0];
            this.channelData.fill(val, this.chanPos, this.chanPos + len);
            results1.push(this.chanPos += len);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX2Zvcm1hdHMvcmxlLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9pbWFnZV9mb3JtYXRzL3JsZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLFFBQUEsRUFBVSxTQUFBO0lBQ1IsSUFBQyxDQUFBLFVBQUQsR0FBYyxJQUFDLENBQUEsZUFBRCxDQUFBO1dBQ2QsSUFBQyxDQUFBLGdCQUFELENBQUE7RUFGUSxDQUFWO0VBSUEsZUFBQSxFQUFpQixTQUFBO0FBQ2YsUUFBQTtBQUFBO1NBQTJCLHdHQUEzQjttQkFBQSxJQUFDLENBQUEsSUFBSSxDQUFDLFNBQU4sQ0FBQTtBQUFBOztFQURlLENBSmpCO0VBT0EsZ0JBQUEsRUFBa0IsU0FBQTtBQUNoQixRQUFBO0lBQUEsSUFBQyxDQUFBLE9BQUQsR0FBVztJQUNYLElBQUMsQ0FBQSxTQUFELEdBQWE7QUFDYjtTQUFTLHdGQUFUO01BQ0UsSUFBQyxDQUFBLGdCQUFELENBQUE7bUJBQ0EsSUFBQyxDQUFBLFNBQUQsSUFBYyxJQUFDLENBQUEsTUFBRCxDQUFBO0FBRmhCOztFQUhnQixDQVBsQjtFQWNBLGdCQUFBLEVBQWtCLFNBQUE7QUFDaEIsUUFBQTtBQUFBO1NBQVMsc0ZBQVQ7TUFDRSxTQUFBLEdBQVksSUFBQyxDQUFBLFVBQVcsQ0FBQSxJQUFDLENBQUEsU0FBRCxHQUFhLENBQWI7TUFDeEIsTUFBQSxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFBLENBQUEsR0FBZTs7O0FBRXhCO2VBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlLE1BQXJCO1VBQ0UsR0FBQSxHQUFNLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsQ0FBYyxDQUFBLENBQUE7VUFFcEIsSUFBRyxHQUFBLEdBQU0sR0FBVDtZQUNFLEdBQUEsSUFBTztZQUVQLElBQUEsR0FBTyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxHQUFYO1lBQ1AsSUFBQyxDQUFBLFdBQVcsQ0FBQyxHQUFiLENBQWlCLElBQWpCLEVBQXVCLElBQUMsQ0FBQSxPQUF4QjswQkFDQSxJQUFDLENBQUEsT0FBRCxJQUFZLEtBTGQ7V0FBQSxNQU1LLElBQUcsR0FBQSxHQUFNLEdBQVQ7WUFDSCxHQUFBLElBQU87WUFDUCxHQUFBLElBQU87WUFFUCxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxDQUFjLENBQUEsQ0FBQTtZQUVwQixJQUFDLENBQUEsV0FBVyxDQUFDLElBQWIsQ0FBa0IsR0FBbEIsRUFBdUIsSUFBQyxDQUFBLE9BQXhCLEVBQWlDLElBQUMsQ0FBQSxPQUFELEdBQVMsR0FBMUM7MEJBQ0EsSUFBQyxDQUFBLE9BQUQsSUFBWSxLQVBUO1dBQUEsTUFBQTtrQ0FBQTs7UUFUUCxDQUFBOzs7QUFKRjs7RUFEZ0IsQ0FkbEIifQ==

},{}],14:[function(require,module,exports){
module.exports = {
  Greyscale: require('./image_modes/greyscale.coffee'),
  RGB: require('./image_modes/rgb.coffee'),
  CMYK: require('./image_modes/cmyk.coffee')
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGUuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxTQUFBLEVBQVcsT0FBQSxDQUFRLGdDQUFSLENBQVg7RUFDQSxHQUFBLEVBQUssT0FBQSxDQUFRLDBCQUFSLENBREw7RUFFQSxJQUFBLEVBQU0sT0FBQSxDQUFRLDJCQUFSLENBRk4ifQ==

},{"./image_modes/cmyk.coffee":15,"./image_modes/greyscale.coffee":16,"./image_modes/rgb.coffee":17}],15:[function(require,module,exports){
var Color;

Color = require('../color.coffee');

module.exports = {
  setCmykChannels: function() {
    this.channelsInfo = [
      {
        id: 0
      }, {
        id: 1
      }, {
        id: 2
      }, {
        id: 3
      }
    ];
    if (this.channels() === 5) {
      return this.channelsInfo.push({
        id: -1
      });
    }
  },
  combineCmykChannel: function() {
    var a, b, c, chan, cmykChannels, g, i, index, j, k, l, len, m, r, ref, ref1, val, y;
    cmykChannels = this.channelsInfo.map(function(ch) {
      return ch.id;
    }).filter(function(ch) {
      return ch >= -1;
    });
    for (i = j = 0, ref = this.numPixels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      c = m = y = k = 0;
      a = 255;
      for (index = l = 0, len = cmykChannels.length; l < len; index = ++l) {
        chan = cmykChannels[index];
        val = this.channelData[i + (this.channelLength * index)];
        switch (chan) {
          case -1:
            a = val;
            break;
          case 0:
            c = val;
            break;
          case 1:
            m = val;
            break;
          case 2:
            y = val;
            break;
          case 3:
            k = val;
        }
      }
      ref1 = Color.cmykToRgb(255 - c, 255 - m, 255 - y, 255 - k), r = ref1[0], g = ref1[1], b = ref1[2];
      this.pixelData.set([r, g, b, a], i * 4);
    }
    return this.readMaskData(cmykChannels);
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGVzL2NteWsuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGVzL2NteWsuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsS0FBQSxHQUFRLE9BQUEsQ0FBUSxpQkFBUjs7QUFDUixNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsZUFBQSxFQUFpQixTQUFBO0lBQ2YsSUFBQyxDQUFBLFlBQUQsR0FBZ0I7TUFDZDtRQUFFLEVBQUEsRUFBSSxDQUFOO09BRGMsRUFFZDtRQUFFLEVBQUEsRUFBSSxDQUFOO09BRmMsRUFHZDtRQUFFLEVBQUEsRUFBSSxDQUFOO09BSGMsRUFJZDtRQUFFLEVBQUEsRUFBSSxDQUFOO09BSmM7O0lBT2hCLElBQWlDLElBQUMsQ0FBQSxRQUFELENBQUEsQ0FBQSxLQUFlLENBQWhEO2FBQUEsSUFBQyxDQUFBLFlBQVksQ0FBQyxJQUFkLENBQW1CO1FBQUUsRUFBQSxFQUFJLENBQUMsQ0FBUDtPQUFuQixFQUFBOztFQVJlLENBQWpCO0VBVUEsa0JBQUEsRUFBb0IsU0FBQTtBQUNsQixRQUFBO0lBQUEsWUFBQSxHQUFlLElBQUMsQ0FBQSxZQUNkLENBQUMsR0FEWSxDQUNSLFNBQUMsRUFBRDthQUFRLEVBQUUsQ0FBQztJQUFYLENBRFEsQ0FFYixDQUFDLE1BRlksQ0FFTCxTQUFDLEVBQUQ7YUFBUSxFQUFBLElBQU0sQ0FBQztJQUFmLENBRks7QUFJZixTQUFTLHVGQUFUO01BQ0UsQ0FBQSxHQUFJLENBQUEsR0FBSSxDQUFBLEdBQUksQ0FBQSxHQUFJO01BQ2hCLENBQUEsR0FBSTtBQUVKLFdBQUEsOERBQUE7O1FBQ0UsR0FBQSxHQUFNLElBQUMsQ0FBQSxXQUFZLENBQUEsQ0FBQSxHQUFJLENBQUMsSUFBQyxDQUFBLGFBQUQsR0FBaUIsS0FBbEIsQ0FBSjtBQUVuQixnQkFBTyxJQUFQO0FBQUEsZUFDTyxDQUFDLENBRFI7WUFDZSxDQUFBLEdBQUk7QUFBWjtBQURQLGVBRU8sQ0FGUDtZQUVjLENBQUEsR0FBSTtBQUFYO0FBRlAsZUFHTyxDQUhQO1lBR2MsQ0FBQSxHQUFJO0FBQVg7QUFIUCxlQUlPLENBSlA7WUFJYyxDQUFBLEdBQUk7QUFBWDtBQUpQLGVBS08sQ0FMUDtZQUtjLENBQUEsR0FBSTtBQUxsQjtBQUhGO01BVUEsT0FBWSxLQUFLLENBQUMsU0FBTixDQUFnQixHQUFBLEdBQU0sQ0FBdEIsRUFBeUIsR0FBQSxHQUFNLENBQS9CLEVBQWtDLEdBQUEsR0FBTSxDQUF4QyxFQUEyQyxHQUFBLEdBQU0sQ0FBakQsQ0FBWixFQUFDLFdBQUQsRUFBSSxXQUFKLEVBQU87TUFDUCxJQUFDLENBQUEsU0FBUyxDQUFDLEdBQVgsQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBZixFQUE2QixDQUFBLEdBQUUsQ0FBL0I7QUFmRjtXQWlCQSxJQUFDLENBQUEsWUFBRCxDQUFjLFlBQWQ7RUF0QmtCLENBVnBCIn0=

},{"../color.coffee":3}],16:[function(require,module,exports){
module.exports = {
  setGreyscaleChannels: function() {
    this.channelsInfo = [
      {
        id: 0
      }
    ];
    if (this.channels() === 2) {
      return this.channelsInfo.push({
        id: -1
      });
    }
  },
  combineGreyscaleChannel: function() {
    var alpha, grey, i, j, ref, results;
    results = [];
    for (i = j = 0, ref = this.numPixels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      grey = this.channelData[i];
      alpha = this.channels() === 2 ? this.channelData[this.channelLength + i] : 255;
      results.push(this.pixelData.set([grey, grey, grey, alpha], i * 4));
    }
    return results;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGVzL2dyZXlzY2FsZS5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvaW1hZ2VfbW9kZXMvZ3JleXNjYWxlLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsb0JBQUEsRUFBc0IsU0FBQTtJQUNwQixJQUFDLENBQUEsWUFBRCxHQUFnQjtNQUFDO1FBQUMsRUFBQSxFQUFJLENBQUw7T0FBRDs7SUFDaEIsSUFBK0IsSUFBQyxDQUFBLFFBQUQsQ0FBQSxDQUFBLEtBQWUsQ0FBOUM7YUFBQSxJQUFDLENBQUEsWUFBWSxDQUFDLElBQWQsQ0FBbUI7UUFBQyxFQUFBLEVBQUksQ0FBQyxDQUFOO09BQW5CLEVBQUE7O0VBRm9CLENBQXRCO0VBSUEsdUJBQUEsRUFBeUIsU0FBQTtBQUN2QixRQUFBO0FBQUE7U0FBUyx1RkFBVDtNQUNFLElBQUEsR0FBTyxJQUFDLENBQUEsV0FBWSxDQUFBLENBQUE7TUFDcEIsS0FBQSxHQUFXLElBQUMsQ0FBQSxRQUFELENBQUEsQ0FBQSxLQUFlLENBQWxCLEdBQ04sSUFBQyxDQUFBLFdBQVksQ0FBQSxJQUFDLENBQUEsYUFBRCxHQUFpQixDQUFqQixDQURQLEdBR047bUJBRUYsSUFBQyxDQUFBLFNBQVMsQ0FBQyxHQUFYLENBQWUsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsS0FBbkIsQ0FBZixFQUEwQyxDQUFBLEdBQUUsQ0FBNUM7QUFQRjs7RUFEdUIsQ0FKekIifQ==

},{}],17:[function(require,module,exports){
module.exports = {
  setRgbChannels: function() {
    this.channelsInfo = [
      {
        id: 0
      }, {
        id: 1
      }, {
        id: 2
      }
    ];
    if (this.channels() === 4) {
      return this.channelsInfo.push({
        id: -1
      });
    }
  },
  combineRgbChannel: function() {
    var a, b, chan, g, i, index, j, k, len, r, ref, rgbChannels, val;
    rgbChannels = this.channelsInfo.map(function(ch) {
      return ch.id;
    }).filter(function(ch) {
      return ch >= -1;
    });
    for (i = j = 0, ref = this.numPixels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      r = g = b = 0;
      a = 255;
      for (index = k = 0, len = rgbChannels.length; k < len; index = ++k) {
        chan = rgbChannels[index];
        val = this.channelData[i + (this.channelLength * index)];
        switch (chan) {
          case -1:
            a = val;
            break;
          case 0:
            r = val;
            break;
          case 1:
            g = val;
            break;
          case 2:
            b = val;
        }
      }
      this.pixelData.set([r, g, b, a], i * 4);
    }
    return this.readMaskData(rgbChannels);
  },
  readMaskData: function(rgbChannels) {
    var i, j, maskPixels, offset, ref, results, val;
    if (this.hasMask) {
      maskPixels = this.layer.mask.width * this.layer.mask.height;
      offset = this.channelLength * rgbChannels.length;
      results = [];
      for (i = j = 0, ref = maskPixels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        val = this.channelData[i + offset];
        results.push(this.maskData.set([0, 0, 0, val], i * 4));
      }
      return results;
    }
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2ltYWdlX21vZGVzL3JnYi5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvaW1hZ2VfbW9kZXMvcmdiLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsY0FBQSxFQUFnQixTQUFBO0lBQ2QsSUFBQyxDQUFBLFlBQUQsR0FBZ0I7TUFDZDtRQUFDLEVBQUEsRUFBSSxDQUFMO09BRGMsRUFFZDtRQUFDLEVBQUEsRUFBSSxDQUFMO09BRmMsRUFHZDtRQUFDLEVBQUEsRUFBSSxDQUFMO09BSGM7O0lBTWhCLElBQStCLElBQUMsQ0FBQSxRQUFELENBQUEsQ0FBQSxLQUFlLENBQTlDO2FBQUEsSUFBQyxDQUFBLFlBQVksQ0FBQyxJQUFkLENBQW1CO1FBQUMsRUFBQSxFQUFJLENBQUMsQ0FBTjtPQUFuQixFQUFBOztFQVBjLENBQWhCO0VBU0EsaUJBQUEsRUFBbUIsU0FBQTtBQUNqQixRQUFBO0lBQUEsV0FBQSxHQUFjLElBQUMsQ0FBQSxZQUNiLENBQUMsR0FEVyxDQUNQLFNBQUMsRUFBRDthQUFRLEVBQUUsQ0FBQztJQUFYLENBRE8sQ0FFWixDQUFDLE1BRlcsQ0FFSixTQUFDLEVBQUQ7YUFBUSxFQUFBLElBQU0sQ0FBQztJQUFmLENBRkk7QUFJZCxTQUFTLHVGQUFUO01BQ0UsQ0FBQSxHQUFJLENBQUEsR0FBSSxDQUFBLEdBQUk7TUFDWixDQUFBLEdBQUk7QUFFSixXQUFBLDZEQUFBOztRQUNFLEdBQUEsR0FBTSxJQUFDLENBQUEsV0FBWSxDQUFBLENBQUEsR0FBSSxDQUFDLElBQUMsQ0FBQSxhQUFELEdBQWlCLEtBQWxCLENBQUo7QUFFbkIsZ0JBQU8sSUFBUDtBQUFBLGVBQ08sQ0FBQyxDQURSO1lBQ2UsQ0FBQSxHQUFJO0FBQVo7QUFEUCxlQUVPLENBRlA7WUFFZSxDQUFBLEdBQUk7QUFBWjtBQUZQLGVBR08sQ0FIUDtZQUdlLENBQUEsR0FBSTtBQUFaO0FBSFAsZUFJTyxDQUpQO1lBSWUsQ0FBQSxHQUFJO0FBSm5CO0FBSEY7TUFRQSxJQUFDLENBQUEsU0FBUyxDQUFDLEdBQVgsQ0FBZSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBZixFQUE2QixDQUFBLEdBQUUsQ0FBL0I7QUFaRjtXQWNBLElBQUMsQ0FBQSxZQUFELENBQWMsV0FBZDtFQW5CaUIsQ0FUbkI7RUE4QkEsWUFBQSxFQUFjLFNBQUMsV0FBRDtBQUVaLFFBQUE7SUFBQSxJQUFHLElBQUMsQ0FBQSxPQUFKO01BQ0UsVUFBQSxHQUFhLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQVosR0FBb0IsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFJLENBQUM7TUFDN0MsTUFBQSxHQUFTLElBQUMsQ0FBQSxhQUFELEdBQWlCLFdBQVcsQ0FBQztBQUN0QztXQUFTLG1GQUFUO1FBQ0UsR0FBQSxHQUFNLElBQUMsQ0FBQSxXQUFZLENBQUEsQ0FBQSxHQUFJLE1BQUo7cUJBQ25CLElBQUMsQ0FBQSxRQUFRLENBQUMsR0FBVixDQUFjLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVixDQUFkLEVBQThCLENBQUEsR0FBRSxDQUFoQztBQUZGO3FCQUhGOztFQUZZLENBOUJkIn0=

},{}],18:[function(require,module,exports){
var Layer, Module,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Module = require('coffeescript-module').Module;

module.exports = Layer = (function(superClass) {
  extend(Layer, superClass);

  Layer.includes(require('./layer/position_channels.coffee'));

  Layer.includes(require('./layer/blend_modes.coffee'));

  Layer.includes(require('./layer/mask.coffee'));

  Layer.includes(require('./layer/blending_ranges.coffee'));

  Layer.includes(require('./layer/name.coffee'));

  Layer.includes(require('./layer/info.coffee'));

  Layer.includes(require('./layer/helpers.coffee'));

  Layer.includes(require('./layer/channel_image.coffee'));

  function Layer(file, header) {
    this.file = file;
    this.header = header;
    this.mask = {};
    this.blendingRanges = {};
    this.adjustments = {};
    this.channelsInfo = [];
    this.blendMode = {};
    this.groupLayer = null;
    this.infoKeys = [];
    Object.defineProperty(this, 'name', {
      get: function() {
        if (this.adjustments['name'] != null) {
          return this.adjustments['name'].data;
        } else {
          return this.legacyName;
        }
      }
    });
  }

  Layer.prototype.parse = function() {
    var extraLen;
    this.parsePositionAndChannels();
    this.parseBlendModes();
    extraLen = this.file.readInt();
    this.layerEnd = this.file.tell() + extraLen;
    this.parseMaskData();
    this.parseBlendingRanges();
    this.parseLegacyLayerName();
    this.parseLayerInfo();
    this.file.seek(this.layerEnd);
    return this;
  };

  Layer.prototype["export"] = function() {
    return {
      name: this.name,
      top: this.top,
      right: this.right,
      bottom: this.bottom,
      left: this.left,
      width: this.width,
      height: this.height,
      opacity: this.opacity,
      visible: this.visible,
      clipped: this.clipped,
      mask: this.mask["export"]()
    };
  };

  return Layer;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxhQUFBO0VBQUE7OztBQUFDLFNBQVUsT0FBQSxDQUFRLHFCQUFSOztBQUtYLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFFckIsS0FBQyxDQUFBLFFBQUQsQ0FBVSxPQUFBLENBQVEsa0NBQVIsQ0FBVjs7RUFDQSxLQUFDLENBQUEsUUFBRCxDQUFVLE9BQUEsQ0FBUSw0QkFBUixDQUFWOztFQUNBLEtBQUMsQ0FBQSxRQUFELENBQVUsT0FBQSxDQUFRLHFCQUFSLENBQVY7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxPQUFBLENBQVEsZ0NBQVIsQ0FBVjs7RUFDQSxLQUFDLENBQUEsUUFBRCxDQUFVLE9BQUEsQ0FBUSxxQkFBUixDQUFWOztFQUNBLEtBQUMsQ0FBQSxRQUFELENBQVUsT0FBQSxDQUFRLHFCQUFSLENBQVY7O0VBQ0EsS0FBQyxDQUFBLFFBQUQsQ0FBVSxPQUFBLENBQVEsd0JBQVIsQ0FBVjs7RUFDQSxLQUFDLENBQUEsUUFBRCxDQUFVLE9BQUEsQ0FBUSw4QkFBUixDQUFWOztFQUVhLGVBQUMsSUFBRCxFQUFRLE1BQVI7SUFBQyxJQUFDLENBQUEsT0FBRDtJQUFPLElBQUMsQ0FBQSxTQUFEO0lBQ25CLElBQUMsQ0FBQSxJQUFELEdBQVE7SUFDUixJQUFDLENBQUEsY0FBRCxHQUFrQjtJQUNsQixJQUFDLENBQUEsV0FBRCxHQUFlO0lBQ2YsSUFBQyxDQUFBLFlBQUQsR0FBZ0I7SUFDaEIsSUFBQyxDQUFBLFNBQUQsR0FBYTtJQUNiLElBQUMsQ0FBQSxVQUFELEdBQWM7SUFFZCxJQUFDLENBQUEsUUFBRCxHQUFZO0lBSVosTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBeUIsTUFBekIsRUFDRTtNQUFBLEdBQUEsRUFBSyxTQUFBO1FBQ0gsSUFBRyxnQ0FBSDtpQkFDRSxJQUFDLENBQUEsV0FBWSxDQUFBLE1BQUEsQ0FBTyxDQUFDLEtBRHZCO1NBQUEsTUFBQTtpQkFHRSxJQUFDLENBQUEsV0FISDs7TUFERyxDQUFMO0tBREY7RUFaVzs7a0JBcUJiLEtBQUEsR0FBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLElBQUMsQ0FBQSx3QkFBRCxDQUFBO0lBQ0EsSUFBQyxDQUFBLGVBQUQsQ0FBQTtJQUVBLFFBQUEsR0FBVyxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNYLElBQUMsQ0FBQSxRQUFELEdBQVksSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlO0lBRTNCLElBQUMsQ0FBQSxhQUFELENBQUE7SUFDQSxJQUFDLENBQUEsbUJBQUQsQ0FBQTtJQUNBLElBQUMsQ0FBQSxvQkFBRCxDQUFBO0lBQ0EsSUFBQyxDQUFBLGNBQUQsQ0FBQTtJQUVBLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLElBQUMsQ0FBQSxRQUFaO0FBQ0EsV0FBTztFQWJGOzttQkFlUCxRQUFBLEdBQVEsU0FBQTtXQUNOO01BQUEsSUFBQSxFQUFNLElBQUMsQ0FBQSxJQUFQO01BQ0EsR0FBQSxFQUFLLElBQUMsQ0FBQSxHQUROO01BRUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxLQUZSO01BR0EsTUFBQSxFQUFRLElBQUMsQ0FBQSxNQUhUO01BSUEsSUFBQSxFQUFNLElBQUMsQ0FBQSxJQUpQO01BS0EsS0FBQSxFQUFPLElBQUMsQ0FBQSxLQUxSO01BTUEsTUFBQSxFQUFRLElBQUMsQ0FBQSxNQU5UO01BT0EsT0FBQSxFQUFTLElBQUMsQ0FBQSxPQVBWO01BUUEsT0FBQSxFQUFTLElBQUMsQ0FBQSxPQVJWO01BU0EsT0FBQSxFQUFTLElBQUMsQ0FBQSxPQVRWO01BVUEsSUFBQSxFQUFNLElBQUMsQ0FBQSxJQUFJLEVBQUMsTUFBRCxFQUFMLENBQUEsQ0FWTjs7RUFETTs7OztHQS9DMkIifQ==

},{"./layer/blend_modes.coffee":19,"./layer/blending_ranges.coffee":20,"./layer/channel_image.coffee":21,"./layer/helpers.coffee":22,"./layer/info.coffee":23,"./layer/mask.coffee":24,"./layer/name.coffee":25,"./layer/position_channels.coffee":26,"coffeescript-module":70}],19:[function(require,module,exports){
var BlendMode;

BlendMode = require('../blend_mode.coffee');

module.exports = {
  parseBlendModes: function() {
    this.blendMode = new BlendMode(this.file);
    this.blendMode.parse();
    this.opacity = this.blendMode.opacity;
    this.visible = this.blendMode.visible;
    return this.clipped = this.blendMode.clipped;
  },
  hidden: function() {
    return !this.visible;
  },
  blendingMode: function() {
    return this.blendMode.mode;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2JsZW5kX21vZGVzLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllci9ibGVuZF9tb2Rlcy5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBS0U7RUFBQSxlQUFBLEVBQWlCLFNBQUE7SUFDZixJQUFDLENBQUEsU0FBRCxHQUFhLElBQUksU0FBSixDQUFjLElBQUMsQ0FBQSxJQUFmO0lBQ2IsSUFBQyxDQUFBLFNBQVMsQ0FBQyxLQUFYLENBQUE7SUFFQSxJQUFDLENBQUEsT0FBRCxHQUFXLElBQUMsQ0FBQSxTQUFTLENBQUM7SUFDdEIsSUFBQyxDQUFBLE9BQUQsR0FBVyxJQUFDLENBQUEsU0FBUyxDQUFDO1dBQ3RCLElBQUMsQ0FBQSxPQUFELEdBQVcsSUFBQyxDQUFBLFNBQVMsQ0FBQztFQU5QLENBQWpCO0VBUUEsTUFBQSxFQUFRLFNBQUE7V0FBRyxDQUFJLElBQUMsQ0FBQTtFQUFSLENBUlI7RUFXQSxZQUFBLEVBQWMsU0FBQTtXQUNaLElBQUMsQ0FBQSxTQUFTLENBQUM7RUFEQyxDQVhkIn0=

},{"../blend_mode.coffee":1}],20:[function(require,module,exports){
module.exports = {
  parseBlendingRanges: function() {
    var i, j, length, numChannels, ref, results;
    length = this.file.readInt();
    if (length === 0) {
      return;
    }
    this.blendingRanges.grey = {
      source: {
        black: [this.file.readByte(), this.file.readByte()],
        white: [this.file.readByte(), this.file.readByte()]
      },
      dest: {
        black: [this.file.readByte(), this.file.readByte()],
        white: [this.file.readByte(), this.file.readByte()]
      }
    };
    numChannels = (length - 8) / 8;
    this.blendingRanges.channels = [];
    results = [];
    for (i = j = 0, ref = numChannels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(this.blendingRanges.channels.push({
        source: {
          black: [this.file.readByte(), this.file.readByte()],
          white: [this.file.readByte(), this.file.readByte()]
        },
        dest: {
          black: [this.file.readByte(), this.file.readByte()],
          white: [this.file.readByte(), this.file.readByte()]
        }
      }));
    }
    return results;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2JsZW5kaW5nX3Jhbmdlcy5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvbGF5ZXIvYmxlbmRpbmdfcmFuZ2VzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBUCxHQUlFO0VBQUEsbUJBQUEsRUFBcUIsU0FBQTtBQUNuQixRQUFBO0lBQUEsTUFBQSxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0lBQ1QsSUFBRyxNQUFBLEtBQVUsQ0FBYjtBQUNFLGFBREY7O0lBR0EsSUFBQyxDQUFBLGNBQWMsQ0FBQyxJQUFoQixHQUNFO01BQUEsTUFBQSxFQUNFO1FBQUEsS0FBQSxFQUFPLENBQUMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBRCxFQUFtQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFuQixDQUFQO1FBQ0EsS0FBQSxFQUFPLENBQUMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBRCxFQUFtQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFuQixDQURQO09BREY7TUFHQSxJQUFBLEVBQ0U7UUFBQSxLQUFBLEVBQU8sQ0FBQyxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFELEVBQW1CLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQW5CLENBQVA7UUFDQSxLQUFBLEVBQU8sQ0FBQyxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFELEVBQW1CLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQW5CLENBRFA7T0FKRjs7SUFPRixXQUFBLEdBQWMsQ0FBQyxNQUFBLEdBQVMsQ0FBVixDQUFBLEdBQWU7SUFFN0IsSUFBQyxDQUFBLGNBQWMsQ0FBQyxRQUFoQixHQUEyQjtBQUMzQjtTQUFTLG9GQUFUO21CQUNFLElBQUMsQ0FBQSxjQUFjLENBQUMsUUFBUSxDQUFDLElBQXpCLENBQ0U7UUFBQSxNQUFBLEVBQ0U7VUFBQSxLQUFBLEVBQU8sQ0FBQyxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFELEVBQW1CLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQW5CLENBQVA7VUFDQSxLQUFBLEVBQU8sQ0FBQyxJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQSxDQUFELEVBQW1CLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQW5CLENBRFA7U0FERjtRQUdBLElBQUEsRUFDRTtVQUFBLEtBQUEsRUFBTyxDQUFDLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQUQsRUFBbUIsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBbkIsQ0FBUDtVQUNBLEtBQUEsRUFBTyxDQUFDLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQUQsRUFBbUIsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBbkIsQ0FEUDtTQUpGO09BREY7QUFERjs7RUFoQm1CLENBQXJCIn0=

},{}],21:[function(require,module,exports){
var ChannelImage, LazyExecute;

ChannelImage = require('../channel_image.coffee');

LazyExecute = require('../lazy_execute.coffee');

module.exports = {
  parseChannelImage: function() {
    var image;
    image = new ChannelImage(this.file, this.header, this);
    return this.image = new LazyExecute(image, this.file).now('skip').later('parse').get();
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2NoYW5uZWxfaW1hZ2UuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2NoYW5uZWxfaW1hZ2UuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsWUFBQSxHQUFlLE9BQUEsQ0FBUSx5QkFBUjs7QUFDZixXQUFBLEdBQWUsT0FBQSxDQUFRLHdCQUFSOztBQUVmLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxpQkFBQSxFQUFtQixTQUFBO0FBQ2pCLFFBQUE7SUFBQSxLQUFBLEdBQVEsSUFBSSxZQUFKLENBQWlCLElBQUMsQ0FBQSxJQUFsQixFQUF3QixJQUFDLENBQUEsTUFBekIsRUFBaUMsSUFBakM7V0FDUixJQUFDLENBQUEsS0FBRCxHQUFTLElBQUksV0FBSixDQUFnQixLQUFoQixFQUF1QixJQUFDLENBQUEsSUFBeEIsQ0FDUCxDQUFDLEdBRE0sQ0FDRixNQURFLENBRVAsQ0FBQyxLQUZNLENBRUEsT0FGQSxDQUdQLENBQUMsR0FITSxDQUFBO0VBRlEsQ0FBbkIifQ==

},{"../channel_image.coffee":2,"../lazy_execute.coffee":49}],22:[function(require,module,exports){
module.exports = {
  isFolder: function() {
    if (this.adjustments['sectionDivider'] != null) {
      return this.adjustments['sectionDivider'].isFolder;
    } else if (this.adjustments['nestedSectionDivider'] != null) {
      return this.adjustments['nestedSectionDivider'].isFolder;
    } else {
      return this.name === "<Layer group>";
    }
  },
  isFolderEnd: function() {
    if (this.adjustments['sectionDivider'] != null) {
      return this.adjustments['sectionDivider'].isHidden;
    } else if (this.adjustments['nestedSectionDivider'] != null) {
      return this.adjustments['nestedSectionDivider'].isHidden;
    } else {
      return this.name === "</Layer group>";
    }
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2hlbHBlcnMuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2hlbHBlcnMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxRQUFBLEVBQVUsU0FBQTtJQUNSLElBQUcsMENBQUg7YUFDRSxJQUFDLENBQUEsV0FBWSxDQUFBLGdCQUFBLENBQWlCLENBQUMsU0FEakM7S0FBQSxNQUVLLElBQUcsZ0RBQUg7YUFDSCxJQUFDLENBQUEsV0FBWSxDQUFBLHNCQUFBLENBQXVCLENBQUMsU0FEbEM7S0FBQSxNQUFBO2FBR0gsSUFBQyxDQUFBLElBQUQsS0FBUyxnQkFITjs7RUFIRyxDQUFWO0VBUUEsV0FBQSxFQUFhLFNBQUE7SUFDWCxJQUFHLDBDQUFIO2FBQ0UsSUFBQyxDQUFBLFdBQVksQ0FBQSxnQkFBQSxDQUFpQixDQUFDLFNBRGpDO0tBQUEsTUFFSyxJQUFHLGdEQUFIO2FBQ0gsSUFBQyxDQUFBLFdBQVksQ0FBQSxzQkFBQSxDQUF1QixDQUFDLFNBRGxDO0tBQUEsTUFBQTthQUdILElBQUMsQ0FBQSxJQUFELEtBQVMsaUJBSE47O0VBSE0sQ0FSYiJ9

},{}],23:[function(require,module,exports){
var LAYER_INFO, LazyExecute, Util,
  hasProp = {}.hasOwnProperty;

LazyExecute = require('../lazy_execute.coffee');

Util = require('../util.coffee');

LAYER_INFO = {
  artboard: require('../layer_info/artboard.coffee'),
  blendClippingElements: require('../layer_info/blend_clipping_elements.coffee'),
  blendInteriorElements: require('../layer_info/blend_interior_elements.coffee'),
  fillOpacity: require('../layer_info/fill_opacity.coffee'),
  gradientFill: require('../layer_info/gradient_fill.coffee'),
  layerId: require('../layer_info/layer_id.coffee'),
  layerNameSource: require('../layer_info/layer_name_source.coffee'),
  legacyTypetool: require('../layer_info/legacy_typetool.coffee'),
  locked: require('../layer_info/locked.coffee'),
  metadata: require('../layer_info/metadata.coffee'),
  name: require('../layer_info/unicode_name.coffee'),
  nestedSectionDivider: require('../layer_info/nested_section_divider.coffee'),
  objectEffects: require('../layer_info/object_effects.coffee'),
  sectionDivider: require('../layer_info/section_divider.coffee'),
  solidColor: require('../layer_info/solid_color.coffee'),
  typeTool: require('../layer_info/typetool.coffee'),
  vectorMask: require('../layer_info/vector_mask.coffee'),
  vectorOrigination: require('../layer_info/vector_origination.coffee'),
  vectorStroke: require('../layer_info/vector_stroke.coffee'),
  vectorStrokeContent: require('../layer_info/vector_stroke_content.coffee')
};

module.exports = {
  parseLayerInfo: function() {
    var i, key, keyParseable, klass, length, name, pos, results;
    results = [];
    while (this.file.tell() < this.layerEnd) {
      this.file.seek(4, true);
      key = this.file.readString(4);
      length = Util.pad2(this.file.readInt());
      pos = this.file.tell();
      keyParseable = false;
      for (name in LAYER_INFO) {
        if (!hasProp.call(LAYER_INFO, name)) continue;
        klass = LAYER_INFO[name];
        if (!klass.shouldParse(key)) {
          continue;
        }
        i = new klass(this, length);
        this.adjustments[name] = new LazyExecute(i, this.file).now('skip').later('parse').get();
        if (this[name] == null) {
          (function(_this) {
            return (function(name) {
              return _this[name] = function() {
                return _this.adjustments[name];
              };
            });
          })(this)(name);
        }
        this.infoKeys.push(key);
        keyParseable = true;
        break;
      }
      if (!keyParseable) {
        results.push(this.file.seek(length, true));
      } else {
        results.push(void 0);
      }
    }
    return results;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2luZm8uY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL2luZm8uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsNkJBQUE7RUFBQTs7QUFBQSxXQUFBLEdBQWMsT0FBQSxDQUFRLHdCQUFSOztBQUNkLElBQUEsR0FBTyxPQUFBLENBQVEsZ0JBQVI7O0FBZVAsVUFBQSxHQUFhO0VBQ1gsUUFBQSxFQUF3QixPQUFBLENBQVEsK0JBQVIsQ0FEYjtFQUVYLHFCQUFBLEVBQXdCLE9BQUEsQ0FBUSw4Q0FBUixDQUZiO0VBR1gscUJBQUEsRUFBd0IsT0FBQSxDQUFRLDhDQUFSLENBSGI7RUFJWCxXQUFBLEVBQXdCLE9BQUEsQ0FBUSxtQ0FBUixDQUpiO0VBS1gsWUFBQSxFQUF3QixPQUFBLENBQVEsb0NBQVIsQ0FMYjtFQU1YLE9BQUEsRUFBd0IsT0FBQSxDQUFRLCtCQUFSLENBTmI7RUFPWCxlQUFBLEVBQXdCLE9BQUEsQ0FBUSx3Q0FBUixDQVBiO0VBUVgsY0FBQSxFQUF3QixPQUFBLENBQVEsc0NBQVIsQ0FSYjtFQVNYLE1BQUEsRUFBd0IsT0FBQSxDQUFRLDZCQUFSLENBVGI7RUFVWCxRQUFBLEVBQXdCLE9BQUEsQ0FBUSwrQkFBUixDQVZiO0VBV1gsSUFBQSxFQUF3QixPQUFBLENBQVEsbUNBQVIsQ0FYYjtFQVlYLG9CQUFBLEVBQXdCLE9BQUEsQ0FBUSw2Q0FBUixDQVpiO0VBYVgsYUFBQSxFQUF3QixPQUFBLENBQVEscUNBQVIsQ0FiYjtFQWNYLGNBQUEsRUFBd0IsT0FBQSxDQUFRLHNDQUFSLENBZGI7RUFlWCxVQUFBLEVBQXdCLE9BQUEsQ0FBUSxrQ0FBUixDQWZiO0VBZ0JYLFFBQUEsRUFBd0IsT0FBQSxDQUFRLCtCQUFSLENBaEJiO0VBaUJYLFVBQUEsRUFBd0IsT0FBQSxDQUFRLGtDQUFSLENBakJiO0VBa0JYLGlCQUFBLEVBQXdCLE9BQUEsQ0FBUSx5Q0FBUixDQWxCYjtFQW1CWCxZQUFBLEVBQXdCLE9BQUEsQ0FBUSxvQ0FBUixDQW5CYjtFQW9CWCxtQkFBQSxFQUF3QixPQUFBLENBQVEsNENBQVIsQ0FwQmI7OztBQXVCYixNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsY0FBQSxFQUFnQixTQUFBO0FBR2QsUUFBQTtBQUFBO1dBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlLElBQUMsQ0FBQSxRQUF0QjtNQUNFLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO01BR0EsR0FBQSxHQUFNLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFpQixDQUFqQjtNQUNOLE1BQUEsR0FBUyxJQUFJLENBQUMsSUFBTCxDQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBLENBQVY7TUFDVCxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUE7TUFFTixZQUFBLEdBQWU7QUFDZixXQUFBLGtCQUFBOzs7UUFDRSxJQUFBLENBQWdCLEtBQUssQ0FBQyxXQUFOLENBQWtCLEdBQWxCLENBQWhCO0FBQUEsbUJBQUE7O1FBS0EsQ0FBQSxHQUFJLElBQUksS0FBSixDQUFVLElBQVYsRUFBYSxNQUFiO1FBQ0osSUFBQyxDQUFBLFdBQVksQ0FBQSxJQUFBLENBQWIsR0FBcUIsSUFBSSxXQUFKLENBQWdCLENBQWhCLEVBQW1CLElBQUMsQ0FBQSxJQUFwQixDQUNuQixDQUFDLEdBRGtCLENBQ2QsTUFEYyxDQUVuQixDQUFDLEtBRmtCLENBRVosT0FGWSxDQUduQixDQUFDLEdBSGtCLENBQUE7UUFNckIsSUFBTyxrQkFBUDtVQUNLLENBQUEsU0FBQSxLQUFBO21CQUFBLENBQUEsU0FBQyxJQUFEO3FCQUFVLEtBQUUsQ0FBQSxJQUFBLENBQUYsR0FBVSxTQUFBO3VCQUFHLEtBQUMsQ0FBQSxXQUFZLENBQUEsSUFBQTtjQUFoQjtZQUFwQixDQUFBO1VBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFILENBQUksSUFBSixFQURGOztRQUlBLElBQUMsQ0FBQSxRQUFRLENBQUMsSUFBVixDQUFlLEdBQWY7UUFDQSxZQUFBLEdBQWU7QUFDZjtBQW5CRjtNQXVCQSxJQUEyQixDQUFJLFlBQS9CO3FCQUFBLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLE1BQVgsRUFBbUIsSUFBbkIsR0FBQTtPQUFBLE1BQUE7NkJBQUE7O0lBaENGLENBQUE7O0VBSGMsQ0FBaEIifQ==

},{"../layer_info/artboard.coffee":28,"../layer_info/blend_clipping_elements.coffee":29,"../layer_info/blend_interior_elements.coffee":30,"../layer_info/fill_opacity.coffee":31,"../layer_info/gradient_fill.coffee":32,"../layer_info/layer_id.coffee":33,"../layer_info/layer_name_source.coffee":34,"../layer_info/legacy_typetool.coffee":35,"../layer_info/locked.coffee":36,"../layer_info/metadata.coffee":37,"../layer_info/nested_section_divider.coffee":38,"../layer_info/object_effects.coffee":39,"../layer_info/section_divider.coffee":40,"../layer_info/solid_color.coffee":41,"../layer_info/typetool.coffee":42,"../layer_info/unicode_name.coffee":43,"../layer_info/vector_mask.coffee":44,"../layer_info/vector_origination.coffee":45,"../layer_info/vector_stroke.coffee":46,"../layer_info/vector_stroke_content.coffee":47,"../lazy_execute.coffee":49,"../util.coffee":65}],24:[function(require,module,exports){
var Mask;

Mask = require('../mask.coffee');

module.exports = {
  parseMaskData: function() {
    return this.mask = new Mask(this.file).parse();
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL21hc2suY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL21hc2suY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxnQkFBUjs7QUFFUCxNQUFNLENBQUMsT0FBUCxHQUlFO0VBQUEsYUFBQSxFQUFlLFNBQUE7V0FDYixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUksSUFBSixDQUFTLElBQUMsQ0FBQSxJQUFWLENBQWUsQ0FBQyxLQUFoQixDQUFBO0VBREssQ0FBZiJ9

},{"../mask.coffee":50}],25:[function(require,module,exports){
var Util;

Util = require('../util.coffee');

module.exports = {
  parseLegacyLayerName: function() {
    var len;
    len = Util.pad4(this.file.readByte());
    return this.legacyName = this.file.readString(len);
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL25hbWUuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL25hbWUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxnQkFBUjs7QUFFUCxNQUFNLENBQUMsT0FBUCxHQU9FO0VBQUEsb0JBQUEsRUFBc0IsU0FBQTtBQUNwQixRQUFBO0lBQUEsR0FBQSxHQUFNLElBQUksQ0FBQyxJQUFMLENBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBVjtXQUNOLElBQUMsQ0FBQSxVQUFELEdBQWMsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQWlCLEdBQWpCO0VBRk0sQ0FBdEIifQ==

},{"../util.coffee":65}],26:[function(require,module,exports){
module.exports = {
  parsePositionAndChannels: function() {
    var i, id, j, length, ref, results;
    this.top = this.file.readInt();
    this.left = this.file.readInt();
    this.bottom = this.file.readInt();
    this.right = this.file.readInt();
    this.channels = this.file.readShort();
    this.rows = this.height = this.bottom - this.top;
    this.cols = this.width = this.right - this.left;
    results = [];
    for (i = j = 0, ref = this.channels; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      id = this.file.readShort();
      length = this.file.readInt();
      results.push(this.channelsInfo.push({
        id: id,
        length: length
      }));
    }
    return results;
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyL3Bvc2l0aW9uX2NoYW5uZWxzLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllci9wb3NpdGlvbl9jaGFubmVscy5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE9BQVAsR0FJRTtFQUFBLHdCQUFBLEVBQTBCLFNBQUE7QUFDeEIsUUFBQTtJQUFBLElBQUMsQ0FBQSxHQUFELEdBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFDUCxJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0lBQ1IsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNWLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFDVCxJQUFDLENBQUEsUUFBRCxHQUFZLElBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBO0lBRVosSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBO0lBQzdCLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBQyxDQUFBLEtBQUQsR0FBUyxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQTtBQUszQjtTQUFTLHNGQUFUO01BQ0UsRUFBQSxHQUFLLElBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBO01BQ0wsTUFBQSxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO21CQUVULElBQUMsQ0FBQSxZQUFZLENBQUMsSUFBZCxDQUFtQjtRQUFBLEVBQUEsRUFBSSxFQUFKO1FBQVEsTUFBQSxFQUFRLE1BQWhCO09BQW5CO0FBSkY7O0VBYndCLENBQTFCIn0=

},{}],27:[function(require,module,exports){
var LayerInfo;

module.exports = LayerInfo = (function() {
  function LayerInfo(layer, length) {
    this.layer = layer;
    this.length = length;
    this.file = this.layer.file;
    this.section_end = this.file.tell() + this.length;
    this.data = {};
  }

  LayerInfo.prototype.skip = function() {
    return this.file.seek(this.section_end);
  };

  LayerInfo.prototype.parse = function() {
    return this.skip();
  };

  return LayerInfo;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8uY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFDUixtQkFBQyxLQUFELEVBQVMsTUFBVDtJQUFDLElBQUMsQ0FBQSxRQUFEO0lBQVEsSUFBQyxDQUFBLFNBQUQ7SUFDcEIsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsS0FBSyxDQUFDO0lBQ2YsSUFBQyxDQUFBLFdBQUQsR0FBZSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBQSxDQUFBLEdBQWUsSUFBQyxDQUFBO0lBQy9CLElBQUMsQ0FBQSxJQUFELEdBQVE7RUFIRzs7c0JBS2IsSUFBQSxHQUFNLFNBQUE7V0FBRyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxJQUFDLENBQUEsV0FBWjtFQUFIOztzQkFDTixLQUFBLEdBQU8sU0FBQTtXQUFHLElBQUMsQ0FBQSxJQUFELENBQUE7RUFBSCJ9

},{}],28:[function(require,module,exports){
var Artboard, Descriptor, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = Artboard = (function(superClass) {
  extend(Artboard, superClass);

  function Artboard() {
    return Artboard.__super__.constructor.apply(this, arguments);
  }

  Artboard.shouldParse = function(key) {
    return key === 'artb';
  };

  Artboard.prototype.parse = function() {
    this.file.seek(4, true);
    return this.data = new Descriptor(this.file).parse();
  };

  Artboard.prototype["export"] = function() {
    return {
      coords: {
        left: this.data.artboardRect['Left'],
        top: this.data.artboardRect['Top '],
        right: this.data.artboardRect['Rght'],
        bottom: this.data.artboardRect['Btom']
      }
    };
  };

  return Artboard;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYXJ0Ym9hcmQuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYXJ0Ym9hcmQuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsK0JBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFDWixVQUFBLEdBQWEsT0FBQSxDQUFRLHNCQUFSOztBQUViLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O0VBQ3JCLFFBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOztxQkFFZCxLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO1dBQ0EsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFJLFVBQUosQ0FBZSxJQUFDLENBQUEsSUFBaEIsQ0FBcUIsQ0FBQyxLQUF0QixDQUFBO0VBRkg7O3NCQUlQLFFBQUEsR0FBUSxTQUFBO1dBQ047TUFBQSxNQUFBLEVBQ0U7UUFBQSxJQUFBLEVBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxZQUFhLENBQUEsTUFBQSxDQUF6QjtRQUNBLEdBQUEsRUFBSyxJQUFDLENBQUEsSUFBSSxDQUFDLFlBQWEsQ0FBQSxNQUFBLENBRHhCO1FBRUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxJQUFJLENBQUMsWUFBYSxDQUFBLE1BQUEsQ0FGMUI7UUFHQSxNQUFBLEVBQVEsSUFBQyxDQUFBLElBQUksQ0FBQyxZQUFhLENBQUEsTUFBQSxDQUgzQjtPQURGOztFQURNOzs7O0dBUDhCIn0=

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],29:[function(require,module,exports){
var BlendClippingElements, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = BlendClippingElements = (function(superClass) {
  extend(BlendClippingElements, superClass);

  function BlendClippingElements() {
    return BlendClippingElements.__super__.constructor.apply(this, arguments);
  }

  BlendClippingElements.shouldParse = function(key) {
    return key === 'clbl';
  };

  BlendClippingElements.prototype.parse = function() {
    this.enabled = this.file.readBoolean();
    return this.file.seek(3, true);
  };

  return BlendClippingElements;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYmxlbmRfY2xpcHBpbmdfZWxlbWVudHMuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYmxlbmRfY2xpcHBpbmdfZWxlbWVudHMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsZ0NBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFFWixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixxQkFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O2tDQUVkLEtBQUEsR0FBTyxTQUFBO0lBQ0wsSUFBQyxDQUFBLE9BQUQsR0FBVyxJQUFDLENBQUEsSUFBSSxDQUFDLFdBQU4sQ0FBQTtXQUNYLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO0VBRks7Ozs7R0FINEMifQ==

},{"../layer_info.coffee":27}],30:[function(require,module,exports){
var BlendInteriorElements, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = BlendInteriorElements = (function(superClass) {
  extend(BlendInteriorElements, superClass);

  function BlendInteriorElements() {
    return BlendInteriorElements.__super__.constructor.apply(this, arguments);
  }

  BlendInteriorElements.shouldParse = function(key) {
    return key === 'infx';
  };

  BlendInteriorElements.prototype.parse = function() {
    this.enabled = this.file.readBoolean();
    return this.file.seek(3, true);
  };

  return BlendInteriorElements;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYmxlbmRfaW50ZXJpb3JfZWxlbWVudHMuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vYmxlbmRfaW50ZXJpb3JfZWxlbWVudHMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsZ0NBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFFWixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixxQkFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O2tDQUVkLEtBQUEsR0FBTyxTQUFBO0lBQ0wsSUFBQyxDQUFBLE9BQUQsR0FBVyxJQUFDLENBQUEsSUFBSSxDQUFDLFdBQU4sQ0FBQTtXQUNYLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO0VBRks7Ozs7R0FINEMifQ==

},{"../layer_info.coffee":27}],31:[function(require,module,exports){
var FillOpacity, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = FillOpacity = (function(superClass) {
  extend(FillOpacity, superClass);

  function FillOpacity() {
    return FillOpacity.__super__.constructor.apply(this, arguments);
  }

  FillOpacity.shouldParse = function(key) {
    return key === 'iOpa';
  };

  FillOpacity.prototype.parse = function() {
    return this.value = this.file.readByte();
  };

  return FillOpacity;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vZmlsbF9vcGFjaXR5LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL2ZpbGxfb3BhY2l0eS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxzQkFBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O0VBQ3JCLFdBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOzt3QkFFZCxLQUFBLEdBQU8sU0FBQTtXQUNMLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUE7RUFESjs7OztHQUhrQyJ9

},{"../layer_info.coffee":27}],32:[function(require,module,exports){
var Descriptor, GradientFill, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = GradientFill = (function(superClass) {
  extend(GradientFill, superClass);

  function GradientFill() {
    return GradientFill.__super__.constructor.apply(this, arguments);
  }

  GradientFill.shouldParse = function(key) {
    return key === 'GdFl';
  };

  GradientFill.prototype.parse = function() {
    this.file.seek(4, true);
    return this.data = new Descriptor(this.file).parse();
  };

  return GradientFill;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vZ3JhZGllbnRfZmlsbC5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvbGF5ZXJfaW5mby9ncmFkaWVudF9maWxsLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBLG1DQUFBO0VBQUE7OztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsc0JBQVI7O0FBQ1osVUFBQSxHQUFhLE9BQUEsQ0FBUSxzQkFBUjs7QUFFYixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixZQUFDLENBQUEsV0FBRCxHQUFjLFNBQUMsR0FBRDtXQUFTLEdBQUEsS0FBTztFQUFoQjs7eUJBRWQsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtXQUNBLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBSSxVQUFKLENBQWUsSUFBQyxDQUFBLElBQWhCLENBQXFCLENBQUMsS0FBdEIsQ0FBQTtFQUZIOzs7O0dBSG1DIn0=

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],33:[function(require,module,exports){
var LayerId, LayerInfo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = LayerId = (function(superClass) {
  extend(LayerId, superClass);

  function LayerId() {
    return LayerId.__super__.constructor.apply(this, arguments);
  }

  LayerId.shouldParse = function(key) {
    return key === 'lyid';
  };

  LayerId.prototype.parse = function() {
    return this.id = this.file.readInt();
  };

  return LayerId;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbGF5ZXJfaWQuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbGF5ZXJfaWQuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsa0JBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFFWixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixPQUFDLENBQUEsV0FBRCxHQUFjLFNBQUMsR0FBRDtXQUFTLEdBQUEsS0FBTztFQUFoQjs7b0JBRWQsS0FBQSxHQUFPLFNBQUE7V0FDTCxJQUFDLENBQUEsRUFBRCxHQUFNLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0VBREQ7Ozs7R0FIOEIifQ==

},{"../layer_info.coffee":27}],34:[function(require,module,exports){
var LayerInfo, LayerNameSource,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = LayerNameSource = (function(superClass) {
  extend(LayerNameSource, superClass);

  function LayerNameSource() {
    return LayerNameSource.__super__.constructor.apply(this, arguments);
  }

  LayerNameSource.shouldParse = function(key) {
    return key === 'lnsr';
  };

  LayerNameSource.prototype.parse = function() {
    return this.id = this.file.readString(4);
  };

  return LayerNameSource;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbGF5ZXJfbmFtZV9zb3VyY2UuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbGF5ZXJfbmFtZV9zb3VyY2UuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsMEJBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFFWixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixlQUFDLENBQUEsV0FBRCxHQUFjLFNBQUMsR0FBRDtXQUFTLEdBQUEsS0FBTztFQUFoQjs7NEJBRWQsS0FBQSxHQUFPLFNBQUE7V0FDTCxJQUFDLENBQUEsRUFBRCxHQUFNLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFpQixDQUFqQjtFQUREOzs7O0dBSHNDIn0=

},{"../layer_info.coffee":27}],35:[function(require,module,exports){
var LegacyTypeTool, TypeTool, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

TypeTool = require('./typetool.coffee');

module.exports = LegacyTypeTool = (function(superClass) {
  extend(LegacyTypeTool, superClass);

  LegacyTypeTool.shouldParse = function(key) {
    return key === 'tySh';
  };

  function LegacyTypeTool(layer, length) {
    LegacyTypeTool.__super__.constructor.call(this, layer, length);
    this.transform = {};
    this.faces = [];
    this.styles = [];
    this.lines = [];
    this.type = 0;
    this.scalingFactor = 0;
    this.characterCount = 0;
    this.horzPlace = 0;
    this.vertPlace = 0;
    this.selectStart = 0;
    this.selectEnd = 0;
    this.color = null;
    this.antialias = null;
  }

  LegacyTypeTool.prototype.parse = function() {
    var facesCount, i, k, l, linesCount, m, ref, ref1, ref2, stylesCount;
    this.file.seek(2, true);
    this.parseTransformInfo();
    this.file.seek(2, true);
    facesCount = this.file.readShort();
    for (i = k = 0, ref = facesCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      this.faces.push(_({}).tap((function(_this) {
        return function(face) {
          var j, l, ref1, results;
          face.mark = _this.file.readShort();
          face.fontType = _this.file.readInt();
          face.fontName = _this.file.readString();
          face.fontFamilyName = _this.file.readString();
          face.fontStyleName = _this.file.readString();
          face.script = _this.file.readShort();
          face.numberAxesVector = _this.file.readInt();
          face.vector = [];
          results = [];
          for (j = l = 0, ref1 = face.numberAxesVector; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
            results.push(face.vector.push(_this.file.readInt()));
          }
          return results;
        };
      })(this)));
    }
    stylesCount = this.file.readShort();
    for (i = l = 0, ref1 = stylesCount; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      this.styles.push(_({}).tap((function(_this) {
        return function(style) {
          style.mark = _this.file.readShort();
          style.faceMark = _this.file.readShort();
          style.size = _this.file.readInt();
          style.tracking = _this.file.readInt();
          style.kerning = _this.file.readInt();
          style.leading = _this.file.readInt();
          style.baseShift = _this.file.readInt();
          style.autoKern = _this.file.readBoolean();
          _this.file.seek(1, true);
          return style.rotate = _this.file.readBoolean();
        };
      })(this)));
    }
    this.type = this.file.readShort();
    this.scalingFactor = this.file.readInt();
    this.characterCount = this.file.readInt();
    this.horzPlace = this.file.readInt();
    this.vertPlace = this.file.readInt();
    this.selectStart = this.file.readInt();
    this.selectEnd = this.file.readInt();
    linesCount = this.file.readShort();
    for (i = m = 0, ref2 = linesCount; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
      this.lines.push(_({}).tap(function(line) {
        line.charCount = this.file.readInt();
        line.orientation = this.file.readShort();
        line.alignment = this.file.readShort();
        line.actualChar = this.file.readShort();
        return line.style = this.file.readShort();
      }));
    }
    this.color = this.file.readSpaceColor();
    return this.antialias = this.file.readBoolean();
  };

  return LegacyTypeTool;

})(TypeTool);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbGVnYWN5X3R5cGV0b29sLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL2xlZ2FjeV90eXBldG9vbC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSwyQkFBQTtFQUFBOzs7QUFBQSxDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVI7O0FBQ0osUUFBQSxHQUFXLE9BQUEsQ0FBUSxtQkFBUjs7QUFFWCxNQUFNLENBQUMsT0FBUCxHQUF1Qjs7O0VBQ3JCLGNBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOztFQUVELHdCQUFDLEtBQUQsRUFBUSxNQUFSO0lBQ1gsZ0RBQU0sS0FBTixFQUFhLE1BQWI7SUFFQSxJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLEtBQUQsR0FBUztJQUNULElBQUMsQ0FBQSxNQUFELEdBQVU7SUFDVixJQUFDLENBQUEsS0FBRCxHQUFTO0lBQ1QsSUFBQyxDQUFBLElBQUQsR0FBUTtJQUNSLElBQUMsQ0FBQSxhQUFELEdBQWlCO0lBQ2pCLElBQUMsQ0FBQSxjQUFELEdBQWtCO0lBQ2xCLElBQUMsQ0FBQSxTQUFELEdBQWE7SUFDYixJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLFdBQUQsR0FBZTtJQUNmLElBQUMsQ0FBQSxTQUFELEdBQWE7SUFDYixJQUFDLENBQUEsS0FBRCxHQUFTO0lBQ1QsSUFBQyxDQUFBLFNBQUQsR0FBYTtFQWZGOzsyQkFpQmIsS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7SUFDQSxJQUFDLENBQUEsa0JBQUQsQ0FBQTtJQUdBLElBQUMsQ0FBQSxJ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

},{"./typetool.coffee":42,"lodash":93}],36:[function(require,module,exports){
var LayerInfo, Locked,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = Locked = (function(superClass) {
  extend(Locked, superClass);

  Locked.shouldParse = function(key) {
    return key === 'lspf';
  };

  function Locked(layer, length) {
    Locked.__super__.constructor.call(this, layer, length);
    this.transparencyLocked = false;
    this.compositeLocked = false;
    this.positionLocked = false;
    this.allLocked = false;
  }

  Locked.prototype.parse = function() {
    var locked;
    locked = this.file.readInt();
    this.transparencyLocked = (locked & (0x01 << 0)) > 0 || locked === -2147483648;
    this.compositeLocked = (locked & (0x01 << 1)) > 0 || locked === -2147483648;
    this.positionLocked = (locked & (0x01 << 2)) > 0 || locked === -2147483648;
    return this.allLocked = this.transparencyLocked && this.compositeLocked && this.positionLocked;
  };

  return Locked;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbG9ja2VkLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL2xvY2tlZC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxpQkFBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFDckIsTUFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O0VBRUQsZ0JBQUMsS0FBRCxFQUFRLE1BQVI7SUFDWCx3Q0FBTSxLQUFOLEVBQWEsTUFBYjtJQUVBLElBQUMsQ0FBQSxrQkFBRCxHQUFzQjtJQUN0QixJQUFDLENBQUEsZUFBRCxHQUFtQjtJQUNuQixJQUFDLENBQUEsY0FBRCxHQUFrQjtJQUNsQixJQUFDLENBQUEsU0FBRCxHQUFhO0VBTkY7O21CQVFiLEtBQUEsR0FBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLE1BQUEsR0FBUyxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUVULElBQUMsQ0FBQSxrQkFBRCxHQUFzQixDQUFDLE1BQUEsR0FBUyxDQUFDLElBQUEsSUFBUSxDQUFULENBQVYsQ0FBQSxHQUF5QixDQUF6QixJQUE4QixNQUFBLEtBQVUsQ0FBQztJQUMvRCxJQUFDLENBQUEsZUFBRCxHQUFtQixDQUFDLE1BQUEsR0FBUyxDQUFDLElBQUEsSUFBUSxDQUFULENBQVYsQ0FBQSxHQUF5QixDQUF6QixJQUE4QixNQUFBLEtBQVUsQ0FBQztJQUM1RCxJQUFDLENBQUEsY0FBRCxHQUFrQixDQUFDLE1BQUEsR0FBUyxDQUFDLElBQUEsSUFBUSxDQUFULENBQVYsQ0FBQSxHQUF5QixDQUF6QixJQUE4QixNQUFBLEtBQVUsQ0FBQztXQUUzRCxJQUFDLENBQUEsU0FBRCxHQUFhLElBQUMsQ0FBQSxrQkFBRCxJQUF3QixJQUFDLENBQUEsZUFBekIsSUFBNkMsSUFBQyxDQUFBO0VBUHREOzs7O0dBWDZCIn0=

},{"../layer_info.coffee":27}],37:[function(require,module,exports){
var Descriptor, LayerInfo, Metadata,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = Metadata = (function(superClass) {
  extend(Metadata, superClass);

  function Metadata() {
    return Metadata.__super__.constructor.apply(this, arguments);
  }

  Metadata.shouldParse = function(key) {
    return key === 'shmd';
  };

  Metadata.prototype.parse = function() {
    var copyOnSheetDup, count, end, i, j, key, len, ref, results;
    count = this.file.readInt();
    results = [];
    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      this.file.seek(4, true);
      key = this.file.readString(4);
      copyOnSheetDup = this.file.readByte();
      this.file.seek(3, true);
      len = this.file.readInt();
      end = this.file.tell() + len;
      if (key === 'cmls') {
        this.parseLayerComps();
      }
      results.push(this.file.seek(end));
    }
    return results;
  };

  Metadata.prototype.parseLayerComps = function() {
    this.file.seek(4, true);
    return this.data.layerComp = new Descriptor(this.file).parse();
  };

  return Metadata;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbWV0YWRhdGEuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbWV0YWRhdGEuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsK0JBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFDWixVQUFBLEdBQWEsT0FBQSxDQUFRLHNCQUFSOztBQUViLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O0VBQ3JCLFFBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOztxQkFFZCxLQUFBLEdBQU8sU0FBQTtBQUNMLFFBQUE7SUFBQSxLQUFBLEdBQVEsSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7QUFFUjtTQUFTLDhFQUFUO01BQ0UsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7TUFFQSxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQWlCLENBQWpCO01BRU4sY0FBQSxHQUFpQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQTtNQUNqQixJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtNQUVBLEdBQUEsR0FBTSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtNQUNOLEdBQUEsR0FBTSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBQSxDQUFBLEdBQWU7TUFFckIsSUFBc0IsR0FBQSxLQUFPLE1BQTdCO1FBQUEsSUFBQyxDQUFBLGVBQUQsQ0FBQSxFQUFBOzttQkFFQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxHQUFYO0FBYkY7O0VBSEs7O3FCQWtCUCxlQUFBLEdBQWlCLFNBQUE7SUFDZixJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtXQUNBLElBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixHQUFrQixJQUFJLFVBQUosQ0FBZSxJQUFDLENBQUEsSUFBaEIsQ0FBcUIsQ0FBQyxLQUF0QixDQUFBO0VBRkg7Ozs7R0FyQnFCIn0=

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],38:[function(require,module,exports){
var LayerInfo, NestedSectionDivider,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = NestedSectionDivider = (function(superClass) {
  extend(NestedSectionDivider, superClass);

  NestedSectionDivider.shouldParse = function(key) {
    return key === 'lsdk';
  };

  function NestedSectionDivider(layer, length) {
    NestedSectionDivider.__super__.constructor.call(this, layer, length);
    this.isFolder = false;
    this.isHidden = false;
  }

  NestedSectionDivider.prototype.parse = function() {
    var code;
    code = this.file.readInt();
    switch (code) {
      case 1:
      case 2:
        return this.isFolder = true;
      case 3:
        return this.isHidden = true;
    }
  };

  return NestedSectionDivider;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vbmVzdGVkX3NlY3Rpb25fZGl2aWRlci5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvbGF5ZXJfaW5mby9uZXN0ZWRfc2VjdGlvbl9kaXZpZGVyLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBLCtCQUFBO0VBQUE7OztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsc0JBQVI7O0FBT1osTUFBTSxDQUFDLE9BQVAsR0FBdUI7OztFQUNyQixvQkFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O0VBRUQsOEJBQUMsS0FBRCxFQUFRLE1BQVI7SUFDWCxzREFBTSxLQUFOLEVBQWEsTUFBYjtJQUVBLElBQUMsQ0FBQSxRQUFELEdBQVk7SUFDWixJQUFDLENBQUEsUUFBRCxHQUFZO0VBSkQ7O2lDQU1iLEtBQUEsR0FBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLElBQUEsR0FBTyxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtBQUVQLFlBQU8sSUFBUDtBQUFBLFdBQ08sQ0FEUDtBQUFBLFdBQ1UsQ0FEVjtlQUNpQixJQUFDLENBQUEsUUFBRCxHQUFZO0FBRDdCLFdBRU8sQ0FGUDtlQUVjLElBQUMsQ0FBQSxRQUFELEdBQVk7QUFGMUI7RUFISzs7OztHQVQyQyJ9

},{"../layer_info.coffee":27}],39:[function(require,module,exports){
var Descriptor, LayerInfo, ObjectEffects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = ObjectEffects = (function(superClass) {
  extend(ObjectEffects, superClass);

  function ObjectEffects() {
    return ObjectEffects.__super__.constructor.apply(this, arguments);
  }

  ObjectEffects.shouldParse = function(key) {
    return key === 'lfx2';
  };

  ObjectEffects.prototype.parse = function() {
    this.file.seek(8, true);
    return this.data = new Descriptor(this.file).parse();
  };

  return ObjectEffects;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vb2JqZWN0X2VmZmVjdHMuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vb2JqZWN0X2VmZmVjdHMuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsb0NBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFDWixVQUFBLEdBQWEsT0FBQSxDQUFRLHNCQUFSOztBQUViLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O0VBQ3JCLGFBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOzswQkFFZCxLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO1dBQ0EsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFJLFVBQUosQ0FBZSxJQUFDLENBQUEsSUFBaEIsQ0FBcUIsQ0FBQyxLQUF0QixDQUFBO0VBRkg7Ozs7R0FIb0MifQ==

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],40:[function(require,module,exports){
var LayerInfo, NestedSectionDivider,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = NestedSectionDivider = (function(superClass) {
  var SECTION_DIVIDER_TYPES;

  extend(NestedSectionDivider, superClass);

  NestedSectionDivider.shouldParse = function(key) {
    return key === 'lsct';
  };

  SECTION_DIVIDER_TYPES = ['other', 'open folder', 'closed folder', 'bounding section divider'];

  function NestedSectionDivider(layer, length) {
    NestedSectionDivider.__super__.constructor.call(this, layer, length);
    this.isFolder = false;
    this.isHidden = false;
    this.layerType = null;
    this.blendMode = null;
    this.subType = null;
  }

  NestedSectionDivider.prototype.parse = function() {
    var code;
    code = this.file.readInt();
    this.layerType = SECTION_DIVIDER_TYPES[code];
    switch (code) {
      case 1:
      case 2:
        this.isFolder = true;
        break;
      case 3:
        this.isHidden = true;
    }
    if (!(this.length >= 12)) {
      return;
    }
    this.file.seek(4, true);
    this.blendMode = this.file.readString(4);
    if (!(this.length >= 16)) {
      return;
    }
    return this.subType = this.file.readInt() === 0 ? 'normal' : 'scene group';
  };

  return NestedSectionDivider;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vc2VjdGlvbl9kaXZpZGVyLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL3NlY3Rpb25fZGl2aWRlci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSwrQkFBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBQXVCO0FBQ3JCLE1BQUE7Ozs7RUFBQSxvQkFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O0VBRWQscUJBQUEsR0FBd0IsQ0FDdEIsT0FEc0IsRUFFdEIsYUFGc0IsRUFHdEIsZUFIc0IsRUFJdEIsMEJBSnNCOztFQU9YLDhCQUFDLEtBQUQsRUFBUSxNQUFSO0lBQ1gsc0RBQU0sS0FBTixFQUFhLE1BQWI7SUFFQSxJQUFDLENBQUEsUUFBRCxHQUFZO0lBQ1osSUFBQyxDQUFBLFFBQUQsR0FBWTtJQUNaLElBQUMsQ0FBQSxTQUFELEdBQWE7SUFDYixJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLE9BQUQsR0FBVztFQVBBOztpQ0FTYixLQUFBLEdBQU8sU0FBQTtBQUNMLFFBQUE7SUFBQSxJQUFBLEdBQU8sSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFFUCxJQUFDLENBQUEsU0FBRCxHQUFhLHFCQUFzQixDQUFBLElBQUE7QUFFbkMsWUFBTyxJQUFQO0FBQUEsV0FDTyxDQURQO0FBQUEsV0FDVSxDQURWO1FBQ2lCLElBQUMsQ0FBQSxRQUFELEdBQVk7QUFBbkI7QUFEVixXQUVPLENBRlA7UUFFYyxJQUFDLENBQUEsUUFBRCxHQUFZO0FBRjFCO0lBSUEsSUFBQSxDQUFBLENBQWMsSUFBQyxDQUFBLE1BQUQsSUFBVyxFQUF6QixDQUFBO0FBQUEsYUFBQTs7SUFFQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtJQUNBLElBQUMsQ0FBQSxTQUFELEdBQWEsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQWlCLENBQWpCO0lBRWIsSUFBQSxDQUFBLENBQWMsSUFBQyxDQUFBLE1BQUQsSUFBVyxFQUF6QixDQUFBO0FBQUEsYUFBQTs7V0FFQSxJQUFDLENBQUEsT0FBRCxHQUFjLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBLENBQUEsS0FBbUIsQ0FBdEIsR0FBNkIsUUFBN0IsR0FBMkM7RUFoQmpEOzs7O0dBbkIyQyJ9

},{"../layer_info.coffee":27}],41:[function(require,module,exports){
var Descriptor, LayerInfo, SolidColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = SolidColor = (function(superClass) {
  extend(SolidColor, superClass);

  SolidColor.shouldParse = function(key) {
    return key === 'SoCo';
  };

  function SolidColor(layer, length) {
    SolidColor.__super__.constructor.call(this, layer, length);
    this.r = this.g = this.b = 0;
  }

  SolidColor.prototype.parse = function() {
    this.file.seek(4, true);
    this.data = new Descriptor(this.file).parse();
    this.r = Math.round(this.colorData()['Rd  ']);
    this.g = Math.round(this.colorData()['Grn ']);
    return this.b = Math.round(this.colorData()['Bl  ']);
  };

  SolidColor.prototype.colorData = function() {
    return this.data['Clr '];
  };

  SolidColor.prototype.color = function() {
    return [this.r, this.g, this.b];
  };

  return SolidColor;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vc29saWRfY29sb3IuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vc29saWRfY29sb3IuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsaUNBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFDWixVQUFBLEdBQWEsT0FBQSxDQUFRLHNCQUFSOztBQUViLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFDckIsVUFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQU87RUFBaEI7O0VBRUQsb0JBQUMsS0FBRCxFQUFRLE1BQVI7SUFDWCw0Q0FBTSxLQUFOLEVBQWEsTUFBYjtJQUVBLElBQUMsQ0FBQSxDQUFELEdBQUssSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFDLENBQUEsQ0FBRCxHQUFLO0VBSEo7O3VCQUtiLEtBQUEsR0FBTyxTQUFBO0lBQ0wsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7SUFDQSxJQUFDLENBQUEsSUFBRCxHQUFRLElBQUksVUFBSixDQUFlLElBQUMsQ0FBQSxJQUFoQixDQUFxQixDQUFDLEtBQXRCLENBQUE7SUFFUixJQUFDLENBQUEsQ0FBRCxHQUFLLElBQUksQ0FBQyxLQUFMLENBQVcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxDQUFhLENBQUEsTUFBQSxDQUF4QjtJQUNMLElBQUMsQ0FBQSxDQUFELEdBQUssSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFDLENBQUEsU0FBRCxDQUFBLENBQWEsQ0FBQSxNQUFBLENBQXhCO1dBQ0wsSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUMsQ0FBQSxTQUFELENBQUEsQ0FBYSxDQUFBLE1BQUEsQ0FBeEI7RUFOQTs7dUJBUVAsU0FBQSxHQUFXLFNBQUE7V0FBRyxJQUFDLENBQUEsSUFBSyxDQUFBLE1BQUE7RUFBVDs7dUJBQ1gsS0FBQSxHQUFPLFNBQUE7V0FBRyxDQUFDLElBQUMsQ0FBQSxDQUFGLEVBQUssSUFBQyxDQUFBLENBQU4sRUFBUyxJQUFDLENBQUEsQ0FBVjtFQUFIOzs7O0dBakJpQyJ9

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],42:[function(require,module,exports){
var Descriptor, LayerInfo, TextElements, _, parseEngineData,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

parseEngineData = require('parse-engine-data');

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = TextElements = (function(superClass) {
  var COORDS_VALUE, TRANSFORM_VALUE;

  extend(TextElements, superClass);

  TextElements.shouldParse = function(key) {
    return key === 'TySh';
  };

  TRANSFORM_VALUE = ['xx', 'xy', 'yx', 'yy', 'tx', 'ty'];

  COORDS_VALUE = ['left', 'top', 'right', 'bottom'];

  function TextElements(layer, length) {
    TextElements.__super__.constructor.call(this, layer, length);
    this.version = null;
    this.transform = {};
    this.textVersion = null;
    this.descriptorVersion = null;
    this.textData = null;
    this.engineData = null;
    this.textValue = null;
    this.warpVersion = null;
    this.descriptorVersion = null;
    this.warpData = null;
    this.coords = {};
  }

  TextElements.prototype.parse = function() {
    var i, index, len, name, results;
    this.version = this.file.readShort();
    this.parseTransformInfo();
    this.textVersion = this.file.readShort();
    this.descriptorVersion = this.file.readInt();
    this.textData = new Descriptor(this.file).parse();
    this.textValue = this.textData['Txt '];
    this.engineData = parseEngineData(this.textData.EngineData);
    this.warpVersion = this.file.readShort();
    this.descriptorVersion = this.file.readInt();
    this.warpData = new Descriptor(this.file).parse();
    results = [];
    for (index = i = 0, len = COORDS_VALUE.length; i < len; index = ++i) {
      name = COORDS_VALUE[index];
      results.push(this.coords[name] = this.file.readInt());
    }
    return results;
  };

  TextElements.prototype.parseTransformInfo = function() {
    var i, index, len, name, results;
    results = [];
    for (index = i = 0, len = TRANSFORM_VALUE.length; i < len; index = ++i) {
      name = TRANSFORM_VALUE[index];
      results.push(this.transform[name] = this.file.readDouble());
    }
    return results;
  };

  TextElements.prototype.fonts = function() {
    if (this.engineData == null) {
      return [];
    }
    return this.engineData.ResourceDict.FontSet.map(function(f) {
      return f.Name;
    });
  };

  TextElements.prototype.lengthArray = function() {
    var arr, sum;
    arr = this.engineData.EngineDict.StyleRun.RunLengthArray;
    sum = _.reduce(arr, function(m, o) {
      return m + o;
    });
    if (sum - this.textValue.length === 1) {
      arr[arr.length - 1] = arr[arr.length - 1] - 1;
    }
    return arr;
  };

  TextElements.prototype.fontStyles = function() {
    var data;
    data = this.engineData.EngineDict.StyleRun.RunArray.map(function(r) {
      return r.StyleSheet.StyleSheetData;
    });
    return data.map(function(f) {
      var style;
      if (f.FauxItalic) {
        style = 'italic';
      } else {
        style = 'normal';
      }
      return style;
    });
  };

  TextElements.prototype.fontWeights = function() {
    var data;
    data = this.engineData.EngineDict.StyleRun.RunArray.map(function(r) {
      return r.StyleSheet.StyleSheetData;
    });
    return data.map(function(f) {
      var weight;
      if (f.FauxBold) {
        weight = 'bold';
      } else {
        weight = 'normal';
      }
      return weight;
    });
  };

  TextElements.prototype.textDecoration = function() {
    var data;
    data = this.engineData.EngineDict.StyleRun.RunArray.map(function(r) {
      return r.StyleSheet.StyleSheetData;
    });
    return data.map(function(f) {
      var decoration;
      if (f.Underline) {
        decoration = 'underline';
      } else {
        decoration = 'none';
      }
      return decoration;
    });
  };

  TextElements.prototype.leading = function() {
    var data;
    data = this.engineData.EngineDict.StyleRun.RunArray.map(function(r) {
      return r.StyleSheet.StyleSheetData;
    });
    return data.map(function(f) {
      var leading;
      if (f.Leading) {
        leading = f.Leading;
      } else {
        leading = 'auto';
      }
      return leading;
    });
  };

  TextElements.prototype.sizes = function() {
    if ((this.engineData == null) && (this.styles().FontSize == null)) {
      return [];
    }
    return this.styles().FontSize;
  };

  TextElements.prototype.alignment = function() {
    var alignments;
    if (this.engineData == null) {
      return [];
    }
    alignments = ['left', 'right', 'center', 'justify'];
    return this.engineData.EngineDict.ParagraphRun.RunArray.map(function(s) {
      return alignments[Math.min(parseInt(s.ParagraphSheet.Properties.Justification, 10), 3)];
    });
  };

  TextElements.prototype.colors = function() {
    if ((this.engineData == null) || (this.styles().FillColor == null)) {
      return [[0, 0, 0, 255]];
    }
    return this.styles().FillColor.map(function(s) {
      var values;
      values = s.Values.map(function(v) {
        return Math.round(v * 255);
      });
      values.push(values.shift());
      return values;
    });
  };

  TextElements.prototype.styles = function() {
    var data;
    if (this.engineData == null) {
      return {};
    }
    if (this._styles != null) {
      return this._styles;
    }
    data = this.engineData.EngineDict.StyleRun.RunArray.map(function(r) {
      return r.StyleSheet.StyleSheetData;
    });
    return this._styles = _.reduce(data, function(m, o) {
      var k, v;
      for (k in o) {
        if (!hasProp.call(o, k)) continue;
        v = o[k];
        m[k] || (m[k] = []);
        m[k].push(v);
      }
      return m;
    }, {});
  };

  TextElements.prototype.toCSS = function() {
    var css, definition, k, v;
    definition = {
      'font-family': this.fonts().join(', '),
      'font-size': (this.sizes()[0]) + "pt",
      'color': "rgba(" + (this.colors()[0].join(', ')) + ")",
      'text-align': this.alignment()[0]
    };
    css = [];
    for (k in definition) {
      v = definition[k];
      if (v == null) {
        continue;
      }
      css.push(k + ": " + v + ";");
    }
    return css.join("\n");
  };

  TextElements.prototype["export"] = function() {
    return {
      value: this.textValue,
      font: {
        lengthArray: this.lengthArray(),
        styles: this.fontStyles(),
        weights: this.fontWeights(),
        names: this.fonts(),
        sizes: this.sizes(),
        colors: this.colors(),
        alignment: this.alignment(),
        textDecoration: this.textDecoration(),
        leading: this.leading()
      },
      left: this.coords.left,
      top: this.coords.top,
      right: this.coords.right,
      bottom: this.coords.bottom,
      transform: this.transform
    };
  };

  return TextElements;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdHlwZXRvb2wuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdHlwZXRvb2wuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsdURBQUE7RUFBQTs7O0FBQUEsQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSOztBQUNKLGVBQUEsR0FBa0IsT0FBQSxDQUFRLG1CQUFSOztBQUNsQixTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUNaLFVBQUEsR0FBYSxPQUFBLENBQVEsc0JBQVI7O0FBRWIsTUFBTSxDQUFDLE9BQVAsR0FBdUI7QUFDckIsTUFBQTs7OztFQUFBLFlBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOztFQUVkLGVBQUEsR0FBa0IsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0I7O0VBQ2xCLFlBQUEsR0FBZSxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLE9BQWhCLEVBQXlCLFFBQXpCOztFQUVGLHNCQUFDLEtBQUQsRUFBUSxNQUFSO0lBQ1gsOENBQU0sS0FBTixFQUFhLE1BQWI7SUFFQSxJQUFDLENBQUEsT0FBRCxHQUFXO0lBQ1gsSUFBQyxDQUFBLFNBQUQsR0FBYTtJQUNiLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFDZixJQUFDLENBQUEsaUJBQUQsR0FBcUI7SUFDckIsSUFBQyxDQUFBLFFBQUQsR0FBWTtJQUNaLElBQUMsQ0FBQSxVQUFELEdBQWM7SUFDZCxJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLFdBQUQsR0FBZTtJQUNmLElBQUMsQ0FBQSxpQkFBRCxHQUFxQjtJQUNyQixJQUFDLENBQUEsUUFBRCxH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

},{"../descriptor.coffee":4,"../layer_info.coffee":27,"lodash":93,"parse-engine-data":94}],43:[function(require,module,exports){
var LayerInfo, UnicodeName,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

module.exports = UnicodeName = (function(superClass) {
  extend(UnicodeName, superClass);

  function UnicodeName() {
    return UnicodeName.__super__.constructor.apply(this, arguments);
  }

  UnicodeName.shouldParse = function(key) {
    return key === 'luni';
  };

  UnicodeName.prototype.parse = function() {
    var pos;
    pos = this.file.tell();
    this.data = this.file.readUnicodeString();
    this.file.seek(pos + this.length);
    return this;
  };

  return UnicodeName;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdW5pY29kZV9uYW1lLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL3VuaWNvZGVfbmFtZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxzQkFBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O0VBQ3JCLFdBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOzt3QkFFZCxLQUFBLEdBQU8sU0FBQTtBQUNMLFFBQUE7SUFBQSxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUE7SUFDTixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxJQUFJLENBQUMsaUJBQU4sQ0FBQTtJQUVSLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLEdBQUEsR0FBTSxJQUFDLENBQUEsTUFBbEI7QUFDQSxXQUFPO0VBTEY7Ozs7R0FIa0MifQ==

},{"../layer_info.coffee":27}],44:[function(require,module,exports){
var LayerInfo, PathRecord, VectorMask,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

PathRecord = require('../path_record.coffee');

module.exports = VectorMask = (function(superClass) {
  extend(VectorMask, superClass);

  VectorMask.shouldParse = function(key) {
    return key === 'vmsk' || key === 'vsms';
  };

  function VectorMask(layer, length) {
    VectorMask.__super__.constructor.call(this, layer, length);
    this.invert = null;
    this.notLink = null;
    this.disable = null;
    this.paths = [];
  }

  VectorMask.prototype.parse = function() {
    var i, j, numRecords, record, ref, results, tag;
    this.file.seek(4, true);
    tag = this.file.readInt();
    this.invert = (tag & 0x01) > 0;
    this.notLink = (tag & (0x01 << 1)) > 0;
    this.disable = (tag & (0x01 << 2)) > 0;
    numRecords = (this.length - 10) / 26;
    results = [];
    for (i = j = 0, ref = numRecords; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      record = new PathRecord(this.file);
      record.parse();
      results.push(this.paths.push(record));
    }
    return results;
  };

  VectorMask.prototype["export"] = function() {
    return {
      invert: this.invert,
      notLink: this.notLink,
      disable: this.disable,
      paths: this.paths.map(function(p) {
        return p["export"]();
      })
    };
  };

  return VectorMask;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdmVjdG9yX21hc2suY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdmVjdG9yX21hc2suY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsaUNBQUE7RUFBQTs7O0FBQUEsU0FBQSxHQUFZLE9BQUEsQ0FBUSxzQkFBUjs7QUFDWixVQUFBLEdBQWEsT0FBQSxDQUFRLHVCQUFSOztBQUViLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFDckIsVUFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7V0FBUyxHQUFBLEtBQVEsTUFBUixJQUFBLEdBQUEsS0FBZ0I7RUFBekI7O0VBRUQsb0JBQUMsS0FBRCxFQUFRLE1BQVI7SUFDWCw0Q0FBTSxLQUFOLEVBQWEsTUFBYjtJQUVBLElBQUMsQ0FBQSxNQUFELEdBQVU7SUFDVixJQUFDLENBQUEsT0FBRCxHQUFXO0lBQ1gsSUFBQyxDQUFBLE9BQUQsR0FBVztJQUNYLElBQUMsQ0FBQSxLQUFELEdBQVM7RUFORTs7dUJBUWIsS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsQ0FBWCxFQUFjLElBQWQ7SUFDQSxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFFTixJQUFDLENBQUEsTUFBRCxHQUFVLENBQUMsR0FBQSxHQUFNLElBQVAsQ0FBQSxHQUFlO0lBQ3pCLElBQUMsQ0FBQSxPQUFELEdBQVcsQ0FBQyxHQUFBLEdBQU0sQ0FBQyxJQUFBLElBQVEsQ0FBVCxDQUFQLENBQUEsR0FBc0I7SUFDakMsSUFBQyxDQUFBLE9BQUQsR0FBVyxDQUFDLEdBQUEsR0FBTSxDQUFDLElBQUEsSUFBUSxDQUFULENBQVAsQ0FBQSxHQUFzQjtJQUdqQyxVQUFBLEdBQWEsQ0FBQyxJQUFDLENBQUEsTUFBRCxHQUFVLEVBQVgsQ0FBQSxHQUFpQjtBQUM5QjtTQUFTLG1GQUFUO01BQ0UsTUFBQSxHQUFTLElBQUksVUFBSixDQUFlLElBQUMsQ0FBQSxJQUFoQjtNQUNULE1BQU0sQ0FBQyxLQUFQLENBQUE7bUJBRUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFQLENBQVksTUFBWjtBQUpGOztFQVZLOzt3QkFnQlAsUUFBQSxHQUFRLFNBQUE7V0FDTjtNQUFBLE1BQUEsRUFBUSxJQUFDLENBQUEsTUFBVDtNQUNBLE9BQUEsRUFBUyxJQUFDLENBQUEsT0FEVjtNQUVBLE9BQUEsRUFBUyxJQUFDLENBQUEsT0FGVjtNQUdBLEtBQUEsRUFBTyxJQUFDLENBQUEsS0FBSyxDQUFDLEdBQVAsQ0FBVyxTQUFDLENBQUQ7ZUFBTyxDQUFDLEVBQUMsTUFBRCxFQUFELENBQUE7TUFBUCxDQUFYLENBSFA7O0VBRE07Ozs7R0EzQmdDIn0=

},{"../layer_info.coffee":27,"../path_record.coffee":58}],45:[function(require,module,exports){
var Descriptor, LayerInfo, VectorOrigination,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = VectorOrigination = (function(superClass) {
  extend(VectorOrigination, superClass);

  function VectorOrigination() {
    return VectorOrigination.__super__.constructor.apply(this, arguments);
  }

  VectorOrigination.shouldParse = function(key) {
    return key === 'vogk';
  };

  VectorOrigination.prototype.parse = function() {
    this.file.seek(8, true);
    return this.data = new Descriptor(this.file).parse();
  };

  return VectorOrigination;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdmVjdG9yX29yaWdpbmF0aW9uLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL3ZlY3Rvcl9vcmlnaW5hdGlvbi5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSx3Q0FBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUNaLFVBQUEsR0FBYSxPQUFBLENBQVEsc0JBQVI7O0FBRWIsTUFBTSxDQUFDLE9BQVAsR0FBdUI7Ozs7Ozs7RUFDckIsaUJBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOzs4QkFFZCxLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO1dBQ0EsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFJLFVBQUosQ0FBZSxJQUFDLENBQUEsSUFBaEIsQ0FBcUIsQ0FBQyxLQUF0QixDQUFBO0VBRkg7Ozs7R0FId0MifQ==

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],46:[function(require,module,exports){
var Descriptor, LayerInfo, VectorStroke,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = VectorStroke = (function(superClass) {
  extend(VectorStroke, superClass);

  function VectorStroke() {
    return VectorStroke.__super__.constructor.apply(this, arguments);
  }

  VectorStroke.shouldParse = function(key) {
    return key === 'vstk';
  };

  VectorStroke.prototype.parse = function() {
    this.file.seek(4, true);
    return this.data = new Descriptor(this.file).parse();
  };

  return VectorStroke;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdmVjdG9yX3N0cm9rZS5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvbGF5ZXJfaW5mby92ZWN0b3Jfc3Ryb2tlLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBLG1DQUFBO0VBQUE7OztBQUFBLFNBQUEsR0FBWSxPQUFBLENBQVEsc0JBQVI7O0FBQ1osVUFBQSxHQUFhLE9BQUEsQ0FBUSxzQkFBUjs7QUFFYixNQUFNLENBQUMsT0FBUCxHQUF1Qjs7Ozs7OztFQUNyQixZQUFDLENBQUEsV0FBRCxHQUFjLFNBQUMsR0FBRDtXQUFTLEdBQUEsS0FBTztFQUFoQjs7eUJBRWQsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtXQUNBLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBSSxVQUFKLENBQWUsSUFBQyxDQUFBLElBQWhCLENBQXFCLENBQUMsS0FBdEIsQ0FBQTtFQUZIOzs7O0dBSG1DIn0=

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],47:[function(require,module,exports){
var Descriptor, LayerInfo, VectorStrokeContent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LayerInfo = require('../layer_info.coffee');

Descriptor = require('../descriptor.coffee');

module.exports = VectorStrokeContent = (function(superClass) {
  extend(VectorStrokeContent, superClass);

  function VectorStrokeContent() {
    return VectorStrokeContent.__super__.constructor.apply(this, arguments);
  }

  VectorStrokeContent.shouldParse = function(key) {
    return key === 'vscg';
  };

  VectorStrokeContent.prototype.parse = function() {
    this.file.seek(8, true);
    return this.data = new Descriptor(this.file).parse();
  };

  return VectorStrokeContent;

})(LayerInfo);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX2luZm8vdmVjdG9yX3N0cm9rZV9jb250ZW50LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9sYXllcl9pbmZvL3ZlY3Rvcl9zdHJva2VfY29udGVudC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSwwQ0FBQTtFQUFBOzs7QUFBQSxTQUFBLEdBQVksT0FBQSxDQUFRLHNCQUFSOztBQUNaLFVBQUEsR0FBYSxPQUFBLENBQVEsc0JBQVI7O0FBRWIsTUFBTSxDQUFDLE9BQVAsR0FBdUI7Ozs7Ozs7RUFDckIsbUJBQUMsQ0FBQSxXQUFELEdBQWMsU0FBQyxHQUFEO1dBQVMsR0FBQSxLQUFPO0VBQWhCOztnQ0FFZCxLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLENBQVgsRUFBYyxJQUFkO1dBQ0EsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFJLFVBQUosQ0FBZSxJQUFDLENBQUEsSUFBaEIsQ0FBcUIsQ0FBQyxLQUF0QixDQUFBO0VBRkg7Ozs7R0FIMEMifQ==

},{"../descriptor.coffee":4,"../layer_info.coffee":27}],48:[function(require,module,exports){
var Layer, LayerMask, Util, _;

_ = require('lodash');

Util = require('./util.coffee');

Layer = require('./layer.coffee');

module.exports = LayerMask = (function() {
  function LayerMask(file, header) {
    this.file = file;
    this.header = header;
    this.layers = [];
    this.mergedAlpha = false;
    this.globalMask = null;
  }

  LayerMask.prototype.skip = function() {
    return this.file.seek(this.file.readInt(), true);
  };

  LayerMask.prototype.parse = function() {
    var finish, maskSize;
    maskSize = this.file.readInt();
    finish = maskSize + this.file.tell();
    if (maskSize <= 0) {
      return;
    }
    this.parseLayers();
    this.parseGlobalMask();
    this.layers.reverse();
    return this.file.seek(finish);
  };

  LayerMask.prototype.parseLayers = function() {
    var i, j, k, layer, layerCount, layerInfoSize, len, ref, ref1, results;
    layerInfoSize = Util.pad2(this.file.readInt());
    if (layerInfoSize > 0) {
      layerCount = this.file.readShort();
      if (layerCount < 0) {
        layerCount = Math.abs(layerCount);
        this.mergedAlpha = true;
      }
      for (i = j = 0, ref = layerCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.layers.push(new Layer(this.file, this.header).parse());
      }
      ref1 = this.layers;
      results = [];
      for (k = 0, len = ref1.length; k < len; k++) {
        layer = ref1[k];
        results.push(layer.parseChannelImage());
      }
      return results;
    }
  };

  LayerMask.prototype.parseGlobalMask = function() {
    var length, maskEnd;
    length = this.file.readInt();
    if (length <= 0) {
      return;
    }
    maskEnd = this.file.tell() + length;
    this.globalMask = _({}).tap((function(_this) {
      return function(mask) {
        mask.overlayColorSpace = _this.file.readShort();
        mask.colorComponents = [_this.file.readShort() >> 8, _this.file.readShort() >> 8, _this.file.readShort() >> 8, _this.file.readShort() >> 8];
        mask.opacity = _this.file.readShort() / 16.0;
        return mask.kind = _this.file.readByte();
      };
    })(this));
    return this.file.seek(maskEnd);
  };

  return LayerMask;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX21hc2suY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xheWVyX21hc2suY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSOztBQUNKLElBQUEsR0FBTyxPQUFBLENBQVEsZUFBUjs7QUFDUCxLQUFBLEdBQVEsT0FBQSxDQUFRLGdCQUFSOztBQVlSLE1BQU0sQ0FBQyxPQUFQLEdBQXVCO0VBQ1IsbUJBQUMsSUFBRCxFQUFRLE1BQVI7SUFBQyxJQUFDLENBQUEsT0FBRDtJQUFPLElBQUMsQ0FBQSxTQUFEO0lBQ25CLElBQUMsQ0FBQSxNQUFELEdBQVU7SUFDVixJQUFDLENBQUEsV0FBRCxHQUFlO0lBQ2YsSUFBQyxDQUFBLFVBQUQsR0FBYztFQUhIOztzQkFLYixJQUFBLEdBQU0sU0FBQTtXQUFHLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBLENBQVgsRUFBNEIsSUFBNUI7RUFBSDs7c0JBRU4sS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsUUFBQSxHQUFXLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0lBQ1gsTUFBQSxHQUFTLFFBQUEsR0FBVyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBQTtJQUVwQixJQUFVLFFBQUEsSUFBWSxDQUF0QjtBQUFBLGFBQUE7O0lBRUEsSUFBQyxDQUFBLFdBQUQsQ0FBQTtJQUNBLElBQUMsQ0FBQSxlQUFELENBQUE7SUFJQSxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBQTtXQUVBLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLE1BQVg7RUFiSzs7c0JBZVAsV0FBQSxHQUFhLFNBQUE7QUFDWCxRQUFBO0lBQUEsYUFBQSxHQUFnQixJQUFJLENBQUMsSUFBTCxDQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBLENBQVY7SUFFaEIsSUFBRyxhQUFBLEdBQWdCLENBQW5CO01BQ0UsVUFBQSxHQUFhLElBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBO01BRWIsSUFBRyxVQUFBLEdBQWEsQ0FBaEI7UUFDRSxVQUFBLEdBQWEsSUFBSSxDQUFDLEdBQUwsQ0FBUyxVQUFUO1FBQ2IsSUFBQyxDQUFBLFdBQUQsR0FBZSxLQUZqQjs7QUFJQSxXQUFTLG1GQUFUO1FBQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLENBQWEsSUFBSSxLQUFKLENBQVUsSUFBQyxDQUFBLElBQVgsRUFBaUIsSUFBQyxDQUFBLE1BQWxCLENBQXlCLENBQUMsS0FBMUIsQ0FBQSxDQUFiO0FBREY7QUFHQTtBQUFBO1dBQUEsc0NBQUE7O3FCQUFBLEtBQUssQ0FBQyxpQkFBTixDQUFBO0FBQUE7cUJBVkY7O0VBSFc7O3NCQWViLGVBQUEsR0FBaUIsU0FBQTtBQUNmLFFBQUE7SUFBQSxNQUFBLEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFDVCxJQUFVLE1BQUEsSUFBVSxDQUFwQjtBQUFBLGFBQUE7O0lBRUEsT0FBQSxHQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFBLENBQUEsR0FBZTtJQUV6QixJQUFDLENBQUEsVUFBRCxHQUFjLENBQUEsQ0FBRSxFQUFGLENBQUssQ0FBQyxHQUFOLENBQVUsQ0FBQSxTQUFBLEtBQUE7YUFBQSxTQUFDLElBQUQ7UUFDdEIsSUFBSSxDQUFDLGlCQUFMLEdBQXlCLEtBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBO1FBQ3pCLElBQUksQ0FBQyxlQUFMLEdBQXVCLENBQ3JCLEtBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBLENBQUEsSUFBcUIsQ0FEQSxFQUVyQixLQUFDLENBQUEsSUFBSSxDQUFDLFNBQU4sQ0FBQSxDQUFBLElBQXFCLENBRkEsRUFHckIsS0FBQyxDQUFBLElBQUksQ0FBQyxTQUFOLENBQUEsQ0FBQSxJQUFxQixDQUhBLEVBSXJCLEtBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBLENBQUEsSUFBcUIsQ0FKQTtRQU92QixJQUFJLENBQUMsT0FBTCxHQUFlLEtBQUMsQ0FBQSxJQUFJLENBQUMsU0FBTixDQUFBLENBQUEsR0FBb0I7ZUFHbkMsSUFBSSxDQUFDLElBQUwsR0FBWSxLQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQTtNQVpVO0lBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFWO1dBY2QsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsT0FBWDtFQXBCZSJ9

},{"./layer.coffee":18,"./util.coffee":65,"lodash":93}],49:[function(require,module,exports){
var LazyExecute,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = LazyExecute = (function() {
  function LazyExecute(obj, file) {
    this.obj = obj;
    this.file = file;
    this.startPos = this.file.tell();
    this.loaded = false;
    this.loadMethod = null;
    this.loadArgs = [];
    this.passthru = [];
  }

  LazyExecute.prototype.now = function() {
    var args, method;
    method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    this.obj[method].apply(this.obj, args);
    return this;
  };

  LazyExecute.prototype.later = function() {
    var args, method;
    method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    this.loadMethod = method;
    this.loadArgs = args;
    return this;
  };

  LazyExecute.prototype.ignore = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    this.passthru.concat(args);
    return this;
  };

  LazyExecute.prototype.get = function() {
    var fn, key, ref, val;
    ref = this.obj;
    fn = (function(_this) {
      return function(key, val) {
        if (_this[key] != null) {
          return;
        }
        return Object.defineProperty(_this, key, {
          get: function() {
            if (!this.loaded && !(indexOf.call(this.passthru, key) >= 0)) {
              this.load();
            }
            return this.obj[key];
          }
        });
      };
    })(this);
    for (key in ref) {
      val = ref[key];
      fn(key, val);
    }
    return this;
  };

  LazyExecute.prototype.load = function() {
    var origPos;
    origPos = this.file.tell();
    this.file.seek(this.startPos);
    this.obj[this.loadMethod].apply(this.obj, this.loadArgs);
    this.file.seek(origPos);
    return this.loaded = true;
  };

  return LazyExecute;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL2xhenlfZXhlY3V0ZS5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvbGF6eV9leGVjdXRlLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5QkEsSUFBQSxXQUFBO0VBQUE7OztBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQXVCO0VBQ1IscUJBQUMsR0FBRCxFQUFPLElBQVA7SUFBQyxJQUFDLENBQUEsTUFBRDtJQUFNLElBQUMsQ0FBQSxPQUFEO0lBQ2xCLElBQUMsQ0FBQSxRQUFELEdBQVksSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUE7SUFDWixJQUFDLENBQUEsTUFBRCxHQUFVO0lBQ1YsSUFBQyxDQUFBLFVBQUQsR0FBYztJQUNkLElBQUMsQ0FBQSxRQUFELEdBQVk7SUFDWixJQUFDLENBQUEsUUFBRCxHQUFZO0VBTEQ7O3dCQVViLEdBQUEsR0FBSyxTQUFBO0FBQ0gsUUFBQTtJQURJLHVCQUFRO0lBQ1osSUFBQyxDQUFBLEdBQUksQ0FBQSxNQUFBLENBQU8sQ0FBQyxLQUFiLENBQW1CLElBQUMsQ0FBQSxHQUFwQixFQUF5QixJQUF6QjtBQUNBLFdBQU87RUFGSjs7d0JBTUwsS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBRE0sdUJBQVE7SUFDZCxJQUFDLENBQUEsVUFBRCxHQUFjO0lBQ2QsSUFBQyxDQUFBLFFBQUQsR0FBWTtBQUNaLFdBQU87RUFIRjs7d0JBV1AsTUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO0lBRE87SUFDUCxJQUFDLENBQUEsUUFBUSxDQUFDLE1BQVYsQ0FBaUIsSUFBakI7QUFDQSxXQUFPO0VBRkQ7O3dCQU9SLEdBQUEsR0FBSyxTQUFBO0FBQ0gsUUFBQTtBQUFBO1NBQTZCLENBQUEsU0FBQSxLQUFBO2FBQUEsU0FBQyxHQUFELEVBQU0sR0FBTjtRQUMzQixJQUFVLGtCQUFWO0FBQUEsaUJBQUE7O2VBQ0EsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsS0FBdEIsRUFBeUIsR0FBekIsRUFDRTtVQUFBLEdBQUEsRUFBSyxTQUFBO1lBQ0gsSUFBVyxDQUFJLElBQUMsQ0FBQSxNQUFMLElBQWdCLENBQUksQ0FBQyxhQUFPLElBQUMsQ0FBQSxRQUFSLEVBQUEsR0FBQSxNQUFELENBQS9CO2NBQUEsSUFBQyxDQUFBLElBQUQsQ0FBQSxFQUFBOzttQkFDQSxJQUFDLENBQUEsR0FBSSxDQUFBLEdBQUE7VUFGRixDQUFMO1NBREY7TUFGMkI7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBO0FBQTdCLFNBQUEsVUFBQTs7U0FBOEIsS0FBSztBQUFuQztXQU9BO0VBUkc7O3dCQWtCTCxJQUFBLEdBQU0sU0FBQTtBQUNKLFFBQUE7SUFBQSxPQUFBLEdBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUE7SUFDVixJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxJQUFDLENBQUEsUUFBWjtJQUVBLElBQUMsQ0FBQSxHQUFJLENBQUEsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFDLEtBQWxCLENBQXdCLElBQUMsQ0FBQSxHQUF6QixFQUE4QixJQUFDLENBQUEsUUFBL0I7SUFFQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxPQUFYO1dBQ0EsSUFBQyxDQUFBLE1BQUQsR0FBVTtFQVBOIn0=

},{}],50:[function(require,module,exports){
var Mask;

module.exports = Mask = (function() {
  function Mask(file) {
    this.file = file;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
  }

  Mask.prototype.parse = function() {
    var maskEnd;
    this.size = this.file.readInt();
    if (this.size === 0) {
      return this;
    }
    maskEnd = this.file.tell() + this.size;
    this.top = this.file.readInt();
    this.left = this.file.readInt();
    this.bottom = this.file.readInt();
    this.right = this.file.readInt();
    this.width = this.right - this.left;
    this.height = this.bottom - this.top;
    this.relative = (this.flags & 0x01) > 0;
    this.disabled = (this.flags & (0x01 << 1)) > 0;
    this.invert = (this.flags & (0x01 << 2)) > 0;
    this.defaultColor = this.file.readByte();
    this.flags = this.file.readByte();
    this.file.seek(maskEnd);
    return this;
  };

  Mask.prototype["export"] = function() {
    if (this.size === 0) {
      return {};
    }
    return {
      top: this.top,
      left: this.left,
      bottom: this.bottom,
      right: this.right,
      width: this.width,
      height: this.height,
      defaultColor: this.defaultColor,
      relative: this.relative,
      disabled: this.disabled,
      invert: this.invert
    };
  };

  return Mask;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL21hc2suY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL21hc2suY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLElBQUE7O0FBQUEsTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFDUixjQUFDLElBQUQ7SUFBQyxJQUFDLENBQUEsT0FBRDtJQUNaLElBQUMsQ0FBQSxHQUFELEdBQU87SUFDUCxJQUFDLENBQUEsS0FBRCxHQUFTO0lBQ1QsSUFBQyxDQUFBLE1BQUQsR0FBVTtJQUNWLElBQUMsQ0FBQSxJQUFELEdBQVE7RUFKRzs7aUJBTWIsS0FBQSxHQUFPLFNBQUE7QUFHTCxRQUFBO0lBQUEsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNSLElBQVksSUFBQyxDQUFBLElBQUQsS0FBUyxDQUFyQjtBQUFBLGFBQU8sS0FBUDs7SUFFQSxPQUFBLEdBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlLElBQUMsQ0FBQTtJQUcxQixJQUFDLENBQUEsR0FBRCxHQUFPLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0lBQ1AsSUFBQyxDQUFBLElBQUQsR0FBUSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNSLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBLElBQUksQ0FBQyxPQUFOLENBQUE7SUFDVixJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO0lBR1QsSUFBQyxDQUFBLEtBQUQsR0FBUyxJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQTtJQUNuQixJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBQyxDQUFBO0lBR3JCLElBQUMsQ0FBQSxRQUFELEdBQVksQ0FBQyxJQUFDLENBQUEsS0FBRCxHQUFTLElBQVYsQ0FBQSxHQUFrQjtJQUM5QixJQUFDLENBQUEsUUFBRCxHQUFZLENBQUMsSUFBQyxDQUFBLEtBQUQsR0FBUyxDQUFDLElBQUEsSUFBUSxDQUFULENBQVYsQ0FBQSxHQUF5QjtJQUNyQyxJQUFDLENBQUEsTUFBRCxHQUFVLENBQUMsSUFBQyxDQUFBLEtBQUQsR0FBUyxDQUFDLElBQUEsSUFBUSxDQUFULENBQVYsQ0FBQSxHQUF5QjtJQUVuQyxJQUFDLENBQUEsWUFBRCxHQUFnQixJQUFDLENBQUEsSUFBSSxDQUFDLFFBQU4sQ0FBQTtJQUNoQixJQUFDLENBQUEsS0FBRCxHQUFTLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBO0lBRVQsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsT0FBWDtBQUNBLFdBQU87RUEzQkY7O2tCQTZCUCxRQUFBLEdBQVEsU0FBQTtJQUNOLElBQWEsSUFBQyxDQUFBLElBQUQsS0FBUyxDQUF0QjtBQUFBLGFBQU8sR0FBUDs7V0FFQTtNQUFBLEdBQUEsRUFBSyxJQUFDLENBQUEsR0FBTjtNQUNBLElBQUEsRUFBTSxJQUFDLENBQUEsSUFEUDtNQUVBLE1BQUEsRUFBUSxJQUFDLENBQUEsTUFGVDtNQUdBLEtBQUEsRUFBTyxJQUFDLENBQUEsS0FIUjtNQUlBLEtBQUEsRUFBTyxJQUFDLENBQUEsS0FKUjtNQUtBLE1BQUEsRUFBUSxJQUFDLENBQUEsTUFMVDtNQU1BLFlBQUEsRUFBYyxJQUFDLENBQUEsWUFOZjtNQU9BLFFBQUEsRUFBVSxJQUFDLENBQUEsUUFQWDtNQVFBLFFBQUEsRUFBVSxJQUFDLENBQUEsUUFSWDtNQVNBLE1BQUEsRUFBUSxJQUFDLENBQUEsTUFUVDs7RUFITSJ9

},{}],51:[function(require,module,exports){
var Module, Node, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Module = require('coffeescript-module').Module;

module.exports = Node = (function(superClass) {
  extend(Node, superClass);

  Node.includes(require('./nodes/ancestry.coffee'));

  Node.includes(require('./nodes/search.coffee'));

  Node.includes(require('./nodes/build_preview.coffee'));

  Node.PROPERTIES = ['name', 'left', 'right', 'top', 'bottom', 'height', 'width'];

  Node.prototype.type = 'node';

  function Node(layer, parent) {
    this.layer = layer;
    this.parent = parent != null ? parent : null;
    this.layer.node = this;
    this._children = [];
    this.name = this.layer.name;
    this.forceVisible = null;
    this.coords = {
      top: this.layer.top,
      bottom: this.layer.bottom,
      left: this.layer.left,
      right: this.layer.right
    };
    this.topOffset = 0;
    this.leftOffset = 0;
    this.createProperties();
  }

  Node.prototype.createProperties = function() {
    Object.defineProperty(this, 'top', {
      get: function() {
        return this.coords.top + this.topOffset;
      },
      set: function(val) {
        return this.coords.top = val;
      }
    });
    Object.defineProperty(this, 'right', {
      get: function() {
        return this.coords.right + this.leftOffset;
      },
      set: function(val) {
        return this.coords.right = val;
      }
    });
    Object.defineProperty(this, 'bottom', {
      get: function() {
        return this.coords.bottom + this.topOffset;
      },
      set: function(val) {
        return this.coords.bottom = val;
      }
    });
    Object.defineProperty(this, 'left', {
      get: function() {
        return this.coords.left + this.leftOffset;
      },
      set: function(val) {
        return this.coords.left = val;
      }
    });
    Object.defineProperty(this, 'width', {
      get: function() {
        return this.right - this.left;
      }
    });
    return Object.defineProperty(this, 'height', {
      get: function() {
        return this.bottom - this.top;
      }
    });
  };

  Node.prototype.get = function(prop) {
    var value;
    value = this[prop] != null ? this[prop] : this.layer[prop];
    if (typeof value === 'function') {
      return value();
    } else {
      return value;
    }
  };

  Node.prototype.visible = function() {
    if (this.layer.clipped && !this.clippingMask().visible()) {
      return false;
    }
    if (this.forceVisible != null) {
      return this.forceVisible;
    } else {
      return this.layer.visible;
    }
  };

  Node.prototype.hidden = function() {
    return !this.visible();
  };

  Node.prototype.isLayer = function() {
    return this.type === 'layer';
  };

  Node.prototype.isGroup = function() {
    return this.type === 'group';
  };

  Node.prototype.isRoot = function() {
    return this.type === 'root';
  };

  Node.prototype.clippingMask = function() {
    var maskNode;
    if (!this.layer.clipped) {
      return null;
    }
    return this.clippingMaskCached || (this.clippingMaskCached = ((function() {
      maskNode = this.nextSibling();
      while (maskNode.clipped) {
        maskNode = maskNode.nextSibling();
      }
      return maskNode;
    }).call(this)));
  };

  Node.prototype.clippedBy = function() {
    return this.clippingMask();
  };

  Node.prototype["export"] = function() {
    var hash, i, len, prop, ref;
    hash = {
      type: null,
      visible: this.visible(),
      opacity: this.layer.opacity / 255.0,
      blendingMode: this.layer.blendingMode()
    };
    ref = Node.PROPERTIES;
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      hash[prop] = this[prop];
    }
    return hash;
  };

  Node.prototype.updateDimensions = function() {
    var child, i, len, nonEmptyChildren, ref;
    if (this.isLayer()) {
      return;
    }
    ref = this._children;
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      child.updateDimensions();
    }
    if (this.isRoot()) {
      return;
    }
    nonEmptyChildren = this._children.filter(function(c) {
      return !c.isEmpty();
    });
    this.left = _.min(nonEmptyChildren.map(function(c) {
      return c.left;
    })) || 0;
    this.top = _.min(nonEmptyChildren.map(function(c) {
      return c.top;
    })) || 0;
    this.bottom = _.max(nonEmptyChildren.map(function(c) {
      return c.bottom;
    })) || 0;
    return this.right = _.max(nonEmptyChildren.map(function(c) {
      return c.right;
    })) || 0;
  };

  return Node;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGUuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGUuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFBLElBQUEsZUFBQTtFQUFBOzs7QUFBQSxDQUFBLEdBQVcsT0FBQSxDQUFRLFFBQVI7O0FBQ1YsU0FBVSxPQUFBLENBQVEscUJBQVI7O0FBRVgsTUFBTSxDQUFDLE9BQVAsR0FBdUI7OztFQUVyQixJQUFDLENBQUEsUUFBRCxDQUFVLE9BQUEsQ0FBUSx5QkFBUixDQUFWOztFQUNBLElBQUMsQ0FBQSxRQUFELENBQVUsT0FBQSxDQUFRLHVCQUFSLENBQVY7O0VBQ0EsSUFBQyxDQUFBLFFBQUQsQ0FBVSxPQUFBLENBQVEsOEJBQVIsQ0FBVjs7RUFJQSxJQUFDLENBQUEsVUFBRCxHQUFhLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsT0FBakIsRUFBMEIsS0FBMUIsRUFBaUMsUUFBakMsRUFBMkMsUUFBM0MsRUFBcUQsT0FBckQ7O2lCQUtiLElBQUEsR0FBTTs7RUFJTyxjQUFDLEtBQUQsRUFBUyxNQUFUO0lBQUMsSUFBQyxDQUFBLFFBQUQ7SUFBUSxJQUFDLENBQUEsMEJBQUQsU0FBVTtJQUM5QixJQUFDLENBQUEsS0FBSyxDQUFDLElBQVAsR0FBYztJQUNkLElBQUMsQ0FBQSxTQUFELEdBQWE7SUFJYixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxLQUFLLENBQUM7SUFFZixJQUFDLENBQUEsWUFBRCxHQUFnQjtJQUloQixJQUFDLENBQUEsTUFBRCxHQUNFO01BQUEsR0FBQSxFQUFLLElBQUMsQ0FBQSxLQUFLLENBQUMsR0FBWjtNQUNBLE1BQUEsRUFBUSxJQUFDLENBQUEsS0FBSyxDQUFDLE1BRGY7TUFFQSxJQUFBLEVBQU0sSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUZiO01BR0EsS0FBQSxFQUFPLElBQUMsQ0FBQSxLQUFLLENBQUMsS0FIZDs7SUFLRixJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLFVBQUQsR0FBYztJQUVkLElBQUMsQ0FBQSxnQkFBRCxDQUFBO0VBckJXOztpQkF1QmIsZ0JBQUEsR0FBa0IsU0FBQTtJQUdoQixNQUFNLENBQUMsY0FBUCxDQUFzQixJQUF0QixFQUF5QixLQUF6QixFQUNFO01BQUEsR0FBQSxFQUFLLFNBQUE7ZUFBRyxJQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsR0FBYyxJQUFDLENBQUE7TUFBbEIsQ0FBTDtNQUNBLEdBQUEsRUFBSyxTQUFDLEdBQUQ7ZUFBUyxJQUFDLENBQUEsTUFBTSxDQUFDLEdBQVIsR0FBYztNQUF2QixDQURMO0tBREY7SUFJQSxNQUFNLENBQUMsY0FBUCxDQUFzQixJQUF0QixFQUF5QixPQUF6QixFQUNFO01BQUEsR0FBQSxFQUFLLFNBQUE7ZUFBRyxJQUFDLENBQUEsTUFBTSxDQUFDLEtBQVIsR0FBZ0IsSUFBQyxDQUFBO01BQXBCLENBQUw7TUFDQSxHQUFBLEVBQUssU0FBQyxHQUFEO2VBQVMsSUFBQyxDQUFBLE1BQU0sQ0FBQyxLQUFSLEdBQWdCO01BQXpCLENBREw7S0FERjtJQUlBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLElBQXRCLEVBQXlCLFFBQXpCLEVBQ0U7TUFBQSxHQUFBLEVBQUssU0FBQTtlQUFHLElBQUMsQ0FBQSxNQUFNLENBQUMsTUFBUixHQUFpQixJQUFDLENBQUE7TUFBckIsQ0FBTDtNQUNBLEdBQUEsRUFBSyxTQUFDLEdBQUQ7ZUFBUyxJQUFDLENBQUEsTUFBTSxDQUFDLE1BQVIsR0FBaUI7TUFBMUIsQ0FETDtLQURGO0lBSUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBeUIsTUFBekIsRUFDRTtNQUFBLEdBQUEsRUFBSyxTQUFBO2VBQUcsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLEdBQWUsSUFBQyxDQUFBO01BQW5CLENBQUw7TUFDQSxHQUFBLEVBQUssU0FBQyxHQUFEO2VBQVMsSUFBQyxDQUFBLE1BQU0sQ0FBQyxJQUFSLEdBQWU7TUFBeEIsQ0FETDtLQURGO0lBTUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBeUIsT0FBekIsRUFBbUM7TUFBQSxHQUFBLEVBQUssU0FBQTtlQUFHLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBO01BQWIsQ0FBTDtLQUFuQztXQUNBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLElBQXRCLEVBQXlCLFFBQXpCLEVBQW1DO01BQUEsR0FBQSxFQUFLLFNBQUE7ZUFBRyxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQTtNQUFkLENBQUw7S0FBbkM7RUF0QmdCOztpQkF3Q2xCLEdBQUEsR0FBSyxTQUFDLElBQUQ7QUFDSCxRQUFBO0lBQUEsS0FBQSxHQUFXLGtCQUFILEdBQWlCLElBQUUsQ0FBQSxJQUFBLENBQW5CLEdBQThCLElBQUMsQ0FBQSxLQUFNLENBQUEsSUFBQTtJQUM3QyxJQUFHLE9BQU8sS0FBUCxLQUFnQixVQUFuQjthQUFtQyxLQUFBLENBQUEsRUFBbkM7S0FBQSxNQUFBO2FBQWdELE1BQWhEOztFQUZHOztpQkFPTCxPQUFBLEdBQVMsU0FBQTtJQUNQLElBQWdCLElBQUMsQ0FBQSxLQUFLLENBQUMsT0FBUCxJQUFtQixDQUFJLElBQUMsQ0FBQSxZQUFELENBQUEsQ0FBZSxDQUFDLE9BQWhCLENBQUEsQ0FBdkM7QUFBQSxhQUFPLE1BQVA7O0lBQ0EsSUFBRyx5QkFBSDthQUF1QixJQUFDLENBQUEsYUFBeEI7S0FBQSxNQUFBO2FBQTBDLElBQUMsQ0FBQSxLQUFLLENBQUMsUUFBakQ7O0VBRk87O2lCQUlULE1BQUEsR0FBUSxTQUFBO1dBQUcsQ0FBSSxJQUFDLENBQUEsT0FBRCxDQUFBO0VBQVA7O2lCQUVSLE9BQUEsR0FBUyxTQUFBO1dBQUcsSUFBQyxDQUFBLElBQUQsS0FBUztFQUFaOztpQkFDVCxPQUFBLEdBQVMsU0FBQTtXQUFHLElBQUMsQ0FBQSxJQUFELEtBQVM7RUFBWjs7aUJBQ1QsTUFBQSxHQUFRLFNBQUE7V0FBSSxJQUFDLENBQUEsSUFBRCxLQUFTO0VBQWI7O2lCQU1SLFlBQUEsR0FBYyxTQUFBO0FBQ1osUUFBQTtJQUFBLElBQUEsQ0FBbUIsSUFBQyxDQUFBLEtBQUssQ0FBQyxPQUExQjtBQUFBLGFBQU8sS0FBUDs7V0FDQSxJQUFDLENBQUEsdUJBQUQsSUFBQyxDQUFBLHFCQUF1QjtNQUN0QixRQUFBLEdBQVcsSUFBQyxDQUFBLFdBQUQsQ0FBQTtBQUN1QixhQUFNLFFBQVEsQ0FBQyxPQUFmO1FBQWxDLFFBQUEsR0FBVyxRQUFRLENBQUMsV0FBVCxDQUFBO01BQXVCO2FBQ2xDO2lCQUhzQjtFQUZaOztpQkFRZCxTQUFBLEdBQVcsU0FBQTtXQUFHLElBQUMsQ0FBQSxZQUFELENBQUE7RUFBSDs7a0JBSVgsUUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO0lBQUEsSUFBQSxHQUNFO01BQUEsSUFBQSxFQUFNLElBQU47TUFDQSxPQUFBLEVBQVMsSUFBQyxDQUFBLE9BQUQsQ0FBQSxDQURUO01BRUEsT0FBQSxFQUFTLElBQUMsQ0FBQSxLQUFLLENBQUMsT0FBUCxHQUFpQixLQUYxQjtNQUdBLFlBQUEsRUFBYyxJQUFDLENBQUEsS0FBSyxDQUFDLFlBQVAsQ0FBQSxDQUhkOztBQUtGO0FBQUEsU0FBQSxxQ0FBQTs7TUFBQSxJQUFLLENBQUEsSUFBQSxDQUFMLEdBQWEsSUFBRSxDQUFBLElBQUE7QUFBZjtXQUNBO0VBUk07O2lCQWNSLGdCQUFBLEdBQWtCLFNBQUE7QUFDaEIsUUFBQTtJQUFBLElBQVUsSUFBQyxDQUFBLE9BQUQsQ0FBQSxDQUFWO0FBQUEsYUFBQTs7QUFFQTtBQUFBLFNBQUEscUNBQUE7O01BQUEsS0FBSyxDQUFDLGdCQUFOLENBQUE7QUFBQTtJQUVBLElBQVUsSUFBQyxDQUFBLE1BQUQsQ0FBQSxDQUFWO0FBQUEsYUFBQTs7SUFFQSxnQkFBQSxHQUFtQixJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsQ0FBa0IsU0FBQyxDQUFEO2FBQU8sQ0FBSSxDQUFDLENBQUMsT0FBRixDQUFBO0lBQVgsQ0FBbEI7SUFDbkIsSUFBQyxDQUFBLElBQUQsR0FBUSxDQUFDLENBQUMsR0FBRixDQUFNLGdCQUFnQixDQUFDLEdBQWpCLENBQXFCLFNBQUMsQ0FBRDthQUFPLENBQUMsQ0FBQztJQUFULENBQXJCLENBQU4sQ0FBQSxJQUE4QztJQUN0RCxJQUFDLENBQUEsR0FBRCxHQUFPLENBQUMsQ0FBQyxHQUFGLENBQU0sZ0JBQWdCLENBQUMsR0FBakIsQ0FBcUIsU0FBQyxDQUFEO2FBQU8sQ0FBQyxDQUFDO0lBQVQsQ0FBckIsQ0FBTixDQUFBLElBQTZDO0lBQ3BELElBQUMsQ0FBQSxNQUFELEdBQVUsQ0FBQyxDQUFDLEdBQUYsQ0FBTSxnQkFBZ0IsQ0FBQyxHQUFqQixDQUFxQixTQUFDLENBQUQ7YUFBTyxDQUFDLENBQUM7SUFBVCxDQUFyQixDQUFOLENBQUEsSUFBZ0Q7V0FDMUQsSUFBQyxDQUFBLEtBQUQsR0FBUyxDQUFDLENBQUMsR0FBRixDQUFNLGdCQUFnQixDQUFDLEdBQWpCLENBQXFCLFNBQUMsQ0FBRDthQUFPLENBQUMsQ0FBQztJQUFULENBQXJCLENBQU4sQ0FBQSxJQUErQztFQVh4Qzs7OztHQS9IZ0IifQ==

},{"./nodes/ancestry.coffee":52,"./nodes/build_preview.coffee":53,"./nodes/search.coffee":57,"coffeescript-module":70,"lodash":93}],52:[function(require,module,exports){
var _;

_ = require('lodash');

module.exports = {
  root: function() {
    if (this.isRoot()) {
      return this;
    }
    return this.parent.root();
  },
  isRoot: function() {
    return this.depth() === 0;
  },
  children: function() {
    return this._children;
  },
  ancestors: function() {
    if ((this.parent == null) || this.parent.isRoot()) {
      return [];
    }
    return this.parent.ancestors().concat([this.parent]);
  },
  hasChildren: function() {
    return this._children.length > 0;
  },
  childless: function() {
    return !this.hasChildren();
  },
  siblings: function() {
    if (this.parent == null) {
      return [];
    }
    return this.parent.children();
  },
  nextSibling: function() {
    var index;
    if (this.parent == null) {
      return null;
    }
    index = this.siblings().indexOf(this);
    return this.siblings()[index + 1];
  },
  prevSibling: function() {
    var index;
    if (this.parent == null) {
      return null;
    }
    index = this.siblings().indexOf(this);
    return this.siblings()[index - 1];
  },
  hasSiblings: function() {
    return this.siblings().length > 1;
  },
  onlyChild: function() {
    return !this.hasSiblings();
  },
  descendants: function() {
    return _.flatten(this._children.map(function(n) {
      return n.subtree();
    }));
  },
  subtree: function() {
    return [this].concat(this.descendants());
  },
  depth: function() {
    return this.ancestors().length + 1;
  },
  path: function(asArray) {
    var path;
    if (asArray == null) {
      asArray = false;
    }
    path = this.ancestors().map(function(n) {
      return n.name;
    }).concat([this.name]);
    if (asArray) {
      return path;
    } else {
      return path.join('/');
    }
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL2FuY2VzdHJ5LmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9ub2Rlcy9hbmNlc3RyeS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVI7O0FBRUosTUFBTSxDQUFDLE9BQVAsR0FDRTtFQUFBLElBQUEsRUFBTSxTQUFBO0lBQ0osSUFBWSxJQUFDLENBQUEsTUFBRCxDQUFBLENBQVo7QUFBQSxhQUFPLEtBQVA7O0FBQ0EsV0FBTyxJQUFDLENBQUEsTUFBTSxDQUFDLElBQVIsQ0FBQTtFQUZILENBQU47RUFJQSxNQUFBLEVBQVEsU0FBQTtXQUFHLElBQUMsQ0FBQSxLQUFELENBQUEsQ0FBQSxLQUFZO0VBQWYsQ0FKUjtFQU1BLFFBQUEsRUFBVSxTQUFBO1dBQUcsSUFBQyxDQUFBO0VBQUosQ0FOVjtFQVFBLFNBQUEsRUFBVyxTQUFBO0lBQ1QsSUFBaUIscUJBQUosSUFBZ0IsSUFBQyxDQUFBLE1BQU0sQ0FBQyxNQUFSLENBQUEsQ0FBN0I7QUFBQSxhQUFPLEdBQVA7O0FBQ0EsV0FBTyxJQUFDLENBQUEsTUFBTSxDQUFDLFNBQVIsQ0FBQSxDQUFtQixDQUFDLE1BQXBCLENBQTJCLENBQUMsSUFBQyxDQUFBLE1BQUYsQ0FBM0I7RUFGRSxDQVJYO0VBWUEsV0FBQSxFQUFhLFNBQUE7V0FBRyxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsR0FBb0I7RUFBdkIsQ0FaYjtFQWFBLFNBQUEsRUFBVyxTQUFBO1dBQUcsQ0FBSSxJQUFDLENBQUEsV0FBRCxDQUFBO0VBQVAsQ0FiWDtFQWVBLFFBQUEsRUFBVSxTQUFBO0lBQ1IsSUFBaUIsbUJBQWpCO0FBQUEsYUFBTyxHQUFQOztXQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUFBO0VBRlEsQ0FmVjtFQW1CQSxXQUFBLEVBQWEsU0FBQTtBQUNYLFFBQUE7SUFBQSxJQUFtQixtQkFBbkI7QUFBQSxhQUFPLEtBQVA7O0lBQ0EsS0FBQSxHQUFRLElBQUMsQ0FBQSxRQUFELENBQUEsQ0FBVyxDQUFDLE9BQVosQ0FBb0IsSUFBcEI7V0FDUixJQUFDLENBQUEsUUFBRCxDQUFBLENBQVksQ0FBQSxLQUFBLEdBQVEsQ0FBUjtFQUhELENBbkJiO0VBd0JBLFdBQUEsRUFBYSxTQUFBO0FBQ1gsUUFBQTtJQUFBLElBQW1CLG1CQUFuQjtBQUFBLGFBQU8sS0FBUDs7SUFDQSxLQUFBLEdBQVEsSUFBQyxDQUFBLFFBQUQsQ0FBQSxDQUFXLENBQUMsT0FBWixDQUFvQixJQUFwQjtXQUNSLElBQUMsQ0FBQSxRQUFELENBQUEsQ0FBWSxDQUFBLEtBQUEsR0FBUSxDQUFSO0VBSEQsQ0F4QmI7RUE2QkEsV0FBQSxFQUFhLFNBQUE7V0FBRyxJQUFDLENBQUEsUUFBRCxDQUFBLENBQVcsQ0FBQyxNQUFaLEdBQXFCO0VBQXhCLENBN0JiO0VBOEJBLFNBQUEsRUFBVyxTQUFBO1dBQUcsQ0FBSSxJQUFDLENBQUEsV0FBRCxDQUFBO0VBQVAsQ0E5Qlg7RUFnQ0EsV0FBQSxFQUFhLFNBQUE7V0FBRyxDQUFDLENBQUMsT0FBRixDQUFVLElBQUMsQ0FBQSxTQUFTLENBQUMsR0FBWCxDQUFlLFNBQUMsQ0FBRDthQUFPLENBQUMsQ0FBQyxPQUFGLENBQUE7SUFBUCxDQUFmLENBQVY7RUFBSCxDQWhDYjtFQWtDQSxPQUFBLEVBQVMsU0FBQTtXQUFHLENBQUMsSUFBRCxDQUFHLENBQUMsTUFBSixDQUFXLElBQUMsQ0FBQSxXQUFELENBQUEsQ0FBWDtFQUFILENBbENUO0VBb0NBLEtBQUEsRUFBTyxTQUFBO1dBQUcsSUFBQyxDQUFBLFNBQUQsQ0FBQSxDQUFZLENBQUMsTUFBYixHQUFzQjtFQUF6QixDQXBDUDtFQXNDQSxJQUFBLEVBQU0sU0FBQyxPQUFEO0FBQ0osUUFBQTs7TUFESyxVQUFVOztJQUNmLElBQUEsR0FBTyxJQUFDLENBQUEsU0FBRCxDQUFBLENBQVksQ0FBQyxHQUFiLENBQWlCLFNBQUMsQ0FBRDthQUFPLENBQUMsQ0FBQztJQUFULENBQWpCLENBQStCLENBQUMsTUFBaEMsQ0FBdUMsQ0FBQyxJQUFDLENBQUEsSUFBRixDQUF2QztJQUNQLElBQUcsT0FBSDthQUFnQixLQUFoQjtLQUFBLE1BQUE7YUFBMEIsSUFBSSxDQUFDLElBQUwsQ0FBVSxHQUFWLEVBQTFCOztFQUZJLENBdENOIn0=

},{"lodash":93}],53:[function(require,module,exports){
module.exports = {
  toPng: function() {
    return this.layer.image.toPng();
  },
  saveAsPng: function(output) {
    return this.layer.image.saveAsPng(output);
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL2J1aWxkX3ByZXZpZXcuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL2J1aWxkX3ByZXZpZXcuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxLQUFBLEVBQU8sU0FBQTtXQUFHLElBQUMsQ0FBQSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQWIsQ0FBQTtFQUFILENBQVA7RUFDQSxTQUFBLEVBQVcsU0FBQyxNQUFEO1dBQVksSUFBQyxDQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBYixDQUF1QixNQUF2QjtFQUFaLENBRFgifQ==

},{}],54:[function(require,module,exports){
var Group, Node, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Node = require('../node.coffee');

module.exports = Group = (function(superClass) {
  extend(Group, superClass);

  function Group() {
    return Group.__super__.constructor.apply(this, arguments);
  }

  Group.prototype.type = 'group';

  Group.prototype.passthruBlending = function() {
    return this.get('blendingMode') === 'passthru';
  };

  Group.prototype.isEmpty = function() {
    var child;
    if (!(function() {
      var i, len, ref, results;
      ref = this._children;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        results.push(child.isEmpty());
      }
      return results;
    }).call(this)) {
      return false;
    }
  };

  Group.prototype["export"] = function() {
    return _.merge(Group.__super__["export"].call(this), {
      type: 'group',
      children: this._children.map(function(c) {
        return c["export"]();
      })
    });
  };

  return Group;

})(Node);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL2dyb3VwLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9ub2Rlcy9ncm91cC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxjQUFBO0VBQUE7OztBQUFBLENBQUEsR0FBTyxPQUFBLENBQVEsUUFBUjs7QUFDUCxJQUFBLEdBQU8sT0FBQSxDQUFRLGdCQUFSOztBQUVQLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O2tCQUNyQixJQUFBLEdBQU07O2tCQUVOLGdCQUFBLEdBQWtCLFNBQUE7V0FDaEIsSUFBQyxDQUFBLEdBQUQsQ0FBSyxjQUFMLENBQUEsS0FBd0I7RUFEUjs7a0JBR2xCLE9BQUEsR0FBUyxTQUFBO0FBQ1AsUUFBQTtJQUFBLElBQUE7O0FBQW9CO0FBQUE7V0FBQSxxQ0FBQTs7cUJBQUEsS0FBSyxDQUFDLE9BQU4sQ0FBQTtBQUFBOztpQkFBcEI7QUFBQSxhQUFPLE1BQVA7O0VBRE87O21CQUdULFFBQUEsR0FBUSxTQUFBO1dBQ04sQ0FBQyxDQUFDLEtBQUYsQ0FBUSxtQ0FBQSxDQUFSLEVBQ0U7TUFBQSxJQUFBLEVBQU0sT0FBTjtNQUNBLFFBQUEsRUFBVSxJQUFDLENBQUEsU0FBUyxDQUFDLEdBQVgsQ0FBZSxTQUFDLENBQUQ7ZUFBTyxDQUFDLEVBQUMsTUFBRCxFQUFELENBQUE7TUFBUCxDQUFmLENBRFY7S0FERjtFQURNOzs7O0dBVDJCIn0=

},{"../node.coffee":51,"lodash":93}],55:[function(require,module,exports){
var Layer, Node, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Node = require('../node.coffee');

module.exports = Layer = (function(superClass) {
  extend(Layer, superClass);

  function Layer() {
    return Layer.__super__.constructor.apply(this, arguments);
  }

  Layer.prototype.type = 'layer';

  Layer.prototype.isEmpty = function() {
    return this.width === 0 || this.height === 0;
  };

  Layer.prototype["export"] = function() {
    var ref;
    return _.merge(Layer.__super__["export"].call(this), {
      type: 'layer',
      mask: this.layer.mask["export"](),
      text: (ref = this.get('typeTool')) != null ? ref["export"]() : void 0,
      image: {}
    });
  };

  return Layer;

})(Node);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL2xheWVyLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9ub2Rlcy9sYXllci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxjQUFBO0VBQUE7OztBQUFBLENBQUEsR0FBTyxPQUFBLENBQVEsUUFBUjs7QUFDUCxJQUFBLEdBQU8sT0FBQSxDQUFRLGdCQUFSOztBQUVQLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7Ozs7O2tCQUNyQixJQUFBLEdBQU07O2tCQUVOLE9BQUEsR0FBUyxTQUFBO1dBQUcsSUFBQyxDQUFBLEtBQUQsS0FBVSxDQUFWLElBQWUsSUFBQyxDQUFBLE1BQUQsS0FBVztFQUE3Qjs7bUJBRVQsUUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO1dBQUEsQ0FBQyxDQUFDLEtBQUYsQ0FBUSxtQ0FBQSxDQUFSLEVBQ0U7TUFBQSxJQUFBLEVBQU0sT0FBTjtNQUNBLElBQUEsRUFBTSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksRUFBQyxNQUFELEVBQVgsQ0FBQSxDQUROO01BRUEsSUFBQSw0Q0FBc0IsRUFBRSxNQUFGLEVBQWhCLENBQUEsVUFGTjtNQUdBLEtBQUEsRUFBTyxFQUhQO0tBREY7RUFETTs7OztHQUwyQiJ9

},{"../node.coffee":51,"lodash":93}],56:[function(require,module,exports){
var Group, Layer, Node, Root, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

Node = require('../node.coffee');

Group = require('./group.coffee');

Layer = require('./layer.coffee');

module.exports = Root = (function(superClass) {
  extend(Root, superClass);

  Root.layerForPsd = function(psd) {
    var i, layer, len, prop, ref;
    layer = {};
    ref = Node.PROPERTIES;
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      layer[prop] = null;
    }
    layer.top = 0;
    layer.left = 0;
    layer.right = psd.header.width;
    layer.bottom = psd.header.height;
    return layer;
  };

  Root.prototype.type = 'root';

  function Root(psd1) {
    this.psd = psd1;
    Root.__super__.constructor.call(this, Root.layerForPsd(this.psd));
    this.buildHeirarchy();
  }

  Root.prototype.documentDimensions = function() {
    return [this.width, this.height];
  };

  Root.prototype.depth = function() {
    return 0;
  };

  Root.prototype.opacity = function() {
    return 255;
  };

  Root.prototype.fillOpacity = function() {
    return 255;
  };

  Root.prototype["export"] = function() {
    var ref, ref1;
    return {
      children: this._children.map(function(c) {
        return c["export"]();
      }),
      document: {
        width: this.width,
        height: this.height,
        resources: {
          layerComps: ((ref = this.psd.resources.resource('layerComps')) != null ? ref["export"]() : void 0) || [],
          resolutionInfo: ((ref1 = this.psd.resources.resource('resolutionInfo')) != null ? ref1["export"]() : void 0) || [],
          guides: [],
          slices: []
        }
      }
    };
  };

  Root.prototype.buildHeirarchy = function() {
    var currentGroup, i, layer, len, parent, parseStack, ref;
    currentGroup = this;
    parseStack = [];
    ref = this.psd.layers;
    for (i = 0, len = ref.length; i < len; i++) {
      layer = ref[i];
      if (layer.isFolder()) {
        parseStack.push(currentGroup);
        currentGroup = new Group(layer, _.last(parseStack));
      } else if (layer.isFolderEnd()) {
        parent = parseStack.pop();
        parent.children().push(currentGroup);
        currentGroup = parent;
      } else {
        currentGroup.children().push(new Layer(layer, currentGroup));
      }
    }
    return this.updateDimensions();
  };

  return Root;

})(Node);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL3Jvb3QuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL3Jvb3QuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsMkJBQUE7RUFBQTs7O0FBQUEsQ0FBQSxHQUFRLE9BQUEsQ0FBUSxRQUFSOztBQUNSLElBQUEsR0FBUSxPQUFBLENBQVEsZ0JBQVI7O0FBQ1IsS0FBQSxHQUFRLE9BQUEsQ0FBUSxnQkFBUjs7QUFDUixLQUFBLEdBQVEsT0FBQSxDQUFRLGdCQUFSOztBQUVSLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFDckIsSUFBQyxDQUFBLFdBQUQsR0FBYyxTQUFDLEdBQUQ7QUFDWixRQUFBO0lBQUEsS0FBQSxHQUFRO0FBQ1I7QUFBQSxTQUFBLHFDQUFBOztNQUFBLEtBQU0sQ0FBQSxJQUFBLENBQU4sR0FBYztBQUFkO0lBRUEsS0FBSyxDQUFDLEdBQU4sR0FBWTtJQUNaLEtBQUssQ0FBQyxJQUFOLEdBQWE7SUFDYixLQUFLLENBQUMsS0FBTixHQUFjLEdBQUcsQ0FBQyxNQUFNLENBQUM7SUFDekIsS0FBSyxDQUFDLE1BQU4sR0FBZSxHQUFHLENBQUMsTUFBTSxDQUFDO1dBQzFCO0VBUlk7O2lCQVVkLElBQUEsR0FBTTs7RUFFTyxjQUFDLElBQUQ7SUFBQyxJQUFDLENBQUEsTUFBRDtJQUNaLHNDQUFNLElBQUksQ0FBQyxXQUFMLENBQWlCLElBQUMsQ0FBQSxHQUFsQixDQUFOO0lBQ0EsSUFBQyxDQUFBLGNBQUQsQ0FBQTtFQUZXOztpQkFJYixrQkFBQSxHQUFvQixTQUFBO1dBQUcsQ0FDckIsSUFBQyxDQUFBLEtBRG9CLEVBRXJCLElBQUMsQ0FBQSxNQUZvQjtFQUFIOztpQkFLcEIsS0FBQSxHQUFPLFNBQUE7V0FBRztFQUFIOztpQkFDUCxPQUFBLEdBQVMsU0FBQTtXQUFHO0VBQUg7O2lCQUNULFdBQUEsR0FBYSxTQUFBO1dBQUc7RUFBSDs7a0JBRWIsUUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO1dBQUE7TUFBQSxRQUFBLEVBQVUsSUFBQyxDQUFBLFNBQVMsQ0FBQyxHQUFYLENBQWUsU0FBQyxDQUFEO2VBQU8sQ0FBQyxFQUFDLE1BQUQsRUFBRCxDQUFBO01BQVAsQ0FBZixDQUFWO01BQ0EsUUFBQSxFQUNFO1FBQUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxLQUFSO1FBQ0EsTUFBQSxFQUFRLElBQUMsQ0FBQSxNQURUO1FBRUEsU0FBQSxFQUNFO1VBQUEsVUFBQSxrRUFBaUQsRUFBRSxNQUFGLEVBQXJDLENBQUEsV0FBQSxJQUFtRCxFQUEvRDtVQUNBLGNBQUEsd0VBQXlELEVBQUUsTUFBRixFQUF6QyxDQUFBLFdBQUEsSUFBdUQsRUFEdkU7VUFFQSxNQUFBLEVBQVEsRUFGUjtVQUdBLE1BQUEsRUFBUSxFQUhSO1NBSEY7T0FGRjs7RUFETTs7aUJBWVIsY0FBQSxHQUFnQixTQUFBO0FBQ2QsUUFBQTtJQUFBLFlBQUEsR0FBZTtJQUNmLFVBQUEsR0FBYTtBQUViO0FBQUEsU0FBQSxxQ0FBQTs7TUFDRSxJQUFHLEtBQUssQ0FBQyxRQUFOLENBQUEsQ0FBSDtRQUNFLFVBQVUsQ0FBQyxJQUFYLENBQWdCLFlBQWhCO1FBQ0EsWUFBQSxHQUFlLElBQUksS0FBSixDQUFVLEtBQVYsRUFBaUIsQ0FBQyxDQUFDLElBQUYsQ0FBTyxVQUFQLENBQWpCLEVBRmpCO09BQUEsTUFHSyxJQUFHLEtBQUssQ0FBQyxXQUFOLENBQUEsQ0FBSDtRQUNILE1BQUEsR0FBUyxVQUFVLENBQUMsR0FBWCxDQUFBO1FBQ1QsTUFBTSxDQUFDLFFBQVAsQ0FBQSxDQUFpQixDQUFDLElBQWxCLENBQXVCLFlBQXZCO1FBQ0EsWUFBQSxHQUFlLE9BSFo7T0FBQSxNQUFBO1FBS0gsWUFBWSxDQUFDLFFBQWIsQ0FBQSxDQUF1QixDQUFDLElBQXhCLENBQTZCLElBQUksS0FBSixDQUFVLEtBQVYsRUFBaUIsWUFBakIsQ0FBN0IsRUFMRzs7QUFKUDtXQVdBLElBQUMsQ0FBQSxnQkFBRCxDQUFBO0VBZmM7Ozs7R0F0Q2tCIn0=

},{"../node.coffee":51,"./group.coffee":54,"./layer.coffee":55,"lodash":93}],57:[function(require,module,exports){
var _;

_ = require('lodash');

module.exports = {
  childrenAtPath: function(path, opts) {
    var matches, query;
    if (opts == null) {
      opts = {};
    }
    if (!Array.isArray(path)) {
      path = path.split('/').filter(function(p) {
        return p.length > 0;
      });
    }
    path = _.clone(path);
    query = path.shift();
    matches = this.children().filter(function(c) {
      if (opts.caseSensitive) {
        return c.name === query;
      } else {
        return c.name.toLowerCase() === query.toLowerCase();
      }
    });
    if (path.length === 0) {
      return matches;
    } else {
      return _.flatten(matches.map(function(m) {
        return m.childrenAtPath(_.clone(path), opts);
      }));
    }
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL25vZGVzL3NlYXJjaC5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2Qvbm9kZXMvc2VhcmNoLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBOztBQUFBLENBQUEsR0FBSSxPQUFBLENBQVEsUUFBUjs7QUFFSixNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsY0FBQSxFQUFnQixTQUFDLElBQUQsRUFBTyxJQUFQO0FBQ2QsUUFBQTs7TUFEcUIsT0FBTzs7SUFDNUIsSUFBQSxDQUFPLEtBQUssQ0FBQyxPQUFOLENBQWMsSUFBZCxDQUFQO01BQ0UsSUFBQSxHQUFPLElBQUksQ0FBQyxLQUFMLENBQVcsR0FBWCxDQUFlLENBQUMsTUFBaEIsQ0FBdUIsU0FBQyxDQUFEO2VBQU8sQ0FBQyxDQUFDLE1BQUYsR0FBVztNQUFsQixDQUF2QixFQURUOztJQUdBLElBQUEsR0FBTyxDQUFDLENBQUMsS0FBRixDQUFRLElBQVI7SUFDUCxLQUFBLEdBQVEsSUFBSSxDQUFDLEtBQUwsQ0FBQTtJQUNSLE9BQUEsR0FBVSxJQUFDLENBQUEsUUFBRCxDQUFBLENBQVcsQ0FBQyxNQUFaLENBQW1CLFNBQUMsQ0FBRDtNQUMzQixJQUFHLElBQUksQ0FBQyxhQUFSO2VBQ0UsQ0FBQyxDQUFDLElBQUYsS0FBVSxNQURaO09BQUEsTUFBQTtlQUdFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBUCxDQUFBLENBQUEsS0FBd0IsS0FBSyxDQUFDLFdBQU4sQ0FBQSxFQUgxQjs7SUFEMkIsQ0FBbkI7SUFNVixJQUFHLElBQUksQ0FBQyxNQUFMLEtBQWUsQ0FBbEI7QUFDRSxhQUFPLFFBRFQ7S0FBQSxNQUFBO0FBR0UsYUFBTyxDQUFDLENBQUMsT0FBRixDQUFVLE9BQU8sQ0FBQyxHQUFSLENBQVksU0FBQyxDQUFEO2VBQzNCLENBQUMsQ0FBQyxjQUFGLENBQWlCLENBQUMsQ0FBQyxLQUFGLENBQVEsSUFBUixDQUFqQixFQUFnQyxJQUFoQztNQUQyQixDQUFaLENBQVYsRUFIVDs7RUFaYyxDQUFoQiJ9

},{"lodash":93}],58:[function(require,module,exports){
var PathRecord, _;

_ = require('lodash');

module.exports = PathRecord = (function() {
  function PathRecord(file) {
    this.file = file;
    this.recordType = null;
  }

  PathRecord.prototype.parse = function() {
    this.recordType = this.file.readShort();
    switch (this.recordType) {
      case 0:
      case 3:
        return this._readPathRecord();
      case 1:
      case 2:
      case 4:
      case 5:
        return this._readBezierPoint();
      case 7:
        return this._readClipboardRecord();
      case 8:
        return this._readInitialFill();
      default:
        return this.file.seek(24, true);
    }
  };

  PathRecord.prototype["export"] = function() {
    return _.merge({
      recordType: this.recordType
    }, (function() {
      var ref;
      switch (this.recordType) {
        case 0:
        case 3:
          return {
            numPoints: this.numPoints
          };
        case 1:
        case 2:
        case 4:
        case 5:
          return {
            linked: this.linked,
            closed: ((ref = this.recordType) === 1 || ref === 2),
            preceding: {
              vert: this.precedingVert,
              horiz: this.precedingHoriz
            },
            anchor: {
              vert: this.anchorVert,
              horiz: this.anchorHoriz
            },
            leaving: {
              vert: this.leavingVert,
              horiz: this.leavingHoriz
            }
          };
        case 7:
          return {
            clipboard: {
              top: this.clipboardTop,
              left: this.clipboardLeft,
              bottom: this.clipboardBottom,
              right: this.clipboardRight,
              resolution: this.clipboardResolution
            }
          };
        case 8:
          return {
            initialFill: this.initialFill
          };
        default:
          return {};
      }
    }).call(this));
  };

  PathRecord.prototype.isBezierPoint = function() {
    var ref;
    return (ref = this.recordType) === 1 || ref === 2 || ref === 4 || ref === 5;
  };

  PathRecord.prototype._readPathRecord = function() {
    this.numPoints = this.file.readShort();
    return this.file.seek(22, true);
  };

  PathRecord.prototype._readBezierPoint = function() {
    var ref;
    this.linked = (ref = this.recordType) === 1 || ref === 4;
    this.precedingVert = this.file.readPathNumber();
    this.precedingHoriz = this.file.readPathNumber();
    this.anchorVert = this.file.readPathNumber();
    this.anchorHoriz = this.file.readPathNumber();
    this.leavingVert = this.file.readPathNumber();
    return this.leavingHoriz = this.file.readPathNumber();
  };

  PathRecord.prototype._readClipboardRecord = function() {
    this.clipboardTop = this.file.readPathNumber();
    this.clipboardLeft = this.file.readPathNumber();
    this.clipboardBottom = this.file.readPathNumber();
    this.clipboardRight = this.file.readPathNumber();
    this.clipboardResolution = this.file.readPathNumber();
    return this.file.seek(4, true);
  };

  PathRecord.prototype._readInitialFill = function() {
    this.initialFill = this.file.readShort();
    return this.file.seek(22, true);
  };

  return PathRecord;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3BhdGhfcmVjb3JkLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9wYXRoX3JlY29yZC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxDQUFBLEdBQUksT0FBQSxDQUFRLFFBQVI7O0FBSUosTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFDUixvQkFBQyxJQUFEO0lBQUMsSUFBQyxDQUFBLE9BQUQ7SUFDWixJQUFDLENBQUEsVUFBRCxHQUFjO0VBREg7O3VCQUdiLEtBQUEsR0FBTyxTQUFBO0lBQ0wsSUFBQyxDQUFBLFVBQUQsR0FBYyxJQUFDLENBQUEsSUFBSSxDQUFDLFNBQU4sQ0FBQTtBQUVkLFlBQU8sSUFBQyxDQUFBLFVBQVI7QUFBQSxXQUNPLENBRFA7QUFBQSxXQUNVLENBRFY7ZUFDaUIsSUFBQyxDQUFBLGVBQUQsQ0FBQTtBQURqQixXQUVPLENBRlA7QUFBQSxXQUVVLENBRlY7QUFBQSxXQUVhLENBRmI7QUFBQSxXQUVnQixDQUZoQjtlQUV1QixJQUFDLENBQUEsZ0JBQUQsQ0FBQTtBQUZ2QixXQUdPLENBSFA7ZUFHYyxJQUFDLENBQUEsb0JBQUQsQ0FBQTtBQUhkLFdBSU8sQ0FKUDtlQUljLElBQUMsQ0FBQSxnQkFBRCxDQUFBO0FBSmQ7ZUFLTyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxFQUFYLEVBQWUsSUFBZjtBQUxQO0VBSEs7O3dCQVVQLFFBQUEsR0FBUSxTQUFBO1dBQ04sQ0FBQyxDQUFDLEtBQUYsQ0FBUTtNQUFFLFVBQUEsRUFBWSxJQUFDLENBQUEsVUFBZjtLQUFSOztBQUFxQyxjQUFPLElBQUMsQ0FBQSxVQUFSO0FBQUEsYUFDOUIsQ0FEOEI7QUFBQSxhQUMzQixDQUQyQjtpQkFDcEI7WUFBRSxTQUFBLEVBQVcsSUFBQyxDQUFBLFNBQWQ7O0FB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

},{"lodash":93}],59:[function(require,module,exports){
var Resource, Util;

Util = require('./util.coffee');

module.exports = Resource = (function() {
  Resource.Section = require('./resource_section.coffee');

  function Resource(file) {
    this.file = file;
    this.id = null;
    this.type = null;
    this.length = 0;
  }

  Resource.prototype.parse = function() {
    var nameLength;
    this.type = this.file.readString(4);
    this.id = this.file.readShort();
    nameLength = Util.pad2(this.file.readByte() + 1) - 1;
    this.name = this.file.readString(nameLength);
    return this.length = Util.pad2(this.file.readInt());
  };

  return Resource;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC9yZXNvdXJjZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQTs7QUFBQSxJQUFBLEdBQU8sT0FBQSxDQUFRLGVBQVI7O0FBRVAsTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFDckIsUUFBQyxDQUFBLE9BQUQsR0FBVSxPQUFBLENBQVEsMkJBQVI7O0VBRUcsa0JBQUMsSUFBRDtJQUFDLElBQUMsQ0FBQSxPQUFEO0lBQ1osSUFBQyxDQUFBLEVBQUQsR0FBTTtJQUNOLElBQUMsQ0FBQSxJQUFELEdBQVE7SUFDUixJQUFDLENBQUEsTUFBRCxHQUFVO0VBSEM7O3FCQUtiLEtBQUEsR0FBTyxTQUFBO0FBQ0wsUUFBQTtJQUFBLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBQyxDQUFBLElBQUksQ0FBQyxVQUFOLENBQWlCLENBQWpCO0lBQ1IsSUFBQyxDQUFBLEVBQUQsR0FBTSxJQUFDLENBQUEsSUFBSSxDQUFDLFNBQU4sQ0FBQTtJQUVOLFVBQUEsR0FBYSxJQUFJLENBQUMsSUFBTCxDQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsUUFBTixDQUFBLENBQUEsR0FBbUIsQ0FBN0IsQ0FBQSxHQUFrQztJQUMvQyxJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFpQixVQUFqQjtXQUNSLElBQUMsQ0FBQSxNQUFELEdBQVUsSUFBSSxDQUFDLElBQUwsQ0FBVSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQSxDQUFWO0VBTkwifQ==

},{"./resource_section.coffee":60,"./util.coffee":65}],60:[function(require,module,exports){
var ResourceSection, _;

_ = require('lodash');

module.exports = ResourceSection = (function() {
  var RESOURCES;

  function ResourceSection() {}

  RESOURCES = [require('./resources/layer_comps.coffee'), require('./resources/layer_links.coffee'), require('./resources/resolution_info.coffee')];

  ResourceSection.factory = function(resource) {
    var Section, i, len;
    for (i = 0, len = RESOURCES.length; i < len; i++) {
      Section = RESOURCES[i];
      if (Section.prototype.id !== resource.id) {
        continue;
      }
      return _.tap(new Section(resource), function(s) {
        return s.parse();
      });
    }
    return null;
  };

  return ResourceSection;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlX3NlY3Rpb24uY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlX3NlY3Rpb24uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSOztBQUVKLE1BQU0sQ0FBQyxPQUFQLEdBQXVCO0FBQ3JCLE1BQUE7Ozs7RUFBQSxTQUFBLEdBQVksQ0FDVixPQUFBLENBQVEsZ0NBQVIsQ0FEVSxFQUVWLE9BQUEsQ0FBUSxnQ0FBUixDQUZVLEVBR1YsT0FBQSxDQUFRLG9DQUFSLENBSFU7O0VBTVosZUFBQyxDQUFBLE9BQUQsR0FBVSxTQUFDLFFBQUQ7QUFDUixRQUFBO0FBQUEsU0FBQSwyQ0FBQTs7TUFDRSxJQUFnQixPQUFPLENBQUEsU0FBRSxDQUFBLEVBQVQsS0FBZSxRQUFRLENBQUMsRUFBeEM7QUFBQSxpQkFBQTs7QUFDQSxhQUFPLENBQUMsQ0FBQyxHQUFGLENBQU0sSUFBSSxPQUFKLENBQVksUUFBWixDQUFOLEVBQTZCLFNBQUMsQ0FBRDtlQUFPLENBQUMsQ0FBQyxLQUFGLENBQUE7TUFBUCxDQUE3QjtBQUZUO1dBSUE7RUFMUSJ9

},{"./resources/layer_comps.coffee":62,"./resources/layer_links.coffee":63,"./resources/resolution_info.coffee":64,"lodash":93}],61:[function(require,module,exports){
var Resource, Resources;

Resource = require('./resource.coffee');

module.exports = Resources = (function() {
  function Resources(file) {
    this.file = file;
    this.resources = {};
    this.typeIndex = {};
    this.length = null;
  }

  Resources.prototype.skip = function() {
    this.length = this.file.readInt();
    return this.file.seek(this.length, true);
  };

  Resources.prototype.parse = function() {
    var finish, resource, resourceEnd, section;
    this.length = this.file.readInt();
    finish = this.length + this.file.tell();
    while (this.file.tell() < finish) {
      resource = new Resource(this.file);
      resource.parse();
      resourceEnd = this.file.tell() + resource.length;
      section = Resource.Section.factory(resource);
      if (section == null) {
        this.file.seek(resourceEnd);
        continue;
      }
      this.resources[section.id] = section;
      if (section.name != null) {
        this.typeIndex[section.name] = section.id;
      }
      this.file.seek(resourceEnd);
    }
    return this.file.seek(finish);
  };

  Resources.prototype.resource = function(search) {
    if (typeof search === 'string') {
      return this.byType(search);
    } else {
      return this.resources[search];
    }
  };

  Resources.prototype.byType = function(name) {
    return this.resources[this.typeIndex[name]];
  };

  return Resources;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlcy5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvcmVzb3VyY2VzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBOztBQUFBLFFBQUEsR0FBVyxPQUFBLENBQVEsbUJBQVI7O0FBRVgsTUFBTSxDQUFDLE9BQVAsR0FBdUI7RUFDUixtQkFBQyxJQUFEO0lBQUMsSUFBQyxDQUFBLE9BQUQ7SUFDWixJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLFNBQUQsR0FBYTtJQUNiLElBQUMsQ0FBQSxNQUFELEdBQVU7RUFIQzs7c0JBS2IsSUFBQSxHQUFNLFNBQUE7SUFDSixJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsT0FBTixDQUFBO1dBQ1YsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsSUFBQyxDQUFBLE1BQVosRUFBb0IsSUFBcEI7RUFGSTs7c0JBSU4sS0FBQSxHQUFPLFNBQUE7QUFDTCxRQUFBO0lBQUEsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUEsSUFBSSxDQUFDLE9BQU4sQ0FBQTtJQUNWLE1BQUEsR0FBUyxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFBO0FBRW5CLFdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlLE1BQXJCO01BQ0UsUUFBQSxHQUFXLElBQUksUUFBSixDQUFhLElBQUMsQ0FBQSxJQUFkO01BQ1gsUUFBUSxDQUFDLEtBQVQsQ0FBQTtNQUVBLFdBQUEsR0FBYyxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBQSxDQUFBLEdBQWUsUUFBUSxDQUFDO01BRXRDLE9BQUEsR0FBVSxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQWpCLENBQXlCLFFBQXpCO01BQ1YsSUFBTyxlQUFQO1FBQ0UsSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQVcsV0FBWDtBQUNBLGlCQUZGOztNQUlBLElBQUMsQ0FBQSxTQUFVLENBQUEsT0FBTyxDQUFDLEVBQVIsQ0FBWCxHQUF5QjtNQUN6QixJQUF5QyxvQkFBekM7UUFBQSxJQUFDLENBQUEsU0FBVSxDQUFBLE9BQU8sQ0FBQyxJQUFSLENBQVgsR0FBMkIsT0FBTyxDQUFDLEdBQW5DOztNQUVBLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBTixDQUFXLFdBQVg7SUFkRjtXQWdCQSxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxNQUFYO0VBcEJLOztzQkFzQlAsUUFBQSxHQUFVLFNBQUMsTUFBRDtJQUNSLElBQUcsT0FBTyxNQUFQLEtBQWtCLFFBQXJCO2FBQ0UsSUFBQyxDQUFBLE1BQUQsQ0FBUSxNQUFSLEVBREY7S0FBQSxNQUFBO2FBR0UsSUFBQyxDQUFBLFNBQVUsQ0FBQSxNQUFBLEVBSGI7O0VBRFE7O3NCQU1WLE1BQUEsR0FBUSxTQUFDLElBQUQ7V0FBVSxJQUFDLENBQUEsU0FBVSxDQUFBLElBQUMsQ0FBQSxTQUFVLENBQUEsSUFBQSxDQUFYO0VBQXJCIn0=

},{"./resource.coffee":59}],62:[function(require,module,exports){
var Descriptor, LayerComps;

Descriptor = require('../descriptor.coffee');

module.exports = LayerComps = (function() {
  LayerComps.prototype.id = 1065;

  LayerComps.prototype.name = 'layerComps';

  LayerComps.visibilityCaptured = function(comp) {
    return comp.capturedInfo & parseInt('001', 2) > 0;
  };

  LayerComps.positionCaptured = function(comp) {
    return comp.positionCaptured & parseInt('010', 2) > 0;
  };

  LayerComps.appearanceCaptured = function(comp) {
    return comp.appearanceCaptured & parseInt('100', 2) > 0;
  };

  function LayerComps(resource) {
    this.resource = resource;
    this.file = this.resource.file;
  }

  LayerComps.prototype.parse = function() {
    this.file.seek(4, true);
    return this.data = new Descriptor(this.file).parse();
  };

  LayerComps.prototype.names = function() {
    return this.data.list.map(function(comp) {
      return comp['Nm  '];
    });
  };

  LayerComps.prototype["export"] = function() {
    return this.data.list.map(function(comp) {
      return {
        id: comp.compID,
        name: comp['Nm  '],
        capturedInfo: comp.capturedInfo
      };
    });
  };

  return LayerComps;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlcy9sYXllcl9jb21wcy5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvcmVzb3VyY2VzL2xheWVyX2NvbXBzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBOztBQUFBLFVBQUEsR0FBYSxPQUFBLENBQVEsc0JBQVI7O0FBRWIsTUFBTSxDQUFDLE9BQVAsR0FBdUI7dUJBQ3JCLEVBQUEsR0FBSTs7dUJBQ0osSUFBQSxHQUFNOztFQUVOLFVBQUMsQ0FBQSxrQkFBRCxHQUFxQixTQUFDLElBQUQ7V0FDbkIsSUFBSSxDQUFDLFlBQUwsR0FBb0IsUUFBQSxDQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsQ0FBQSxHQUFxQjtFQUR0Qjs7RUFHckIsVUFBQyxDQUFBLGdCQUFELEdBQW1CLFNBQUMsSUFBRDtXQUNqQixJQUFJLENBQUMsZ0JBQUwsR0FBd0IsUUFBQSxDQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsQ0FBQSxHQUFxQjtFQUQ1Qjs7RUFHbkIsVUFBQyxDQUFBLGtCQUFELEdBQXFCLFNBQUMsSUFBRDtXQUNuQixJQUFJLENBQUMsa0JBQUwsR0FBMEIsUUFBQSxDQUFTLEtBQVQsRUFBZ0IsQ0FBaEIsQ0FBQSxHQUFxQjtFQUQ1Qjs7RUFHUixvQkFBQyxRQUFEO0lBQUMsSUFBQyxDQUFBLFdBQUQ7SUFDWixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxRQUFRLENBQUM7RUFEUDs7dUJBR2IsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsSUFBSSxDQUFDLElBQU4sQ0FBVyxDQUFYLEVBQWMsSUFBZDtXQUNBLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBSSxVQUFKLENBQWUsSUFBQyxDQUFBLElBQWhCLENBQXFCLENBQUMsS0FBdEIsQ0FBQTtFQUZIOzt1QkFJUCxLQUFBLEdBQU8sU0FBQTtXQUFHLElBQUMsQ0FBQSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQVgsQ0FBZSxTQUFDLElBQUQ7YUFBVSxJQUFLLENBQUEsTUFBQTtJQUFmLENBQWY7RUFBSDs7d0JBQ1AsUUFBQSxHQUFRLFNBQUE7V0FDTixJQUFDLENBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFYLENBQWUsU0FBQyxJQUFEO2FBQ2I7UUFBQSxFQUFBLEVBQUksSUFBSSxDQUFDLE1BQVQ7UUFDQSxJQUFBLEVBQU0sSUFBSyxDQUFBLE1BQUEsQ0FEWDtRQUVBLFlBQUEsRUFBYyxJQUFJLENBQUMsWUFGbkI7O0lBRGEsQ0FBZjtFQURNIn0=

},{"../descriptor.coffee":4}],63:[function(require,module,exports){
var LinkLayers;

module.exports = LinkLayers = (function() {
  LinkLayers.prototype.id = 1026;

  LinkLayers.prototype.name = 'LinkLayers';

  function LinkLayers(resource) {
    this.resource = resource;
    this.file = this.resource.file;
    this.linkArray = [];
  }

  LinkLayers.prototype.parse = function() {
    var end;
    end = this.file.tell() + this.resource.length;
    while (end > this.file.tell()) {
      this.linkArray.push(this.file.readShort());
    }
    return this.linkArray.reverse();
  };

  return LinkLayers;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlcy9sYXllcl9saW5rcy5jb2ZmZWUiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIvVXNlcnMvYnJ5YW4vUHJvamVjdHMvcHNkLmpzL2xpYi9wc2QvcmVzb3VyY2VzL2xheWVyX2xpbmtzLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFBOztBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQXVCO3VCQUVyQixFQUFBLEdBQUk7O3VCQUNKLElBQUEsR0FBTTs7RUFFTyxvQkFBQyxRQUFEO0lBQUMsSUFBQyxDQUFBLFdBQUQ7SUFDWixJQUFDLENBQUEsSUFBRCxHQUFRLElBQUMsQ0FBQSxRQUFRLENBQUM7SUFDbEIsSUFBQyxDQUFBLFNBQUQsR0FBYTtFQUZGOzt1QkFJYixLQUFBLEdBQU8sU0FBQTtBQUNMLFFBQUE7SUFBQSxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBQSxHQUFlLElBQUMsQ0FBQSxRQUFRLENBQUM7QUFFL0IsV0FBTSxHQUFBLEdBQU0sSUFBQyxDQUFBLElBQUksQ0FBQyxJQUFOLENBQUEsQ0FBWjtNQUNFLElBQUMsQ0FBQSxTQUFTLENBQUMsSUFBWCxDQUFnQixJQUFDLENBQUEsSUFBSSxDQUFDLFNBQU4sQ0FBQSxDQUFoQjtJQURGO1dBSUEsSUFBQyxDQUFBLFNBQVMsQ0FBQyxPQUFYLENBQUE7RUFQSyJ9

},{}],64:[function(require,module,exports){
var ResolutionInfo;

module.exports = ResolutionInfo = (function() {
  ResolutionInfo.prototype.id = 1005;

  ResolutionInfo.prototype.name = 'resolutionInfo';

  function ResolutionInfo(resource) {
    this.resource = resource;
    this.file = this.resource.file;
  }

  ResolutionInfo.prototype.parse = function() {
    this.h_res = this.file.readUInt() / 65536;
    this.h_res_unit = this.file.readUShort();
    this.width_unit = this.file.readUShort();
    this.v_res = this.file.readUInt() / 65536;
    this.v_res_unit = this.file.readUShort();
    this.height_unit = this.file.readUShort();
    return this.resource.data = this;
  };

  ResolutionInfo.prototype["export"] = function() {
    var data, i, key, len, ref;
    data = {};
    ref = ['h_res', 'h_res_unit', 'width_unit', 'v_res', 'v_res_unit', 'height_unit'];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      data[key] = this[key];
    }
    return data;
  };

  return ResolutionInfo;

})();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlcy9yZXNvbHV0aW9uX2luZm8uY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3Jlc291cmNlcy9yZXNvbHV0aW9uX2luZm8uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUE7O0FBQUEsTUFBTSxDQUFDLE9BQVAsR0FBdUI7MkJBQ3JCLEVBQUEsR0FBSTs7MkJBQ0osSUFBQSxHQUFNOztFQUVPLHdCQUFDLFFBQUQ7SUFBQyxJQUFDLENBQUEsV0FBRDtJQUNaLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBQyxDQUFBLFFBQVEsQ0FBQztFQURQOzsyQkFHYixLQUFBLEdBQU8sU0FBQTtJQUVMLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBQSxHQUFtQjtJQUM1QixJQUFDLENBQUEsVUFBRCxHQUFjLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFBO0lBQ2QsSUFBQyxDQUFBLFVBQUQsR0FBYyxJQUFDLENBQUEsSUFBSSxDQUFDLFVBQU4sQ0FBQTtJQUdkLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBQyxDQUFBLElBQUksQ0FBQyxRQUFOLENBQUEsQ0FBQSxHQUFtQjtJQUM1QixJQUFDLENBQUEsVUFBRCxHQUFjLElBQUMsQ0FBQSxJQUFJLENBQUMsVUFBTixDQUFBO0lBQ2QsSUFBQyxDQUFBLFdBQUQsR0FBZSxJQUFDLENBQUEsSUFBSSxDQUFDLFVBQU4sQ0FBQTtXQUVmLElBQUMsQ0FBQSxRQUFRLENBQUMsSUFBVixHQUFpQjtFQVhaOzs0QkFhUCxRQUFBLEdBQVEsU0FBQTtBQUNOLFFBQUE7SUFBQSxJQUFBLEdBQU87QUFDUDtBQUFBLFNBQUEscUNBQUE7O01BQ0UsSUFBSyxDQUFBLEdBQUEsQ0FBTCxHQUFZLElBQUUsQ0FBQSxHQUFBO0FBRGhCO1dBR0E7RUFMTSJ9

},{}],65:[function(require,module,exports){
module.exports = {
  pad2: function(i) {
    return (i + 1) & ~0x01;
  },
  pad4: function(i) {
    return ((i + 4) & ~0x03) - 1;
  },
  getUnicodeCharacter: function(cp) {
    var first, second;
    if (cp >= 0 && cp <= 0xD7FF || cp >= 0xE000 && cp <= 0xFFFF) {
      return String.fromCharCode(cp);
    } else if (cp >= 0x10000 && cp <= 0x10FFFF) {
      cp -= 0x10000;
      first = ((0xffc00 & cp) >> 10) + 0xD800;
      second = (0x3ff & cp) + 0xDC00;
      return String.fromCharCode(first) + String.fromCharCode(second);
    }
  },
  clamp: function(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3V0aWwuY29mZmVlIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkL3V0aWwuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQ0U7RUFBQSxJQUFBLEVBQU0sU0FBQyxDQUFEO1dBQU8sQ0FBQyxDQUFBLEdBQUksQ0FBTCxDQUFBLEdBQVUsQ0FBQztFQUFsQixDQUFOO0VBQ0EsSUFBQSxFQUFNLFNBQUMsQ0FBRDtXQUFPLENBQUMsQ0FBQyxDQUFBLEdBQUksQ0FBTCxDQUFBLEdBQVUsQ0FBQyxJQUFaLENBQUEsR0FBb0I7RUFBM0IsQ0FETjtFQUVBLG1CQUFBLEVBQXFCLFNBQUMsRUFBRDtBQUNuQixRQUFBO0lBQUEsSUFBRyxFQUFBLElBQU0sQ0FBTixJQUFZLEVBQUEsSUFBTSxNQUFsQixJQUE0QixFQUFBLElBQU0sTUFBTixJQUFpQixFQUFBLElBQU0sTUFBdEQ7QUFDRSxhQUFPLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEVBQXBCLEVBRFQ7S0FBQSxNQUVLLElBQUcsRUFBQSxJQUFNLE9BQU4sSUFBa0IsRUFBQSxJQUFNLFFBQTNCO01BR0gsRUFBQSxJQUFNO01BSU4sS0FBQSxHQUFRLENBQUMsQ0FBQyxPQUFBLEdBQVUsRUFBWCxDQUFBLElBQWtCLEVBQW5CLENBQUEsR0FBeUI7TUFJakMsTUFBQSxHQUFTLENBQUMsS0FBQSxHQUFRLEVBQVQsQ0FBQSxHQUFlO2FBRXhCLE1BQU0sQ0FBQyxZQUFQLENBQW9CLEtBQXBCLENBQUEsR0FBNkIsTUFBTSxDQUFDLFlBQVAsQ0FBb0IsTUFBcEIsRUFiMUI7O0VBSGMsQ0FGckI7RUFvQkEsS0FBQSxFQUFPLFNBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYO1dBQ0wsSUFBSSxDQUFDLEdBQUwsQ0FBUyxJQUFJLENBQUMsR0FBTCxDQUFTLEdBQVQsRUFBYyxHQUFkLENBQVQsRUFBNkIsR0FBN0I7RUFESyxDQXBCUCJ9

},{}],66:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],67:[function(require,module,exports){

},{}],68:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":66,"ieee754":91,"isarray":69}],69:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],70:[function(require,module,exports){
module.exports = require('./module');
},{"./module":71}],71:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var Module, moduleKeywords,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

moduleKeywords = ['extended', 'included'];

exports.Module = Module = (function() {
  function Module() {}

  Module["extends"] = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this[key] = value;
      }
    }
    if ((_ref = obj.extended) != null) {
      _ref.call(this, this);
    }
    return this;
  };

  Module.includes = function(obj) {
    var key, value, _ref;
    for (key in obj) {
      value = obj[key];
      if (__indexOf.call(moduleKeywords, key) < 0) {
        this.prototype[key] = value;
      }
    }
    if ((_ref = obj.included) != null) {
      _ref.call(this, this);
    }
    return this;
  };

  Module.delegate = function() {
    var args, source, target, _i, _len, _results;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    target = args.pop();
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      source = args[_i];
      _results.push(this.prototype[source] = target.prototype[source]);
    }
    return _results;
  };

  Module.aliasFunction = function(to, from) {
    return this.prototype[to] = (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return _this.prototype[from].apply(_this, args);
      };
    })(this);
  };

  Module.aliasProperty = function(to, from) {
    return Object.defineProperty(this.prototype, to, {
      get: function() {
        return this[from];
      },
      set: function(val) {
        return this[from] = val;
      }
    });
  };

  Module.included = function(func) {
    return func.call(this, this.prototype);
  };

  return Module;

})();

},{}],72:[function(require,module,exports){
"use strict";
var Buffer = require("safer-buffer").Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}


},{"safer-buffer":97}],73:[function(require,module,exports){
"use strict";

// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return require('./tables/shiftjis.json') },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return require('./tables/eucjp.json') },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json') },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
        gb18030: function() { return require('./tables/gb18030-ranges.json') },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return require('./tables/cp949.json') },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return require('./tables/cp950.json') },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return require('./tables/cp950.json').concat(require('./tables/big5-added.json')) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};

},{"./tables/big5-added.json":79,"./tables/cp936.json":80,"./tables/cp949.json":81,"./tables/cp950.json":82,"./tables/eucjp.json":83,"./tables/gb18030-ranges.json":84,"./tables/gbk-added.json":85,"./tables/shiftjis.json":86}],74:[function(require,module,exports){
"use strict"; // Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.

var modules = [require("./internal"), require("./utf16"), require("./utf7"), require("./sbcs-codec"), require("./sbcs-data"), require("./sbcs-data-generated"), require("./dbcs-codec"), require("./dbcs-data")]; // Put all encoding/alias/codec definitions to single object and export it. 

for (var i = 0; i < modules.length; i++) {
  var _module = modules[i];

  for (var enc in _module) if (Object.prototype.hasOwnProperty.call(_module, enc)) exports[enc] = _module[enc];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIm1vZHVsZXMiLCJyZXF1aXJlIiwiaSIsImxlbmd0aCIsIm1vZHVsZSIsImVuYyIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLGEsQ0FFQTtBQUNBOztBQUNBLElBQUlBLE9BQU8sR0FBRyxDQUNWQyxPQUFPLENBQUMsWUFBRCxDQURHLEVBRVZBLE9BQU8sQ0FBQyxTQUFELENBRkcsRUFHVkEsT0FBTyxDQUFDLFFBQUQsQ0FIRyxFQUlWQSxPQUFPLENBQUMsY0FBRCxDQUpHLEVBS1ZBLE9BQU8sQ0FBQyxhQUFELENBTEcsRUFNVkEsT0FBTyxDQUFDLHVCQUFELENBTkcsRUFPVkEsT0FBTyxDQUFDLGNBQUQsQ0FQRyxFQVFWQSxPQUFPLENBQUMsYUFBRCxDQVJHLENBQWQsQyxDQVdBOztBQUNBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsT0FBTyxDQUFDRyxNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQyxNQUFJRSxPQUFNLEdBQUdKLE9BQU8sQ0FBQ0UsQ0FBRCxDQUFwQjs7QUFDQSxPQUFLLElBQUlHLEdBQVQsSUFBZ0JELE9BQWhCLEVBQ0ksSUFBSUUsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNMLE9BQXJDLEVBQTZDQyxHQUE3QyxDQUFKLEVBQ0lLLE9BQU8sQ0FBQ0wsR0FBRCxDQUFQLEdBQWVELE9BQU0sQ0FBQ0MsR0FBRCxDQUFyQjtBQUNYIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVwZGF0ZSB0aGlzIGFycmF5IGlmIHlvdSBhZGQvcmVuYW1lL3JlbW92ZSBmaWxlcyBpbiB0aGlzIGRpcmVjdG9yeS5cbi8vIFdlIHN1cHBvcnQgQnJvd3NlcmlmeSBieSBza2lwcGluZyBhdXRvbWF0aWMgbW9kdWxlIGRpc2NvdmVyeSBhbmQgcmVxdWlyaW5nIG1vZHVsZXMgZGlyZWN0bHkuXG52YXIgbW9kdWxlcyA9IFtcbiAgICByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKSxcbiAgICByZXF1aXJlKFwiLi91dGYxNlwiKSxcbiAgICByZXF1aXJlKFwiLi91dGY3XCIpLFxuICAgIHJlcXVpcmUoXCIuL3NiY3MtY29kZWNcIiksXG4gICAgcmVxdWlyZShcIi4vc2Jjcy1kYXRhXCIpLFxuICAgIHJlcXVpcmUoXCIuL3NiY3MtZGF0YS1nZW5lcmF0ZWRcIiksXG4gICAgcmVxdWlyZShcIi4vZGJjcy1jb2RlY1wiKSxcbiAgICByZXF1aXJlKFwiLi9kYmNzLWRhdGFcIiksXG5dO1xuXG4vLyBQdXQgYWxsIGVuY29kaW5nL2FsaWFzL2NvZGVjIGRlZmluaXRpb25zIHRvIHNpbmdsZSBvYmplY3QgYW5kIGV4cG9ydCBpdC4gXG5mb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICBmb3IgKHZhciBlbmMgaW4gbW9kdWxlKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZHVsZSwgZW5jKSlcbiAgICAgICAgICAgIGV4cG9ydHNbZW5jXSA9IG1vZHVsZVtlbmNdO1xufVxuIl19
},{"./dbcs-codec":72,"./dbcs-data":73,"./internal":75,"./sbcs-codec":76,"./sbcs-data":78,"./sbcs-data-generated":77,"./utf16":87,"./utf7":88}],75:[function(require,module,exports){
"use strict";
var Buffer = require("safer-buffer").Buffer;

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = require('string_decoder').StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}

},{"safer-buffer":97,"string_decoder":98}],76:[function(require,module,exports){
"use strict";
var Buffer = require("safer-buffer").Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}

},{"safer-buffer":97}],77:[function(require,module,exports){
"use strict";

// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}
},{}],78:[function(require,module,exports){
"use strict";

// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    "mik": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};


},{}],79:[function(require,module,exports){
module.exports=[
["8740",""],
["8767",""],
["87a1",""],
["8840","",4,""],
["88a1",""],
["8940",""],
["8943",""],
["8946",""],
["894c",""],
["89a1",""],
["89ab",""],
["89b0",""],
["89b5",""],
["89c1",""],
["89c5",""],
["8a40",""],
["8a43",""],
["8a64",""],
["8a76",""],
["8aa1",""],
["8aac",""],
["8ab2",""],
["8abb",""],
["8ac9",""],
["8ace",""],
["8adf",""],
["8af6",""],
["8b40",""],
["8b55",""],
["8ba1",""],
["8bde",""],
["8c40",""],
["8ca1",""],
["8ca7",""],
["8cc9",""],
["8cce",""],
["8ce6",""],
["8d40",""],
["8d42",""],
["8da1",""],
["8e40",""],
["8ea1",""],
["8f40",""],
["8fa1",""],
["9040",""],
["90a1",""],
["9140",""],
["91a1",""],
["9240",""],
["92a1",""],
["9340",""],
["93a1",""],
["9440",""],
["94a1",""],
["9540",""],
["95a1",""],
["9640",""],
["96a1",""],
["9740",""],
["97a1",""],
["9840",""],
["98a1",""],
["9940",""],
["99a1",""],
["9a40",""],
["9aa1",""],
["9b40",""],
["9b62",""],
["9ba1",""],
["9c40",""],
["9ca1",""],
["9d40",""],
["9da1",""],
["9e40",""],
["9ea1",""],
["9ead",""],
["9ec5",""],
["9ef5",""],
["9f40",""],
["9f4f",""],
["9fa1",""],
["9fae",""],
["9fb2",""],
["9fc1",""],
["9fc9",""],
["9fdb",""],
["9fe7",""],
["9feb",""],
["9ff0",""],
["a040",""],
["a055",""],
["a058",""],
["a05b",""],
["a063",""],
["a073",""],
["a0a1",""],
["a0a6",""],
["a0ae",""],
["a0b0",""],
["a0d4",""],
["a0e2",""],
["a3c0","",31,""],
["c6a1","",9,"",9,"",9,"",23],
["c740","",58,""],
["c7a1","",81,"",5,"",4],
["c840","",26,"",25,""],
["c8a1",""],
["c8cd",""],
["c8f5",""],
["f9fe",""],
["fa40",""],
["faa1",""],
["fb40",""],
["fba1",""],
["fc40",""],
["fca1",""],
["fd40",""],
["fda1",""],
["fe40",""],
["fea1",""]
]

},{}],80:[function(require,module,exports){
module.exports=[
["0","\u0000",127,""],
["8140","",5,"",9,"",6,""],
["8180","",6,"",4,"",4,"",5,""],
["8240","",4,"",8,"",4,"",11],
["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],
["8340","",17,"",5,"",10,"",4,"",9,""],
["8380","",5,"",13,"",28,"",4,"",4,"",5],
["8440","",5,"",5,""],
["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],
["8540","",9,""],
["8580","",4,"",6,"",4,"",4,"",7,""],
["8640","",4,"",5,"",4,"",5,""],
["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],
["8740","",7,"",11,"",4,"",4],
["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],
["8840","",9,"",4,"",4,""],
["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],
["8940","",5,"",6,"",4,"",5,"",4,"",16,""],
["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],
["8a40","",4,"",12,""],
["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],
["8b40","",8,"",17,"",6,"",13,""],
["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],
["8c40","",7,""],
["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],
["8d40","",5,"",5,"",5,"",6,"",9,"",4],
["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],
["8e40","",21,"",12,"",6,"",12,""],
["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],
["8f40","",5,"",11,"",8,""],
["8f80","",6,"",14,"",5,"",5,"",4,""],
["9040","",4,"",4,"",6,""],
["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],
["9140","",6,"",6,"",18,"",4,""],
["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],
["9240","",6,"",5,""],
["9280","",5,"",7,"",6,""],
["9340","",6,"",4,"",4,"",5,""],
["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],
["9440","",24,"",7,"",7,"",4,"",8],
["9480","",4,"",4,"",14,"",7,"",7,""],
["9540","",4,"",4,"",6,""],
["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],
["9640","",5,"",4,""],
["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],
["9740","",7,"",8,"",7,"",9,""],
["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],
["9840","",4,"",5,"",9,""],
["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],
["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],
["9980","",114,"",6],
["9a40","",11,"",7,"",13,""],
["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],
["9b40","",4,""],
["9b80","",5,"",4,"",4,"",5,""],
["9c40","",7,""],
["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],
["9d40","",7,"",4,"",9,"",6,""],
["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],
["9e40","",7,"",32,"",7,"",6,"",6],
["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],
["9f40","",6,"",10,"",4,"",10,"",7,""],
["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],
["a040","",9,"",5,"",9,"",11,"",19],
["a080","",9,"",6,"",4,"",11,"",11,"",6,""],
["a1a1","",7,""],
["a2a1","",9],
["a2b1","",19,"",19,"",9],
["a2e5","",9],
["a2f1","",11],
["a3a1","",88,""],
["a4a1","",82],
["a5a1","",85],
["a6a1","",16,"",6],
["a6c1","",16,"",6],
["a6e0",""],
["a6ee",""],
["a6f4",""],
["a7a1","",5,"",25],
["a7d1","",5,"",25],
["a840","",35,"",6],
["a880","",7,""],
["a8a1",""],
["a8bd",""],
["a8c0",""],
["a8c5","",36],
["a940","",8,""],
["a959",""],
["a95c",""],
["a960","",9,"",8],
["a980","",4,""],
["a996",""],
["a9a4","",75],
["aa40","",5,"",5,"",8],
["aa80","",7,"",10,""],
["ab40","",11,"",4,"",5,"",4],
["ab80","",6,"",4],
["ac40","",10,"",8,"",5,"",4,"",11],
["ac80","",6,"",12,"",4,""],
["ad40","",10,"",7,"",15,"",12],
["ad80","",9,"",8,"",6,""],
["ae40","",6,"",7,"",4,""],
["ae80","",7,"",6,"",4,""],
["af40","",4,""],
["af80",""],
["b040","",6,"",5,"",4,"",6,"",7,""],
["b080","",7,"",8,"",9,""],
["b140","",4,"",7,"",10,""],
["b180","",4,"",7,"",7,""],
["b240","",11,"",5,"",11,"",4],
["b280","",12,"",8,"",4,""],
["b340","",5,""],
["b380","",11,"",7,"",6,""],
["b440","",7,"",9],
["b480","",4,"",5,"",6,""],
["b540","",5,"",9,"",4,"",14,"",4,"",8,""],
["b580","",6,"",4,""],
["b640","",6,"",11,"",10,"",4,"",5,""],
["b680","",6,"",4,""],
["b740","",14,"",5,"",9,"",4,"",16],
["b780","",6,""],
["b840","",4,"",10,"",10,"",9,"",5,""],
["b880","",4,""],
["b940","",5,"",10,"",6,""],
["b980","",7,""],
["ba40","",4,"",4,"",7,"",5,""],
["ba80","",4,"",5,"",12,"",5,""],
["bb40","",9,"",36,"",5,"",9],
["bb80","",6,"",4,""],
["bc40","",6,"",6,"",5,"",7,"",13,"",5],
["bc80","",14,"",6,""],
["bd40","",54,"",7],
["bd80","",32,""],
["be40","",12,"",6,"",42],
["be80","",32,""],
["bf40","",62],
["bf80","",4,"",4,"",21,""],
["c040","",35,"",23,""],
["c080","",6,"",9,""],
["c140","",4,"",7,"",4,"",4,"",6,""],
["c180","",4,"",4,"",5,""],
["c240","",6,"",5,""],
["c280","",13,"",5,"",11,""],
["c340","",5,"",4,"",6,""],
["c380","",12,"",4,""],
["c440","",5,"",4,"",4,"",5,"",4,""],
["c480","",7,"",5,"",6,""],
["c540","",14,"",4,"",5,"",4,"",5,""],
["c580","",7,"",7,""],
["c640",""],
["c680","",4,"",9,""],
["c740","",4,"",4,"",6,"",6,"",6,""],
["c780",""],
["c840","",4,"",5,"",5,"",7,"",5,"",7,""],
["c880","",6,"",4,"",4,""],
["c940","",4,"",7,"",12,""],
["c980","",4,"",4,"",10,""],
["ca40","",8,"",8,"",9,"",4,"",10],
["ca80","",4,"",8,""],
["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],
["cb80","",5,"",6,"",14,""],
["cc40","",4,"",10,"",15,"",13,""],
["cc80","",11,"",4,"",7,""],
["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],
["cd80",""],
["ce40","",6,"",5,"",7,""],
["ce80","",4,"",6,"",4,""],
["cf40","",4,"",4,"",6,"",9],
["cf80","",5,"",7,"",4,""],
["d040","",13,"",5,"",5,"",5,"",6,""],
["d080","",4,"",4,"",5,""],
["d140","",4,"",4,"",6,"",5],
["d180","",4,"",4,"",4,""],
["d240","",8,"",24,"",5,"",19,""],
["d280","",26,""],
["d340","",30,"",6],
["d380","",4,"",5,"",21,""],
["d440","",31,"",8,"",21],
["d480","",25,"",6,""],
["d540","",7,"",7,"",46],
["d580","",32,""],
["d640","",34,"",27],
["d680","",30,""],
["d740","",31,"",4,"",25],
["d780","",24,""],
["d840","",8,"",7,"",5,"",6,"",6,"",6,""],
["d880","",6,"",20,""],
["d940","",62],
["d980","",32,""],
["da40","",14,"",8,"",4,"",9,""],
["da80","",12,""],
["db40","",6,"",7,"",4,""],
["db80","",4,"",5,"",11,""],
["dc40","",4,"",6,"",6,"",11,"",6,"",7],
["dc80","",10,"",21,""],
["dd40","",62],
["dd80","",32,""],
["de40","",32,""],
["de80","",4,""],
["df40","",5,"",4,"",4,"",5,"",4,"",6,""],
["df80","",4,""],
["e040","",19,""],
["e080","",10,"",6,"",8,""],
["e140","",4,"",6,"",5,"",5,""],
["e180","",10,"",9,"",8,""],
["e240","",62],
["e280","",32,"",5,""],
["e340","",45,"",16],
["e380","",7,"",24,""],
["e440","",5,"",24,"",31],
["e480","",32,""],
["e540","",51,"",10],
["e580","",31,""],
["e640","",34,"",27],
["e680","",29,""],
["e740","",7,"",54],
["e780","",32,"",6,"",4,""],
["e840","",14,"",43,""],
["e880","",20,""],
["e940","",7,"",42],
["e980","",32,""],
["ea40","",27,"",6,""],
["ea80","",4,"",12,""],
["eb40","",9,"",7,"",9,"",6,""],
["eb80","",4,""],
["ec40","",8,"",4,"",18,"",7],
["ec80","",4,"",7,"",4,"",4,""],
["ed40","",6,"",46],
["ed80","",4,"",23,""],
["ee40","",62],
["ee80","",32,"",4,"",6,""],
["ef40","",5,"",37,"",4],
["ef80","",30,"",4,"",8,""],
["f040","",4,"",28,"",26],
["f080","",9,"",12,"",4,"",6,""],
["f140","",10,"",47],
["f180","",32,""],
["f240","",62],
["f280","",32,""],
["f340","",17,"",6,"",4,""],
["f380","",8,"",6,""],
["f440","",5,"",10,"",10,"",7,"",5],
["f480","",32,""],
["f540","",62],
["f580","",32,""],
["f640","",62],
["f680","",32,"",5,"",5,"",4,"",7,""],
["f740","",62],
["f780","",4,"",4,""],
["f840","",62],
["f880","",32],
["f940","",62],
["f980","",32],
["fa40","",62],
["fa80","",32],
["fb40","",27,"",9,""],
["fb80","",5,"",8,"",5,""],
["fc40","",8,"",4,"",8,"",6],
["fc80","",4,"",5,"",8,""],
["fd40","",4,"",4,"",10,"",38],
["fd80","",5,"",11,"",4,""],
["fe40",""]
]

},{}],81:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["8141","",4,"",6,""],
["8161","",9,"",5,""],
["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],
["8241","",7,"",5],
["8261","",6,"",5,""],
["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],
["8341","",5,"",5,"",7],
["8361","",18,""],
["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],
["8441","",5,"",8],
["8461","",18],
["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],
["8541","",5,"",4,"",6,"",4],
["8561","",5,"",5,"",6,""],
["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],
["8641","",6,"",5,""],
["8661","",6,"",10],
["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],
["8741","",9,"",15],
["8761","",18,""],
["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],
["8841","",4,"",5,"",6,"",4],
["8861","",4,""],
["8881","",15,"",4,"",6,"",5,"",54,""],
["8941","",6,"",5,""],
["8961","",10,"",5,""],
["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],
["8a41","",10,"",6,""],
["8a61","",4,"",18,""],
["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],
["8b41","",5,"",4,"",6,""],
["8b61","",6,"",8],
["8b81","",52,"",4,"",6,"",5,"",18,"",18],
["8c41","",15,"",4],
["8c61","",6,"",5,"",6,"",5],
["8c81","",12,"",26,"",50,"",5,"",16],
["8d41","",16,"",8],
["8d61","",17,""],
["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],
["8e41","",6,"",5,"",8],
["8e61","",4,"",19],
["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],
["8f41","",7,"",17],
["8f61","",7,"",6,"",4],
["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],
["9041","",6,"",5,""],
["9061","",5,"",15],
["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],
["9141","",6,"",5],
["9161","",9,"",5],
["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],
["9241","",7,"",4,""],
["9261","",7,"",7,"",4],
["9281","",21,"",18,"",6,"",7,"",6,"",35,""],
["9341","",4,""],
["9361","",6,"",8],
["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],
["9441","",5,"",5,"",8],
["9461","",5,"",6,"",12],
["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],
["9541","",11,"",5,""],
["9561","",6,"",5,""],
["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],
["9641","",23,""],
["9661","",6,"",5,"",8],
["9681","",10,"",5,"",13,"",33,"",6,"",44],
["9741","",16,"",8],
["9761","",17,"",7],
["9781","",11,"",5,"",6,"",89,""],
["9841","",16,"",5,""],
["9861","",6,"",15],
["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],
["9941","",6,"",5,""],
["9961","",6,"",5,""],
["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],
["9a41","",16],
["9a61","",6,"",6,""],
["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],
["9b41","",6,"",8],
["9b61","",17,"",7],
["9b81","",25,"",4,"",5,"",50,"",22,""],
["9c41","",4,"",5,"",5],
["9c61","",8,"",6,"",9],
["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],
["9d41","",13,"",8],
["9d61","",25],
["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],
["9e41","",7,"",9,""],
["9e61","",4,"",6,""],
["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],
["9f41","",5,"",4,"",5,""],
["9f61","",6,"",5,""],
["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],
["a041","",5,"",6,""],
["a061","",5,"",13],
["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],
["a141","",18,""],
["a161","",6,"",5,""],
["a181","",14,"",5,"",4,"",9,""],
["a241","",5,"",18],
["a261","",6,"",18],
["a281","",7,"",6,"",7,""],
["a341","",6,"",10,""],
["a361","",6,"",16],
["a381","",16,"",4,"",58,"",32,""],
["a441","",5,""],
["a461","",5,"",12],
["a481","",28,"",93],
["a541","",4,"",6,"",5,""],
["a561","",17,"",5,""],
["a581","",16,"",14,"",9],
["a5b0","",9],
["a5c1","",16,"",6],
["a5e1","",16,"",6],
["a641","",19,""],
["a661","",5,"",5,"",6],
["a681","",6,"",18,"",7],
["a741","",4,"",6,"",7],
["a761","",22,""],
["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],
["a841","",10,"",14],
["a861","",18,"",6],
["a881","",19,"",11,""],
["a8a6",""],
["a8a8",""],
["a8b1","",27,"",25,"",14,""],
["a941","",14,"",10],
["a961","",18],
["a981","",14,"",6,"",27,"",25,"",14,""],
["aa41","",6,"",4,""],
["aa61","",4,"",5,"",6,""],
["aa81","",29,"",82],
["ab41","",6,"",5,""],
["ab61","",6,"",5,"",5],
["ab81","",8,"",6,"",12,"",85],
["ac41","",5,"",6,""],
["ac61","",11,"",4],
["ac81","",28,"",5,"",25],
["acd1","",5,"",25],
["ad41","",6,"",5,"",7],
["ad61","",6,"",10,""],
["ad81","",5,"",18,""],
["ae41","",5,"",16],
["ae61","",5,"",6,"",4],
["ae81","",6,"",5,""],
["af41","",19],
["af61","",13,"",5,""],
["af81","",5,"",6,"",5,""],
["b041","",5,"",5,"",12],
["b061","",5,"",19],
["b081","",13,"",6,"",5,"",7,"",4,""],
["b141","",6,"",5,""],
["b161","",6,"",5,"",11],
["b181","",14,"",6,""],
["b241","",6,"",5,""],
["b261","",18,"",5,""],
["b281","",5,"",18,"",6,""],
["b341","",19,""],
["b361","",5,"",5,"",5],
["b381","",5,"",5,"",19,"",4,""],
["b441","",5,"",6,"",5],
["b461","",6,"",10,""],
["b481","",6,"",18,"",4,"",4,""],
["b541","",14,"",5],
["b561","",5,"",5,"",4],
["b581","",6,"",5,"",11,""],
["b641","",7,"",17],
["b661","",15,""],
["b681","",5,"",6,"",5,""],
["b741","",13,"",6,""],
["b761","",20,""],
["b781","",6,"",14,""],
["b841","",7,"",17],
["b861","",8,"",13],
["b881","",5,"",24,"",4,""],
["b941","",6,"",5,""],
["b961","",14,"",6,""],
["b981","",22,"",4,"",4,""],
["ba41","",5,"",6,""],
["ba61","",5,"",4,"",5],
["ba81","",6,"",9,""],
["bb41","",4,"",5,"",4,""],
["bb61","",6,"",5,""],
["bb81","",31,""],
["bc41","",17,""],
["bc61","",5,"",6,""],
["bc81","",4,"",6,"",5,"",5,"",4,""],
["bd41","",7,"",7,""],
["bd61","",5,"",13],
["bd81","",5,"",25,""],
["be41","",7,"",14],
["be61","",7,"",7,""],
["be81","",4,"",4,"",5,"",8,"",6,""],
["bf41","",10,"",14],
["bf61","",18,""],
["bf81","",5,"",7,"",6,"",5,""],
["c041","",5,"",6,"",5],
["c061","",25],
["c081","",6,"",5,"",7,""],
["c141","",5,"",6,""],
["c161","",19,""],
["c181","",31,""],
["c241","",4,"",5,""],
["c261","",4,"",5,"",6,""],
["c281","",5,"",7,"",9,""],
["c341","",4],
["c361","",4,"",5,"",11],
["c381","",5,"",7,"",5,""],
["c441","",7,"",7,""],
["c461","",5,"",4],
["c481","",5,"",11,""],
["c541","",6,"",5,""],
["c561","",6,"",5,"",4],
["c581","",6,"",5,""],
["c641","",6,"",5],
["c6a1",""],
["c7a1",""],
["c8a1",""],
["caa1",""],
["cba1",""],
["cca1",""],
["cda1",""],
["cea1",""],
["cfa1",""],
["d0a1",""],
["d1a1","",5,"",4,""],
["d2a1","",4,"",5,"",10,"",7,"",5,""],
["d3a1",""],
["d4a1",""],
["d5a1",""],
["d6a1",""],
["d7a1",""],
["d8a1",""],
["d9a1",""],
["daa1",""],
["dba1",""],
["dca1",""],
["dda1",""],
["dea1",""],
["dfa1",""],
["e0a1",""],
["e1a1",""],
["e2a1",""],
["e3a1",""],
["e4a1",""],
["e5a1",""],
["e6a1",""],
["e7a1",""],
["e8a1",""],
["e9a1",""],
["eaa1",""],
["eba1",""],
["eca1",""],
["eda1",""],
["eea1",""],
["efa1",""],
["f0a1",""],
["f1a1",""],
["f2a1",""],
["f3a1",""],
["f4a1",""],
["f5a1",""],
["f6a1",""],
["f7a1",""],
["f8a1",""],
["f9a1",""],
["faa1",""],
["fba1",""],
["fca1",""],
["fda1",""]
]

},{}],82:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["a140",""],
["a1a1","",4,""],
["a240","",7,""],
["a2a1","",9,"",9,"",8,"",25,"",21],
["a340","",16,"",6,"",16,"",6,"",10],
["a3a1","",25,""],
["a3e1",""],
["a440",""],
["a4a1",""],
["a540",""],
["a5a1",""],
["a640",""],
["a6a1",""],
["a740",""],
["a7a1",""],
["a840",""],
["a8a1",""],
["a940",""],
["a9a1",""],
["aa40",""],
["aaa1",""],
["ab40",""],
["aba1",""],
["ac40",""],
["aca1",""],
["ad40",""],
["ada1",""],
["ae40",""],
["aea1",""],
["af40",""],
["afa1",""],
["b040",""],
["b0a1",""],
["b140",""],
["b1a1",""],
["b240",""],
["b2a1",""],
["b340",""],
["b3a1",""],
["b440",""],
["b4a1",""],
["b540",""],
["b5a1",""],
["b640",""],
["b6a1",""],
["b740",""],
["b7a1",""],
["b840",""],
["b8a1",""],
["b940",""],
["b9a1",""],
["ba40",""],
["baa1",""],
["bb40",""],
["bba1",""],
["bc40",""],
["bca1",""],
["bd40",""],
["bda1",""],
["be40",""],
["bea1",""],
["bf40",""],
["bfa1",""],
["c040",""],
["c0a1",""],
["c140",""],
["c1a1",""],
["c240",""],
["c2a1",""],
["c340",""],
["c3a1",""],
["c440",""],
["c4a1",""],
["c540",""],
["c5a1",""],
["c640",""],
["c940",""],
["c9a1",""],
["ca40",""],
["caa1",""],
["cb40",""],
["cba1",""],
["cc40",""],
["cca1",""],
["cd40",""],
["cda1",""],
["ce40",""],
["cea1",""],
["cf40",""],
["cfa1",""],
["d040",""],
["d0a1",""],
["d140",""],
["d1a1",""],
["d240",""],
["d2a1",""],
["d340",""],
["d3a1",""],
["d440",""],
["d4a1",""],
["d540",""],
["d5a1",""],
["d640",""],
["d6a1",""],
["d740",""],
["d7a1",""],
["d840",""],
["d8a1",""],
["d940",""],
["d9a1",""],
["da40",""],
["daa1",""],
["db40",""],
["dba1",""],
["dc40",""],
["dca1",""],
["dd40",""],
["dda1",""],
["de40",""],
["dea1",""],
["df40",""],
["dfa1",""],
["e040",""],
["e0a1",""],
["e140",""],
["e1a1",""],
["e240",""],
["e2a1",""],
["e340",""],
["e3a1",""],
["e440",""],
["e4a1",""],
["e540",""],
["e5a1",""],
["e640",""],
["e6a1",""],
["e740",""],
["e7a1",""],
["e840",""],
["e8a1",""],
["e940",""],
["e9a1",""],
["ea40",""],
["eaa1",""],
["eb40",""],
["eba1",""],
["ec40",""],
["eca1",""],
["ed40",""],
["eda1",""],
["ee40",""],
["eea1",""],
["ef40",""],
["efa1",""],
["f040",""],
["f0a1",""],
["f140",""],
["f1a1",""],
["f240",""],
["f2a1",""],
["f340",""],
["f3a1",""],
["f440",""],
["f4a1",""],
["f540",""],
["f5a1",""],
["f640",""],
["f6a1",""],
["f740",""],
["f7a1",""],
["f840",""],
["f8a1",""],
["f940",""],
["f9a1",""]
]

},{}],83:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["8ea1","",62],
["a1a1","",9,""],
["a2a1",""],
["a2ba",""],
["a2ca",""],
["a2dc",""],
["a2f2",""],
["a2fe",""],
["a3b0","",9],
["a3c1","",25],
["a3e1","",25],
["a4a1","",82],
["a5a1","",85],
["a6a1","",16,"",6],
["a6c1","",16,"",6],
["a7a1","",5,"",25],
["a7d1","",5,"",25],
["a8a1",""],
["ada1","",19,"",9],
["adc0",""],
["addf","",4,""],
["b0a1",""],
["b1a1",""],
["b2a1",""],
["b3a1",""],
["b4a1",""],
["b5a1",""],
["b6a1",""],
["b7a1",""],
["b8a1",""],
["b9a1",""],
["baa1",""],
["bba1",""],
["bca1",""],
["bda1",""],
["bea1",""],
["bfa1",""],
["c0a1",""],
["c1a1",""],
["c2a1",""],
["c3a1",""],
["c4a1",""],
["c5a1",""],
["c6a1",""],
["c7a1",""],
["c8a1",""],
["c9a1",""],
["caa1",""],
["cba1",""],
["cca1",""],
["cda1",""],
["cea1",""],
["cfa1",""],
["d0a1",""],
["d1a1",""],
["d2a1",""],
["d3a1",""],
["d4a1",""],
["d5a1",""],
["d6a1",""],
["d7a1",""],
["d8a1",""],
["d9a1",""],
["daa1",""],
["dba1",""],
["dca1",""],
["dda1",""],
["dea1",""],
["dfa1",""],
["e0a1",""],
["e1a1",""],
["e2a1",""],
["e3a1",""],
["e4a1",""],
["e5a1",""],
["e6a1",""],
["e7a1",""],
["e8a1",""],
["e9a1",""],
["eaa1",""],
["eba1",""],
["eca1",""],
["eda1",""],
["eea1",""],
["efa1",""],
["f0a1",""],
["f1a1",""],
["f2a1",""],
["f3a1",""],
["f4a1",""],
["f9a1",""],
["faa1",""],
["fba1",""],
["fca1",""],
["fcf1","",9,""],
["8fa2af",""],
["8fa2c2",""],
["8fa2eb",""],
["8fa6e1",""],
["8fa6e7",""],
["8fa6e9",""],
["8fa6ec",""],
["8fa6f1",""],
["8fa7c2","",10,""],
["8fa7f2","",10,""],
["8fa9a1",""],
["8fa9a4",""],
["8fa9a6",""],
["8fa9a8",""],
["8fa9ab",""],
["8fa9af",""],
["8fa9c1",""],
["8faaa1",""],
["8faaba",""],
["8faba1",""],
["8fabbd",""],
["8fabc5",""],
["8fb0a1",""],
["8fb1a1",""],
["8fb2a1","",4,""],
["8fb3a1",""],
["8fb4a1",""],
["8fb5a1",""],
["8fb6a1","",5,"",4,""],
["8fb7a1","",4,""],
["8fb8a1",""],
["8fb9a1",""],
["8fbaa1","",4,""],
["8fbba1",""],
["8fbca1","",4,""],
["8fbda1","",4,""],
["8fbea1","",4,""],
["8fbfa1",""],
["8fc0a1",""],
["8fc1a1",""],
["8fc2a1",""],
["8fc3a1","",4,""],
["8fc4a1",""],
["8fc5a1",""],
["8fc6a1",""],
["8fc7a1",""],
["8fc8a1",""],
["8fc9a1","",4,"",4,""],
["8fcaa1",""],
["8fcba1",""],
["8fcca1","",9,""],
["8fcda1","",5,""],
["8fcea1","",6,""],
["8fcfa1",""],
["8fd0a1",""],
["8fd1a1",""],
["8fd2a1","",5],
["8fd3a1",""],
["8fd4a1","",4,""],
["8fd5a1",""],
["8fd6a1",""],
["8fd7a1",""],
["8fd8a1",""],
["8fd9a1","",4,"",6,""],
["8fdaa1","",4,""],
["8fdba1","",6,""],
["8fdca1","",4,""],
["8fdda1","",4,""],
["8fdea1","",4,""],
["8fdfa1",""],
["8fe0a1",""],
["8fe1a1","",4,""],
["8fe2a1",""],
["8fe3a1","",5,"",4,""],
["8fe4a1","",4,""],
["8fe5a1","",4,""],
["8fe6a1",""],
["8fe7a1",""],
["8fe8a1","",4,""],
["8fe9a1","",4],
["8feaa1","",4,""],
["8feba1","",4,""],
["8feca1",""],
["8feda1","",4,"",4,""]
]

},{}],84:[function(require,module,exports){
module.exports={"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}
},{}],85:[function(require,module,exports){
module.exports=[
["a140","",62],
["a180","",32],
["a240","",62],
["a280","",32],
["a2ab","",5],
["a2e3",""],
["a2ef",""],
["a2fd",""],
["a340","",62],
["a380","",31,""],
["a440","",62],
["a480","",32],
["a4f4","",10],
["a540","",62],
["a580","",32],
["a5f7","",7],
["a640","",62],
["a680","",32],
["a6b9","",7],
["a6d9","",6],
["a6ec",""],
["a6f3",""],
["a6f6","",8],
["a740","",62],
["a780","",32],
["a7c2","",14],
["a7f2","",12],
["a896","",10],
["a8bc",""],
["a8bf",""],
["a8c1",""],
["a8ea","",20],
["a958",""],
["a95b",""],
["a95d",""],
["a989","",11],
["a997","",12],
["a9f0","",14],
["aaa1","",93],
["aba1","",93],
["aca1","",93],
["ada1","",93],
["aea1","",93],
["afa1","",93],
["d7fa","",4],
["f8a1","",93],
["f9a1","",93],
["faa1","",93],
["fba1","",93],
["fca1","",93],
["fda1","",93],
["fe50",""],
["fe80","",6,"",93]
]

},{}],86:[function(require,module,exports){
module.exports=[
["0","\u0000",128],
["a1","",62],
["8140","",9,""],
["8180",""],
["81b8",""],
["81c8",""],
["81da",""],
["81f0",""],
["81fc",""],
["824f","",9],
["8260","",25],
["8281","",25],
["829f","",82],
["8340","",62],
["8380","",22],
["839f","",16,"",6],
["83bf","",16,"",6],
["8440","",5,"",25],
["8470","",5,"",7],
["8480","",17],
["849f",""],
["8740","",19,"",9],
["875f",""],
["877e",""],
["8780","",4,""],
["889f",""],
["8940",""],
["8980",""],
["8a40",""],
["8a80",""],
["8b40",""],
["8b80",""],
["8c40",""],
["8c80",""],
["8d40",""],
["8d80",""],
["8e40",""],
["8e80",""],
["8f40",""],
["8f80",""],
["9040",""],
["9080",""],
["9140",""],
["9180",""],
["9240",""],
["9280",""],
["9340",""],
["9380",""],
["9440",""],
["9480",""],
["9540",""],
["9580",""],
["9640",""],
["9680",""],
["9740",""],
["9780",""],
["9840",""],
["989f",""],
["9940",""],
["9980",""],
["9a40",""],
["9a80",""],
["9b40",""],
["9b80",""],
["9c40",""],
["9c80",""],
["9d40",""],
["9d80",""],
["9e40",""],
["9e80",""],
["9f40",""],
["9f80",""],
["e040",""],
["e080",""],
["e140",""],
["e180",""],
["e240",""],
["e280",""],
["e340",""],
["e380",""],
["e440",""],
["e480",""],
["e540",""],
["e580",""],
["e640",""],
["e680",""],
["e740",""],
["e780",""],
["e840",""],
["e880",""],
["e940",""],
["e980",""],
["ea40",""],
["ea80",""],
["ed40",""],
["ed80",""],
["ee40",""],
["ee80",""],
["eeef","",9,""],
["f040","",62],
["f080","",124],
["f140","",62],
["f180","",124],
["f240","",62],
["f280","",124],
["f340","",62],
["f380","",124],
["f440","",62],
["f480","",124],
["f540","",62],
["f580","",124],
["f640","",62],
["f680","",124],
["f740","",62],
["f780","",124],
["f840","",62],
["f880","",124],
["f940",""],
["fa40","",9,"",9,""],
["fa80",""],
["fb40",""],
["fb80",""],
["fc40",""]
]

},{}],87:[function(require,module,exports){
"use strict";
var Buffer = require("safer-buffer").Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}



},{"safer-buffer":97}],88:[function(require,module,exports){
"use strict";
var Buffer = require("safer-buffer").Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}



},{"safer-buffer":97}],89:[function(require,module,exports){
"use strict";

var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}


},{}],90:[function(require,module,exports){
(function (process){
"use strict";

// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = require("safer-buffer").Buffer;

var bomHandling = require("./bom-handling"),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = require("../encodings"); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require("./streams")(iconv);
    }

    // Load Node primitive extensions.
    require("./extend-node")(iconv);
}

if ("" != "\u0100") {
    console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
}

}).call(this,require('_process'))
},{"../encodings":74,"./bom-handling":89,"./extend-node":67,"./streams":67,"_process":95,"safer-buffer":97}],91:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],92:[function(require,module,exports){
/*!
 *  Copyright  2008 Fair Oaks Labs, Inc.
 *  All rights reserved.
 */

// Utility object:  Encode/Decode C-style binary primitives to/from octet arrays
function JSPack()
{
	// Module-level (private) variables
	var el,  bBE = false, m = this;


	// Raw byte arrays
	m._DeArray = function (a, p, l)
	{
		return [a.slice(p,p+l)];
	};
	m._EnArray = function (a, p, l, v)
	{
		for (var i = 0; i < l; a[p+i] = v[i]?v[i]:0, i++);
	};

	// ASCII characters
	m._DeChar = function (a, p)
	{
		return String.fromCharCode(a[p]);
	};
	m._EnChar = function (a, p, v)
	{
		a[p] = v.charCodeAt(0);
	};

	// Little-endian (un)signed N-byte integers
	m._DeInt = function (a, p)
	{
		var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, rv, i, f;
		for (rv = 0, i = lsb, f = 1; i != stop; rv+=(a[p+i]*f), i+=nsb, f*=256);
		if (el.bSigned && (rv & Math.pow(2, el.len*8-1))) { rv -= Math.pow(2, el.len*8); }
		return rv;
	};
	m._EnInt = function (a, p, v)
	{
		var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, i;
		v = (v<el.min)?el.min:(v>el.max)?el.max:v;
		for (i = lsb; i != stop; a[p+i]=v&0xff, i+=nsb, v>>=8);
	};

	// ASCII character strings
	m._DeString = function (a, p, l)
	{
		for (var rv = new Array(l), i = 0; i < l; rv[i] = String.fromCharCode(a[p+i]), i++);
		return rv.join('');
	};
	m._EnString = function (a, p, l, v)
	{
		for (var t, i = 0; i < l; a[p+i] = (t=v.charCodeAt(i))?t:0, i++);
	};

	// Little-endian N-bit IEEE 754 floating point
	m._De754 = function (a, p)
	{
		var s, e, m, i, d, nBits, mLen, eLen, eBias, eMax;
		mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

		i = bBE?0:(el.len-1); d = bBE?1:-1; s = a[p+i]; i+=d; nBits = -7;
		for (e = s&((1<<(-nBits))-1), s>>=(-nBits), nBits += eLen; nBits > 0; e=e*256+a[p+i], i+=d, nBits-=8);
		for (m = e&((1<<(-nBits))-1), e>>=(-nBits), nBits += mLen; nBits > 0; m=m*256+a[p+i], i+=d, nBits-=8);

		switch (e)
		{
			case 0:
				// Zero, or denormalized number
				e = 1-eBias;
				break;
			case eMax:
				// NaN, or +/-Infinity
				return m?NaN:((s?-1:1)*Infinity);
			default:
				// Normalized number
				m = m + Math.pow(2, mLen);
				e = e - eBias;
				break;
		}
		return (s?-1:1) * m * Math.pow(2, e-mLen);
	};
	m._En754 = function (a, p, v)
	{
		var s, e, m, i, d, c, mLen, eLen, eBias, eMax;
		mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

		s = v<0?1:0;
		v = Math.abs(v);
		if (isNaN(v) || (v == Infinity))
		{
			m = isNaN(v)?1:0;
			e = eMax;
		}
		else
		{
			e = Math.floor(Math.log(v)/Math.LN2);			// Calculate log2 of the value
			if (v*(c = Math.pow(2, -e)) < 1) { e--; c*=2; }		// Math.log() isn't 100% reliable

			// Round by adding 1/2 the significand's LSD
			if (e+eBias >= 1) { v += el.rt/c; }			// Normalized:  mLen significand digits
			else { v += el.rt*Math.pow(2, 1-eBias); } 		// Denormalized:  <= mLen significand digits
			if (v*c >= 2) { e++; c/=2; }				// Rounding can increment the exponent

			if (e+eBias >= eMax)
			{
				// Overflow
				m = 0;
				e = eMax;
			}
			else if (e+eBias >= 1)
			{
				// Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
				m = (v*c-1)*Math.pow(2, mLen);
				e = e + eBias;
			}
			else
			{
				// Denormalized - also catches the '0' case, somewhat by chance
				m = v*Math.pow(2, eBias-1)*Math.pow(2, mLen);
				e = 0;
			}
		}

		for (i = bBE?(el.len-1):0, d=bBE?-1:1; mLen >= 8; a[p+i]=m&0xff, i+=d, m/=256, mLen-=8);
		for (e=(e<<mLen)|m, eLen+=mLen; eLen > 0; a[p+i]=e&0xff, i+=d, e/=256, eLen-=8);
		a[p+i-d] |= s*128;
	};

	// Convert int64 to array with 3 elements: [lowBits, highBits, unsignedFlag]
	// '>>>' trick to convert signed 32bit int to unsigned int (because << always results in a signed 32bit int)
	m._DeInt64 = function (a, p) {
		var start = bBE ? 0 : 7, nsb = bBE ? 1 : -1, stop = start + nsb * 8, rv = [0,0, !el.bSigned], i, f, rvi;
		for (i = start, rvi = 1, f = 0;
			i != stop;
			rv[rvi] = (((rv[rvi]<<8)>>>0) + a[p + i]), i += nsb, f++, rvi = (f < 4 ? 1 : 0));
		return rv;
	};
	m._EnInt64 = function (a, p, v) {
		var start = bBE ? 0 : 7, nsb = bBE ? 1 : -1, stop = start + nsb * 8, i, f, rvi, s;
		for (i = start, rvi = 1, f = 0, s = 24;
			i != stop;
			a[p + i] = v[rvi]>>s & 0xff, i += nsb, f++, rvi = (f < 4 ? 1 : 0), s = 24 - (8 * (f % 4)));
	};
	

	// Class data
	m._sPattern	= '(\\d+)?([AxcbBhHsfdiIlLqQ])';
	m._lenLut	= {'A':1, 'x':1, 'c':1, 'b':1, 'B':1, 'h':2, 'H':2, 's':1, 'f':4, 'd':8, 'i':4, 'I':4, 'l':4, 'L':4, 'q':8, 'Q':8};
	m._elLut	= {	'A': {en:m._EnArray, de:m._DeArray},
				's': {en:m._EnString, de:m._DeString},
				'c': {en:m._EnChar, de:m._DeChar},
				'b': {en:m._EnInt, de:m._DeInt, len:1, bSigned:true, min:-Math.pow(2, 7), max:Math.pow(2, 7)-1},
				'B': {en:m._EnInt, de:m._DeInt, len:1, bSigned:false, min:0, max:Math.pow(2, 8)-1},
				'h': {en:m._EnInt, de:m._DeInt, len:2, bSigned:true, min:-Math.pow(2, 15), max:Math.pow(2, 15)-1},
				'H': {en:m._EnInt, de:m._DeInt, len:2, bSigned:false, min:0, max:Math.pow(2, 16)-1},
				'i': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
				'I': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
				'l': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
				'L': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
				'f': {en:m._En754, de:m._De754, len:4, mLen:23, rt:Math.pow(2, -24)-Math.pow(2, -77)},
				'd': {en:m._En754, de:m._De754, len:8, mLen:52, rt:0},
				'q': {en:m._EnInt64, de:m._DeInt64, bSigned:true},
				'Q': {en:m._EnInt64, de:m._DeInt64, bSigned:false}};

	// Unpack a series of n elements of size s from array a at offset p with fxn
	m._UnpackSeries = function (n, s, a, p)
	{
		for (var fxn = el.de, rv = [], i = 0; i < n; rv.push(fxn(a, p+i*s)), i++);
		return rv;
	};

	// Pack a series of n elements of size s from array v at offset i to array a at offset p with fxn
	m._PackSeries = function (n, s, a, p, v, i)
	{
		for (var fxn = el.en, o = 0; o < n; fxn(a, p+o*s, v[i+o]), o++);
	};

	// Unpack the octet array a, beginning at offset p, according to the fmt string
	m.Unpack = function (fmt, a, p)
	{
		// Set the private bBE flag based on the format string - assume big-endianness
		bBE = (fmt.charAt(0) != '<');

		p = p?p:0;
		var re = new RegExp(this._sPattern, 'g'), m, n, s, rv = [];
		while (m = re.exec(fmt))
		{
			n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
			s = this._lenLut[m[2]];
			if ((p + n*s) > a.length)
			{
				return undefined;
			}
			switch (m[2])
			{
				case 'A': case 's':
					rv.push(this._elLut[m[2]].de(a, p, n));
					break;
				case 'c': case 'b': case 'B': case 'h': case 'H':
				case 'i': case 'I': case 'l': case 'L': case 'f': case 'd': case 'q': case 'Q':
					el = this._elLut[m[2]];
					rv.push(this._UnpackSeries(n, s, a, p));
					break;
			}
			p += n*s;
		}
		return Array.prototype.concat.apply([], rv);
	};

	// Pack the supplied values into the octet array a, beginning at offset p, according to the fmt string
	m.PackTo = function (fmt, a, p, values)
	{
		// Set the private bBE flag based on the format string - assume big-endianness
		bBE = (fmt.charAt(0) != '<');

		var re = new RegExp(this._sPattern, 'g'), m, n, s, i = 0, j;
		while (m = re.exec(fmt))
		{
			n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
			s = this._lenLut[m[2]];
			if ((p + n*s) > a.length)
			{
				return false;
			}
			switch (m[2])
			{
				case 'A': case 's':
					if ((i + 1) > values.length) { return false; }
					this._elLut[m[2]].en(a, p, n, values[i]);
					i += 1;
					break;
				case 'c': case 'b': case 'B': case 'h': case 'H':
				case 'i': case 'I': case 'l': case 'L': case 'f': case 'd': case 'q': case 'Q':
					el = this._elLut[m[2]];
					if ((i + n) > values.length) { return false; }
					this._PackSeries(n, s, a, p, values, i);
					i += n;
					break;
				case 'x':
					for (j = 0; j < n; j++) { a[p+j] = 0; }
					break;
			}
			p += n*s;
		}
		return a;
	};

	// Pack the supplied values into a new octet array, according to the fmt string
	m.Pack = function (fmt, values)
	{
		return this.PackTo(fmt, new Array(this.CalcLength(fmt)), 0, values);
	};

	// Determine the number of bytes represented by the format string
	m.CalcLength = function (fmt)
	{
		var re = new RegExp(this._sPattern, 'g'), m, sum = 0;
		while (m = re.exec(fmt))
		{
			sum += (((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1])) * this._lenLut[m[2]];
		}
		return sum;
	};
};

exports.jspack = new JSPack();

},{}],93:[function(require,module,exports){
(function (global){
"use strict";

/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;
(function () {
  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;
  /** Used to pool arrays and objects used internally */

  var arrayPool = [],
      objectPool = [];
  /** Used to generate unique IDs */

  var idCounter = 0;
  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */

  var keyPrefix = +new Date() + '';
  /** Used as the size when optimizations are enabled for large arrays */

  var largeArraySize = 75;
  /** Used as the max size of the `arrayPool` and `objectPool` */

  var maxPoolSize = 40;
  /** Used to detect and test whitespace */

  var whitespace = // whitespace
  ' \t\x0B\f\xA0\ufeff' + // line terminators
  '\n\r\u2028\u2029' + // unicode category "Zs" space separators
  '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
  /** Used to match empty string literals in compiled template source */

  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */

  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  /** Used to match regexp flags from their coerced string values */

  var reFlags = /\w*$/;
  /** Used to detected named functions */

  var reFuncName = /^\s*function[ \n\r\t]+\w/;
  /** Used to match "interpolate" template delimiters */

  var reInterpolate = /<%=([\s\S]+?)%>/g;
  /** Used to match leading whitespace and zeros to be removed */

  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
  /** Used to ensure capturing order of template delimiters */

  var reNoMatch = /($^)/;
  /** Used to detect functions containing a `this` reference */

  var reThis = /\bthis\b/;
  /** Used to match unescaped characters in compiled string literals */

  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
  /** Used to assign default `context` object properties */

  var contextProps = ['Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object', 'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN', 'parseInt', 'setTimeout'];
  /** Used to make template sourceURLs easier to identify */

  var templateCounter = 0;
  /** `Object#toString` result shortcuts */

  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';
  /** Used to identify object classifications that `_.clone` supports */

  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
  /** Used as an internal `_.debounce` options object */

  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };
  /** Used as the property descriptor for `__bindData__` */

  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };
  /** Used to determine if values are of the language type Object */

  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };
  /** Used to escape characters for inclusion in compiled string literals */

  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };
  /** Used as a reference to the global object */

  var root = objectTypes[typeof window] && window || this;
  /** Detect free variable `exports` */

  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  /** Detect free variable `module` */

  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  /** Detect the popular CommonJS extension `module.exports` */

  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */

  var freeGlobal = objectTypes[typeof global] && global;

  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }
  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */


  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }
  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */


  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }

    if (type != 'number' && type != 'string') {
      type = 'object';
    }

    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];
    return type == 'object' ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
  }
  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */


  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }

      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }
  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */


  function charAtCallback(value) {
    return value.charCodeAt(0);
  }
  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */


  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }

        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90


    return a.index - b.index;
  }
  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */


  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[length / 2 | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }

    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }

    return result;
  }
  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */


  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }
  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */


  function getArray() {
    return arrayPool.pop() || [];
  }
  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */


  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }
  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */


  function releaseArray(array) {
    array.length = 0;

    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }
  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */


  function releaseObject(object) {
    var cache = object.cache;

    if (cache) {
      releaseObject(cache);
    }

    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;

    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }
  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */


  function slice(array, start, end) {
    start || (start = 0);

    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }

    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }

    return result;
  }
  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */


  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    /** Native constructor references */

    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;
    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */

    var arrayRef = [];
    /** Used for native method references */

    var objectProto = Object.prototype;
    /** Used to restore the original `_` reference in `noConflict` */

    var oldDash = context._;
    /** Used to resolve the internal [[Class]] of values */

    var toString = objectProto.toString;
    /** Used to detect if a method is native */

    var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
    /** Native method shortcuts */

    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;
    /** Used to set meta data on functions */

    var defineProperty = function () {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch (e) {}

      return result;
    }();
    /* Native method shortcuts for methods with the same name as other `lodash` methods */


    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;
    /** Used to lookup a built-in constructor by [[Class]] */

    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;
    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */

    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
    }
    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */


    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    } // ensure `new lodashWrapper` is an instance of `lodash`


    lodashWrapper.prototype = lodash.prototype;
    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */

    var support = lodash.support = {};
    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */

    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */

    support.funcNames = typeof Function.name == 'string';
    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */

    lodash.templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };
    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */

    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        } // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2


        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }

        return func.apply(thisArg, args || arguments);
      }

      setBindData(bound, bindData);
      return bound;
    }
    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */


    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);

        if (typeof result != 'undefined') {
          return result;
        }
      } // inspect [[Class]]


      var isObj = isObject(value);

      if (isObj) {
        var className = toString.call(value);

        if (!cloneableClasses[className]) {
          return value;
        }

        var ctor = ctorByClass[className];

        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }

      var isArr = isArray(value);

      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());
        var length = stackA.length;

        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }

        result = isArr ? ctor(value.length) : {};
      } else {
        result = isArr ? slice(value) : assign({}, value);
      } // add array properties assigned by `RegExp#exec`


      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }

        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      } // exit for shallow clone


      if (!isDeep) {
        return result;
      } // add the source value to the stack of traversed objects
      // and associate it with its clone


      stackA.push(value);
      stackB.push(result); // recursively populate clone (susceptible to call stack limits)

      (isArr ? forEach : forOwn)(value, function (objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }

      return result;
    }
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */


    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    } // fallback for browsers without `Object.create`


    if (!nativeCreate) {
      baseCreate = function () {
        function Object() {}

        return function (prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object();
            Object.prototype = null;
          }

          return result || context.Object();
        };
      }();
    }
    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */


    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      } // exit early for no `thisArg` or already bound by `Function#bind`


      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }

      var bindData = func.__bindData__;

      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }

        bindData = bindData || !support.funcDecomp;

        if (!bindData) {
          var source = fnToString.call(func);

          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }

          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      } // exit early if there are no `this` references or `func` is bound


      if (bindData === false || bindData !== true && bindData[1] & 1) {
        return func;
      }

      switch (argCount) {
        case 1:
          return function (value) {
            return func.call(thisArg, value);
          };

        case 2:
          return function (a, b) {
            return func.call(thisArg, a, b);
          };

        case 3:
          return function (value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };

        case 4:
          return function (accumulator, value, index, collection) {
            return func.call(thisArg, accumulator, value, index, collection);
          };
      }

      return bind(func, thisArg);
    }
    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */


    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;

        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }

        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));

          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }

          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity]);
          }
        }

        args || (args = arguments);

        if (isBindKey) {
          func = thisBinding[key];
        }

        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }

        return func.apply(thisBinding, args);
      }

      setBindData(bound, bindData);
      return bound;
    }
    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */


    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);

        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }

      while (++index < length) {
        var value = array[index];

        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }

      if (isLarge) {
        releaseObject(values);
      }

      return result;
    }
    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */


    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }

          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;
          result.length += valLength;

          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }

      return result;
    }
    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);

        if (typeof result != 'undefined') {
          return !!result;
        }
      } // exit early for identical values


      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || 1 / a == 1 / b;
      }

      var type = typeof a,
          otherType = typeof b; // exit early for unlike primitive values

      if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
        return false;
      } // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4


      if (a == null || b == null) {
        return a === b;
      } // compare [[Class]] names


      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }

      if (otherClass == argsClass) {
        otherClass = objectClass;
      }

      if (className != otherClass) {
        return false;
      }

      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return a != +a ? b != +b // but treat `+0` vs. `-0` as not equal
          : a == 0 ? 1 / a == 1 / b : a == +b;

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }

      var isArr = className == arrayClass;

      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        } // exit for functions and DOM nodes


        if (className != objectClass) {
          return false;
        } // in older versions of Opera, `arguments` objects have `Array` constructors


        var ctorA = a.constructor,
            ctorB = b.constructor; // non `Object` object instances with different constructors are not equal

        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && 'constructor' in a && 'constructor' in b) {
          return false;
        }
      } // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)


      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());
      var length = stackA.length;

      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }

      var size = 0;
      result = true; // add `a` and `b` to the stack of traversed objects

      stackA.push(a);
      stackB.push(b); // recursively compare objects and arrays (susceptible to call stack limits)

      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function (value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++; // deep compare each property value.

            return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function (value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return result = --size > -1;
            }
          });
        }
      }

      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }

      return result;
    }
    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */


    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function (source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;

          while (stackLength--) {
            if (found = stackA[stackLength] == source) {
              value = stackB[stackLength];
              break;
            }
          }

          if (!found) {
            var isShallow;

            if (callback) {
              result = callback(value, source);

              if (isShallow = typeof result != 'undefined') {
                value = result;
              }
            }

            if (!isShallow) {
              value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
            } // add `source` and associated `value` to the stack of traversed objects


            stackA.push(source);
            stackB.push(value); // recursively merge objects and arrays (susceptible to call stack limits)

            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        } else {
          if (callback) {
            result = callback(value, source);

            if (typeof result == 'undefined') {
              result = source;
            }
          }

          if (typeof result != 'undefined') {
            value = result;
          }
        }

        object[key] = value;
      });
    }
    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */


    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }
    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */


    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];
      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = callback || isLarge ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }

      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
          if (callback || isLarge) {
            seen.push(computed);
          }

          result.push(value);
        }
      }

      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }

      return result;
    }
    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */


    function createAggregator(setter) {
      return function (collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);
        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function (value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }

        return result;
      };
    }
    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */


    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError();
      }

      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }

      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }

      var bindData = func && func.__bindData__;

      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);

        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }

        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        } // set `thisBinding` is not previously bound


        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        } // set if previously bound but not currently (subsequent curried functions)


        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        } // set curried arity if not yet set


        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        } // append partial left arguments


        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        } // append partial right arguments


        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        } // merge flags


        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      } // fast path for `_.bind`


      var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }
    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */


    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }
    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */


    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }
    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */


    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }
    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */


    var setBindData = !defineProperty ? noop : function (func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
      descriptor.value = null;
    };
    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */

    function shimIsPlainObject(value) {
      var ctor, result; // avoid non Object objects, `arguments` objects, and DOM elements

      if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      } // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.


      forIn(value, function (value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }
    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */


    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }
    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
    }
    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */


    var isArray = nativeIsArray || function (value) {
      return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
    };
    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */


    var shimKeys = function (object) {
      var index,
          iterable = object,
          result = [];
      if (!iterable) return result;
      if (!objectTypes[typeof object]) return result;

      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          result.push(index);
        }
      }

      return result;
    };
    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */


    var keys = !nativeKeys ? shimKeys : function (object) {
      if (!isObject(object)) {
        return [];
      }

      return nativeKeys(object);
    };
    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */

    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    /** Used to convert HTML entities to characters */

    var htmlUnescapes = invert(htmlEscapes);
    /** Used to match HTML entities and HTML characters */

    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */

    var assign = function (object, source, guard) {
      var index,
          iterable = object,
          result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;

      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }

      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];

        if (iterable && objectTypes[typeof iterable]) {
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable] && keys(iterable),
              length = ownProps ? ownProps.length : 0;

          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
          }
        }
      }

      return result;
    };
    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */


    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }

      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */


    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }
    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */


    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }
    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */


    var defaults = function (object, source, guard) {
      var index,
          iterable = object,
          result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;

      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];

        if (iterable && objectTypes[typeof iterable]) {
          var ownIndex = -1,
              ownProps = objectTypes[typeof iterable] && keys(iterable),
              length = ownProps ? ownProps.length : 0;

          while (++ownIndex < length) {
            index = ownProps[ownIndex];
            if (typeof result[index] == 'undefined') result[index] = iterable[index];
          }
        }
      }

      return result;
    };
    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */


    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function (value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */


    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function (value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */


    var forIn = function (collection, callback, thisArg) {
      var index,
          iterable = collection,
          result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);

      for (index in iterable) {
        if (callback(iterable[index], index, collection) === false) return result;
      }

      return result;
    };
    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */


    function forInRight(object, callback, thisArg) {
      var pairs = [];
      forIn(object, function (value, key) {
        pairs.push(key, value);
      });
      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);

      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }

      return object;
    }
    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */


    var forOwn = function (collection, callback, thisArg) {
      var index,
          iterable = collection,
          result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      var ownIndex = -1,
          ownProps = objectTypes[typeof iterable] && keys(iterable),
          length = ownProps ? ownProps.length : 0;

      while (++ownIndex < length) {
        index = ownProps[ownIndex];
        if (callback(iterable[index], index, collection) === false) return result;
      }

      return result;
    };
    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */


    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;
      callback = baseCreateCallback(callback, thisArg, 3);

      while (length--) {
        var key = props[length];

        if (callback(object[key], key, object) === false) {
          break;
        }
      }

      return object;
    }
    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */


    function functions(object) {
      var result = [];
      forIn(object, function (value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }
    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */


    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }
    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */


    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }

      return result;
    }
    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */


    function isBoolean(value) {
      return value === true || value === false || value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }
    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */


    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }
    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */


    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }
    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */


    function isEmpty(value) {
      var result = true;

      if (!value) {
        return result;
      }

      var className = toString.call(value),
          length = value.length;

      if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
        return !length;
      }

      forOwn(value, function () {
        return result = false;
      });
      return result;
    }
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */


    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }
    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */


    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }
    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */


    function isFunction(value) {
      return typeof value == 'function';
    }
    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */


    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }
    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */


    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }
    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */


    function isNull(value) {
      return value === null;
    }
    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */


    function isNumber(value) {
      return typeof value == 'number' || value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }
    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */


    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }

      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
      return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
    };
    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */

    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }
    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */


    function isString(value) {
      return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }
    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */


    function isUndefined(value) {
      return typeof value == 'undefined';
    }
    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */


    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function (value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }
    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */


    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      } // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments


      if (typeof args[2] != 'number') {
        length = args.length;
      }

      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }

      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }

      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }
    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */


    function omit(object, callback, thisArg) {
      var result = {};

      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function (value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function (value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }

      return result;
    }
    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */


    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }

      return result;
    }
    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */


    function pick(object, callback, thisArg) {
      var result = {};

      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];

          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function (value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }

      return result;
    }
    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */


    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);

      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;
          accumulator = baseCreate(proto);
        }
      }

      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function (value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }

      return accumulator;
    }
    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */


    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }

      return result;
    }
    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */


    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = args[2] && args[2][args[1]] === collection ? 1 : props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = collection[props[index]];
      }

      return result;
    }
    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */


    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;
      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;

      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function (value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }

      return result;
    }
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */


    var countBy = createAggregator(function (result, value, key) {
      hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
    });
    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */

    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          return result = !!callback(value, index, collection);
        });
      }

      return result;
    }
    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */


    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];

          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }

      return result;
    }
    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */


    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];

          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function (value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }
    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */


    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function (value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */


    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);

      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }

      return collection;
    }
    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */


    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);

      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function (value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }

      return collection;
    }
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */


    var groupBy = createAggregator(function (result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */

    var indexBy = createAggregator(function (result, value, key) {
      result[key] = value;
    });
    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */

    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);
      forEach(collection, function (value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }
    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */


    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);

      if (typeof length == 'number') {
        var result = Array(length);

        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function (value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }

      return result;
    }
    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */


    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed; // allows working with functions like `_.map` without using
      // their `index` argument as a callback

      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }

      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];

          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
        forEach(collection, function (value, index, collection) {
          var current = callback(value, index, collection);

          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }

      return result;
    }
    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */


    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed; // allows working with functions like `_.map` without using
      // their `index` argument as a callback

      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }

      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];

          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
        forEach(collection, function (value, index, collection) {
          var current = callback(value, index, collection);

          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }

      return result;
    }
    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */


    var pluck = map;
    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */

    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }

        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
        });
      }

      return accumulator;
    }
    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */


    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function (value, index, collection) {
        accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }
    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */


    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function (value, index, collection) {
        return !callback(value, index, collection);
      });
    }
    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */


    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }

      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }

      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }
    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */


    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);
      forEach(collection, function (value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }
    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */


    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }
    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */


    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (result = callback(collection[index], index, collection)) {
            break;
          }
        }
      } else {
        forOwn(collection, function (value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }

      return !!result;
    }
    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */


    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }

      forEach(collection, function (value, key, collection) {
        var object = result[++index] = getObject();

        if (isArr) {
          object.criteria = map(callback, function (key) {
            return value[key];
          });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }

        object.index = index;
        object.value = value;
      });
      length = result.length;
      result.sort(compareAscending);

      while (length--) {
        var object = result[length];
        result[length] = object.value;

        if (!isArr) {
          releaseArray(object.criteria);
        }

        releaseObject(object);
      }

      return result;
    }
    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */


    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }

      return values(collection);
    }
    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */


    var where = filter;
    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */

    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value) {
          result.push(value);
        }
      }

      return result;
    }
    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */


    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }
    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */


    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);

      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }

      return -1;
    }
    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */


    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);

      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */


    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);

        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;

        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }

      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }
    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */


    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array ? null : isShallow;
        isShallow = false;
      }

      if (callback != null) {
        array = map(array, callback, thisArg);
      }

      return baseFlatten(array, isShallow);
    }
    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */


    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }

      return baseIndexOf(array, value, fromIndex);
    }
    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */


    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);

        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : callback || n;
      }

      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }
    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */


    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];

        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
        }
      }

      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer: while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);

          while (--argsIndex) {
            cache = caches[argsIndex];

            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }

          result.push(value);
        }
      }

      while (argsLength--) {
        cache = caches[argsLength];

        if (cache) {
          releaseObject(cache);
        }
      }

      releaseArray(caches);
      releaseArray(seen);
      return result;
    }
    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */


    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);

        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;

        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }

      return slice(array, nativeMax(0, length - n));
    }
    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */


    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;

      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }

      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }

      return -1;
    }
    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */


    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];

        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }

      return array;
    }
    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */


    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : +step || 1;

      if (end == null) {
        end = start;
        start = 0;
      } // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s


      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }

      return result;
    }
    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */


    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      while (++index < length) {
        var value = array[index];

        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }

      return result;
    }
    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */


    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;
        callback = lodash.createCallback(callback, thisArg, 3);

        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : nativeMax(0, callback);
      }

      return slice(array, n);
    }
    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */


    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low; // explicitly reference `identity` for better inlining in Firefox

      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = low + high >>> 1;
        callback(array[mid]) < value ? low = mid + 1 : high = mid;
      }

      return low;
    }
    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */


    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }
    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */


    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array ? null : isSorted;
        isSorted = false;
      }

      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }

      return baseUniq(array, isSorted, callback);
    }
    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */


    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }
    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */


    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];

        if (isArray(array) || isArguments(array)) {
          var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
        }
      }

      return result || [];
    }
    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */


    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }

      return result;
    }
    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */


    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }

      while (++index < length) {
        var key = keys[index];

        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }

      return result;
    }
    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */


    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError();
      }

      return function () {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */


    function bind(func, thisArg) {
      return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
    }
    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */


    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }

      return object;
    }
    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */


    function bindKey(object, key) {
      return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
    }
    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */


    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError();
        }
      }

      return function () {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }

        return args[0];
      };
    }
    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */


    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : +arity || func.length;
      return createWrapper(func, 4, null, null, null, arity);
    }
    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */


    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError();
      }

      wait = nativeMax(0, wait) || 0;

      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      var delayed = function () {
        var remaining = wait - (now() - stamp);

        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }

          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;

          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);

            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function () {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }

        maxTimeoutId = timeoutId = trailingCall = undefined;

        if (trailing || maxWait !== wait) {
          lastCalled = now();
          result = func.apply(thisArg, args);

          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function () {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }

          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }

            lastCalled = stamp;
            result = func.apply(thisArg, args);
          } else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }

        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        } else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }

        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }

        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }

        return result;
      };
    }
    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */


    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError();
      }

      var args = slice(arguments, 1);
      return setTimeout(function () {
        func.apply(undefined, args);
      }, 1);
    }
    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */


    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError();
      }

      var args = slice(arguments, 2);
      return setTimeout(function () {
        func.apply(undefined, args);
      }, wait);
    }
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */


    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError();
      }

      var memoized = function () {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
        return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
      };

      memoized.cache = {};
      return memoized;
    }
    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */


    function once(func) {
      var ran, result;

      if (!isFunction(func)) {
        throw new TypeError();
      }

      return function () {
        if (ran) {
          return result;
        }

        ran = true;
        result = func.apply(this, arguments); // clear the `func` variable so the function may be garbage collected

        func = null;
        return result;
      };
    }
    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */


    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }
    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */


    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }
    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */


    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError();
      }

      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }
    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */


    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }
    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */


    function constant(value) {
      return function () {
        return value;
      };
    }
    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */


    function createCallback(func, thisArg, argCount) {
      var type = typeof func;

      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      } // handle "_.pluck" style callback shorthands


      if (type != 'object') {
        return property(func);
      }

      var props = keys(func),
          key = props[0],
          a = func[key]; // handle "_.where" style callback shorthands

      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function (object) {
          var b = object[key];
          return a === b && (a !== 0 || 1 / a == 1 / b);
        };
      }

      return function (object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }

        return result;
      };
    }
    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */


    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }
    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */


    function identity(value) {
      return value;
    }
    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */


    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || !options && !methodNames.length) {
        if (options == null) {
          options = source;
        }

        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }

      var ctor = object,
          isFunc = isFunction(ctor);
      forEach(methodNames, function (methodName) {
        var func = object[methodName] = source[methodName];

        if (isFunc) {
          ctor.prototype[methodName] = function () {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];
            push.apply(args, arguments);
            var result = func.apply(object, args);

            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }

              result = new ctor(result);
              result.__chain__ = chainAll;
            }

            return result;
          };
        }
      });
    }
    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */


    function noConflict() {
      context._ = oldDash;
      return this;
    }
    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */


    function noop() {} // no operation performed

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */


    var now = isNative(now = Date.now) && now || function () {
      return new Date().getTime();
    };
    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */


    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };
    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */

    function property(key) {
      return function (object) {
        return object[key];
      };
    }
    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */


    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        } else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }

      if (noMin && noMax) {
        max = 1;
      }

      min = +min || 0;

      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }

      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max);
      }

      return baseRandom(min, max);
    }
    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */


    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }
    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * https://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */


    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || ''); // avoid missing dependencies when `iteratorTemplate` is not defined

      options = defaults({}, options, settings);
      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);
      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '"; // compile the regexp to match each delimiter

      var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
      text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue); // escape characters that cannot be included in string literals

        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar); // replace delimiters with snippets

        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }

        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }

        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }

        index = offset + match.length; // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value

        return match;
      });
      source += "';\n"; // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain

      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      } // cleanup code by stripping empty strings


      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // frame code as the function body

      source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}'; // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl

      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) {
        return result(data);
      } // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process


      result.source = source;
      return result;
    }
    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */


    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);
      callback = baseCreateCallback(callback, thisArg, 1);

      while (++index < n) {
        result[index] = callback(index);
      }

      return result;
    }
    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */


    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }
    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */


    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }
    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */


    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }
    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */


    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */


    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }
    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */


    function wrapperToString() {
      return String(this.__wrapped__);
    }
    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */


    function wrapperValueOf() {
      return this.__wrapped__;
    }
    /*--------------------------------------------------------------------------*/
    // add functions that return wrapped values when chaining


    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject; // add aliases

    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip; // add functions to `lodash.prototype`

    mixin(lodash);
    /*--------------------------------------------------------------------------*/
    // add functions that return unwrapped values when chaining

    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId; // add aliases

    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;
    mixin(function () {
      var source = {};
      forOwn(lodash, function (func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);
    /*--------------------------------------------------------------------------*/
    // add functions capable of returning wrapped and unwrapped values when chaining

    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample; // add aliases

    lodash.take = first;
    lodash.head = first;
    forOwn(lodash, function (func, methodName) {
      var callbackable = methodName !== 'sample';

      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function (n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);
          return !chainAll && (n == null || guard && !(callbackable && typeof n == 'function')) ? result : new lodashWrapper(result, chainAll);
        };
      }
    });
    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */

    lodash.VERSION = '2.4.2'; // add "Chaining" functions to the wrapper

    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf; // add `Array` functions that return unwrapped values

    forEach(['join', 'pop', 'shift'], function (methodName) {
      var func = arrayRef[methodName];

      lodash.prototype[methodName] = function () {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);
        return chainAll ? new lodashWrapper(result, chainAll) : result;
      };
    }); // add `Array` functions that return the existing wrapped value

    forEach(['push', 'reverse', 'sort', 'unshift'], function (methodName) {
      var func = arrayRef[methodName];

      lodash.prototype[methodName] = function () {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    }); // add `Array` functions that return new wrapped values

    forEach(['concat', 'slice', 'splice'], function (methodName) {
      var func = arrayRef[methodName];

      lodash.prototype[methodName] = function () {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });
    return lodash;
  }
  /*--------------------------------------------------------------------------*/
  // expose Lo-Dash


  var _ = runInContext(); // some AMD build optimizers like r.js check for condition patterns like the following:


  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _; // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module

    define(function () {
      return _;
    });
  } // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
      // in Node.js or RingoJS
      if (moduleExports) {
        (freeModule.exports = _)._ = _;
      } // in Narwhal or Rhino -require
      else {
          freeExports._ = _;
        }
    } else {
      // in a browser or Rhino
      root._ = _;
    }
}).call(void 0);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxvZGFzaC5qcyJdLCJuYW1lcyI6WyJ1bmRlZmluZWQiLCJhcnJheVBvb2wiLCJvYmplY3RQb29sIiwiaWRDb3VudGVyIiwia2V5UHJlZml4IiwiRGF0ZSIsImxhcmdlQXJyYXlTaXplIiwibWF4UG9vbFNpemUiLCJ3aGl0ZXNwYWNlIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlRnVuY05hbWUiLCJyZUludGVycG9sYXRlIiwicmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MiLCJSZWdFeHAiLCJyZU5vTWF0Y2giLCJyZVRoaXMiLCJyZVVuZXNjYXBlZFN0cmluZyIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsImFyZ3NDbGFzcyIsImFycmF5Q2xhc3MiLCJib29sQ2xhc3MiLCJkYXRlQ2xhc3MiLCJmdW5jQ2xhc3MiLCJudW1iZXJDbGFzcyIsIm9iamVjdENsYXNzIiwicmVnZXhwQ2xhc3MiLCJzdHJpbmdDbGFzcyIsImNsb25lYWJsZUNsYXNzZXMiLCJkZWJvdW5jZU9wdGlvbnMiLCJkZXNjcmlwdG9yIiwib2JqZWN0VHlwZXMiLCJzdHJpbmdFc2NhcGVzIiwicm9vdCIsIndpbmRvdyIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiYmFzZUluZGV4T2YiLCJhcnJheSIsInZhbHVlIiwiZnJvbUluZGV4IiwiaW5kZXgiLCJsZW5ndGgiLCJjYWNoZUluZGV4T2YiLCJjYWNoZSIsInR5cGUiLCJrZXkiLCJjYWNoZVB1c2giLCJ0eXBlQ2FjaGUiLCJwdXNoIiwiY2hhckF0Q2FsbGJhY2siLCJjaGFyQ29kZUF0IiwiY29tcGFyZUFzY2VuZGluZyIsImEiLCJiIiwiYWMiLCJjcml0ZXJpYSIsImJjIiwib3RoZXIiLCJjcmVhdGVDYWNoZSIsImZpcnN0IiwibWlkIiwibGFzdCIsImdldE9iamVjdCIsInJlc3VsdCIsImVzY2FwZVN0cmluZ0NoYXIiLCJtYXRjaCIsImdldEFycmF5IiwicG9wIiwicmVsZWFzZUFycmF5IiwicmVsZWFzZU9iamVjdCIsIm9iamVjdCIsIm51bWJlciIsInN0cmluZyIsInNsaWNlIiwic3RhcnQiLCJlbmQiLCJBcnJheSIsInJ1bkluQ29udGV4dCIsImNvbnRleHQiLCJfIiwiZGVmYXVsdHMiLCJPYmplY3QiLCJwaWNrIiwiQm9vbGVhbiIsIkZ1bmN0aW9uIiwiTWF0aCIsIk51bWJlciIsIlN0cmluZyIsIlR5cGVFcnJvciIsImFycmF5UmVmIiwib2JqZWN0UHJvdG8iLCJwcm90b3R5cGUiLCJvbGREYXNoIiwidG9TdHJpbmciLCJyZU5hdGl2ZSIsInJlcGxhY2UiLCJjZWlsIiwiY2xlYXJUaW1lb3V0IiwiZmxvb3IiLCJmblRvU3RyaW5nIiwiZ2V0UHJvdG90eXBlT2YiLCJpc05hdGl2ZSIsImhhc093blByb3BlcnR5Iiwic2V0VGltZW91dCIsInNwbGljZSIsInVuc2hpZnQiLCJkZWZpbmVQcm9wZXJ0eSIsIm8iLCJmdW5jIiwiZSIsIm5hdGl2ZUNyZWF0ZSIsImNyZWF0ZSIsIm5hdGl2ZUlzQXJyYXkiLCJpc0FycmF5IiwibmF0aXZlSXNGaW5pdGUiLCJpc0Zpbml0ZSIsIm5hdGl2ZUlzTmFOIiwiaXNOYU4iLCJuYXRpdmVLZXlzIiwia2V5cyIsIm5hdGl2ZU1heCIsIm1heCIsIm5hdGl2ZU1pbiIsIm1pbiIsIm5hdGl2ZVBhcnNlSW50IiwicGFyc2VJbnQiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJjdG9yQnlDbGFzcyIsImxvZGFzaCIsImNhbGwiLCJsb2Rhc2hXcmFwcGVyIiwiY2hhaW5BbGwiLCJfX2NoYWluX18iLCJfX3dyYXBwZWRfXyIsInN1cHBvcnQiLCJmdW5jRGVjb21wIiwiV2luUlRFcnJvciIsInRlc3QiLCJmdW5jTmFtZXMiLCJuYW1lIiwidGVtcGxhdGVTZXR0aW5ncyIsImJhc2VCaW5kIiwiYmluZERhdGEiLCJwYXJ0aWFsQXJncyIsInRoaXNBcmciLCJib3VuZCIsImFyZ3MiLCJhcHBseSIsImFyZ3VtZW50cyIsInRoaXNCaW5kaW5nIiwiYmFzZUNyZWF0ZSIsImlzT2JqZWN0Iiwic2V0QmluZERhdGEiLCJiYXNlQ2xvbmUiLCJpc0RlZXAiLCJjYWxsYmFjayIsInN0YWNrQSIsInN0YWNrQiIsImlzT2JqIiwiY2xhc3NOYW1lIiwiY3RvciIsInNvdXJjZSIsImV4ZWMiLCJsYXN0SW5kZXgiLCJpc0FyciIsImluaXRlZFN0YWNrIiwiYXNzaWduIiwiaW5wdXQiLCJmb3JFYWNoIiwiZm9yT3duIiwib2JqVmFsdWUiLCJwcm9wZXJ0aWVzIiwiYmFzZUNyZWF0ZUNhbGxiYWNrIiwiYXJnQ291bnQiLCJpZGVudGl0eSIsIl9fYmluZERhdGFfXyIsImNvbGxlY3Rpb24iLCJhY2N1bXVsYXRvciIsImJpbmQiLCJiYXNlQ3JlYXRlV3JhcHBlciIsImJpdG1hc2siLCJwYXJ0aWFsUmlnaHRBcmdzIiwiYXJpdHkiLCJpc0JpbmQiLCJpc0JpbmRLZXkiLCJpc0N1cnJ5IiwiaXNDdXJyeUJvdW5kIiwiYmFzZURpZmZlcmVuY2UiLCJ2YWx1ZXMiLCJpbmRleE9mIiwiZ2V0SW5kZXhPZiIsImlzTGFyZ2UiLCJiYXNlRmxhdHRlbiIsImlzU2hhbGxvdyIsImlzU3RyaWN0IiwiaXNBcmd1bWVudHMiLCJ2YWxJbmRleCIsInZhbExlbmd0aCIsInJlc0luZGV4IiwiYmFzZUlzRXF1YWwiLCJpc1doZXJlIiwib3RoZXJUeXBlIiwib3RoZXJDbGFzcyIsImFXcmFwcGVkIiwiYldyYXBwZWQiLCJjdG9yQSIsImNvbnN0cnVjdG9yIiwiY3RvckIiLCJpc0Z1bmN0aW9uIiwic2l6ZSIsImZvckluIiwiYmFzZU1lcmdlIiwiZm91bmQiLCJpc1BsYWluT2JqZWN0Iiwic3RhY2tMZW5ndGgiLCJiYXNlUmFuZG9tIiwiYmFzZVVuaXEiLCJpc1NvcnRlZCIsInNlZW4iLCJjb21wdXRlZCIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJzZXR0ZXIiLCJjcmVhdGVDYWxsYmFjayIsImNyZWF0ZVdyYXBwZXIiLCJpc1BhcnRpYWwiLCJpc1BhcnRpYWxSaWdodCIsImNyZWF0ZXIiLCJlc2NhcGVIdG1sQ2hhciIsImh0bWxFc2NhcGVzIiwibm9vcCIsInNoaW1Jc1BsYWluT2JqZWN0IiwidW5lc2NhcGVIdG1sQ2hhciIsImh0bWxVbmVzY2FwZXMiLCJzaGltS2V5cyIsIml0ZXJhYmxlIiwiaW52ZXJ0IiwicmVFc2NhcGVkSHRtbCIsImpvaW4iLCJyZVVuZXNjYXBlZEh0bWwiLCJndWFyZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJvd25JbmRleCIsIm93blByb3BzIiwiY2xvbmUiLCJjbG9uZURlZXAiLCJmaW5kS2V5IiwiZmluZExhc3RLZXkiLCJmb3JPd25SaWdodCIsImZvckluUmlnaHQiLCJwYWlycyIsInByb3BzIiwiZnVuY3Rpb25zIiwic29ydCIsImhhcyIsImlzQm9vbGVhbiIsImlzRGF0ZSIsImlzRWxlbWVudCIsImlzRW1wdHkiLCJpc0VxdWFsIiwicGFyc2VGbG9hdCIsImlzTnVtYmVyIiwiaXNOdWxsIiwidmFsdWVPZiIsIm9ialByb3RvIiwiaXNSZWdFeHAiLCJpc1N0cmluZyIsImlzVW5kZWZpbmVkIiwibWFwVmFsdWVzIiwibWVyZ2UiLCJzb3VyY2VzIiwib21pdCIsInRyYW5zZm9ybSIsInByb3RvIiwiYXQiLCJjb250YWlucyIsInRhcmdldCIsImNvdW50QnkiLCJldmVyeSIsImZpbHRlciIsImZpbmQiLCJmaW5kTGFzdCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpbmRleEJ5IiwiaW52b2tlIiwibWV0aG9kTmFtZSIsImlzRnVuYyIsIm1hcCIsIkluZmluaXR5IiwiY3VycmVudCIsInBsdWNrIiwicmVkdWNlIiwibm9hY2N1bSIsInJlZHVjZVJpZ2h0IiwicmVqZWN0Iiwic2FtcGxlIiwibiIsInNodWZmbGUiLCJyYW5kIiwic29tZSIsInNvcnRCeSIsInRvQXJyYXkiLCJ3aGVyZSIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW4iLCJzb3J0ZWRJbmRleCIsImluaXRpYWwiLCJpbnRlcnNlY3Rpb24iLCJjYWNoZXMiLCJ0cnVzdEluZGV4T2YiLCJvdXRlciIsImxhc3RJbmRleE9mIiwicHVsbCIsInJhbmdlIiwic3RlcCIsInJlbW92ZSIsInJlc3QiLCJsb3ciLCJoaWdoIiwidW5pb24iLCJ1bmlxIiwid2l0aG91dCIsInhvciIsImNvbmNhdCIsInppcCIsInppcE9iamVjdCIsImFmdGVyIiwiYmluZEFsbCIsImZ1bmNzIiwiYmluZEtleSIsImNvbXBvc2UiLCJjdXJyeSIsImRlYm91bmNlIiwid2FpdCIsIm9wdGlvbnMiLCJtYXhUaW1lb3V0SWQiLCJzdGFtcCIsInRpbWVvdXRJZCIsInRyYWlsaW5nQ2FsbCIsImxhc3RDYWxsZWQiLCJtYXhXYWl0IiwidHJhaWxpbmciLCJsZWFkaW5nIiwiZGVsYXllZCIsInJlbWFpbmluZyIsIm5vdyIsImlzQ2FsbGVkIiwibWF4RGVsYXllZCIsImxlYWRpbmdDYWxsIiwiZGVmZXIiLCJkZWxheSIsIm1lbW9pemUiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwib25jZSIsInJhbiIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJ0aHJvdHRsZSIsIndyYXAiLCJ3cmFwcGVyIiwiY29uc3RhbnQiLCJwcm9wZXJ0eSIsImVzY2FwZSIsIm1peGluIiwiY2hhaW4iLCJtZXRob2ROYW1lcyIsIm5vQ29uZmxpY3QiLCJnZXRUaW1lIiwicmFkaXgiLCJmbG9hdGluZyIsIm5vTWluIiwibm9NYXgiLCJ0ZW1wbGF0ZSIsInRleHQiLCJkYXRhIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJvZmZzZXQiLCJ2YXJpYWJsZSIsImhhc1ZhcmlhYmxlIiwic291cmNlVVJMIiwidGltZXMiLCJ1bmVzY2FwZSIsInVuaXF1ZUlkIiwicHJlZml4IiwiaWQiLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJUb1N0cmluZyIsIndyYXBwZXJWYWx1ZU9mIiwiY29sbGVjdCIsImRyb3AiLCJlYWNoIiwiZWFjaFJpZ2h0IiwiZXh0ZW5kIiwibWV0aG9kcyIsInNlbGVjdCIsInRhaWwiLCJ1bmlxdWUiLCJ1bnppcCIsImFsbCIsImFueSIsImRldGVjdCIsImZpbmRXaGVyZSIsImZvbGRsIiwiZm9sZHIiLCJpbmNsdWRlIiwiaW5qZWN0IiwidGFrZSIsImhlYWQiLCJjYWxsYmFja2FibGUiLCJWRVJTSU9OIiwiZGVmaW5lIiwiYW1kIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7QUFTQTtBQUFFLGFBQVc7QUFFWDtBQUNBLE1BQUlBLFNBQUo7QUFFQTs7QUFDQSxNQUFJQyxTQUFTLEdBQUcsRUFBaEI7QUFBQSxNQUNJQyxVQUFVLEdBQUcsRUFEakI7QUFHQTs7QUFDQSxNQUFJQyxTQUFTLEdBQUcsQ0FBaEI7QUFFQTs7QUFDQSxNQUFJQyxTQUFTLEdBQUcsQ0FBQyxJQUFJQyxJQUFKLEVBQUQsR0FBWSxFQUE1QjtBQUVBOztBQUNBLE1BQUlDLGNBQWMsR0FBRyxFQUFyQjtBQUVBOztBQUNBLE1BQUlDLFdBQVcsR0FBRyxFQUFsQjtBQUVBOztBQUNBLE1BQUlDLFVBQVUsR0FDWjtBQUNBLDBCQUVBO0FBQ0Esb0JBSEEsR0FLQTtBQUNBLG9HQVJGO0FBV0E7O0FBQ0EsTUFBSUMsb0JBQW9CLEdBQUcsZ0JBQTNCO0FBQUEsTUFDSUMsbUJBQW1CLEdBQUcsb0JBRDFCO0FBQUEsTUFFSUMscUJBQXFCLEdBQUcsK0JBRjVCO0FBSUE7Ozs7O0FBSUEsTUFBSUMsWUFBWSxHQUFHLGlDQUFuQjtBQUVBOztB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bGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1vIC4vZGlzdC9sb2Rhc2guanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlIEVTNSBlbnZpcm9ubWVudHMgKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCB0byBwb29sIGFycmF5cyBhbmQgb2JqZWN0cyB1c2VkIGludGVybmFsbHkgKi9cbiAgdmFyIGFycmF5UG9vbCA9IFtdLFxuICAgICAgb2JqZWN0UG9vbCA9IFtdO1xuXG4gIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgKi9cbiAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgLyoqIFVzZWQgdG8gcHJlZml4IGtleXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggYF9fcHJvdG9fX2AgYW5kIHByb3BlcnRpZXMgb24gYE9iamVjdC5wcm90b3R5cGVgICovXG4gIHZhciBrZXlQcmVmaXggPSArbmV3IERhdGUgKyAnJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB3aGVuIG9wdGltaXphdGlvbnMgYXJlIGVuYWJsZWQgZm9yIGxhcmdlIGFycmF5cyAqL1xuICB2YXIgbGFyZ2VBcnJheVNpemUgPSA3NTtcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4IHNpemUgb2YgdGhlIGBhcnJheVBvb2xgIGFuZCBgb2JqZWN0UG9vbGAgKi9cbiAgdmFyIG1heFBvb2xTaXplID0gNDA7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGFuZCB0ZXN0IHdoaXRlc3BhY2UgKi9cbiAgdmFyIHdoaXRlc3BhY2UgPSAoXG4gICAgLy8gd2hpdGVzcGFjZVxuICAgICcgXFx0XFx4MEJcXGZcXHhBMFxcdWZlZmYnICtcblxuICAgIC8vIGxpbmUgdGVybWluYXRvcnNcbiAgICAnXFxuXFxyXFx1MjAyOFxcdTIwMjknICtcblxuICAgIC8vIHVuaWNvZGUgY2F0ZWdvcnkgXCJac1wiIHNwYWNlIHNlcGFyYXRvcnNcbiAgICAnXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCdcbiAgKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggRVM2IHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHJlZ2V4cCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcyAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0ZWQgbmFtZWQgZnVuY3Rpb25zICovXG4gIHZhciByZUZ1bmNOYW1lID0gL15cXHMqZnVuY3Rpb25bIFxcblxcclxcdF0rXFx3LztcblxuICAvKiogVXNlZCB0byBtYXRjaCBcImludGVycG9sYXRlXCIgdGVtcGxhdGUgZGVsaW1pdGVycyAqL1xuICB2YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZSBhbmQgemVyb3MgdG8gYmUgcmVtb3ZlZCAqL1xuICB2YXIgcmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MgPSBSZWdFeHAoJ15bJyArIHdoaXRlc3BhY2UgKyAnXSowKyg/PS4kKScpO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycyAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBmdW5jdGlvbnMgY29udGFpbmluZyBhIGB0aGlzYCByZWZlcmVuY2UgKi9cbiAgdmFyIHJlVGhpcyA9IC9cXGJ0aGlzXFxiLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx0XFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcyAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRnVuY3Rpb24nLCAnTWF0aCcsICdOdW1iZXInLCAnT2JqZWN0JyxcbiAgICAnUmVnRXhwJywgJ1N0cmluZycsICdfJywgJ2F0dGFjaEV2ZW50JywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdpc05hTicsXG4gICAgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeSAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gMDtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGZ1bmNDbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBudW1iZXJDbGFzcyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IG9iamVjdCBjbGFzc2lmaWNhdGlvbnMgdGhhdCBgXy5jbG9uZWAgc3VwcG9ydHMgKi9cbiAgdmFyIGNsb25lYWJsZUNsYXNzZXMgPSB7fTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1tmdW5jQ2xhc3NdID0gZmFsc2U7XG4gIGNsb25lYWJsZUNsYXNzZXNbYXJnc0NsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbYXJyYXlDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW2Jvb2xDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2RhdGVDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW251bWJlckNsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbb2JqZWN0Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tyZWdleHBDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW3N0cmluZ0NsYXNzXSA9IHRydWU7XG5cbiAgLyoqIFVzZWQgYXMgYW4gaW50ZXJuYWwgYF8uZGVib3VuY2VgIG9wdGlvbnMgb2JqZWN0ICovXG4gIHZhciBkZWJvdW5jZU9wdGlvbnMgPSB7XG4gICAgJ2xlYWRpbmcnOiBmYWxzZSxcbiAgICAnbWF4V2FpdCc6IDAsXG4gICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCBhcyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYF9fYmluZERhdGFfX2AgKi9cbiAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogbnVsbCxcbiAgICAnd3JpdGFibGUnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIE9iamVjdCAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlLFxuICAgICdudW1iZXInOiBmYWxzZSxcbiAgICAnc3RyaW5nJzogZmFsc2UsXG4gICAgJ3VuZGVmaW5lZCc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMgKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx0JzogJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAqL1xuICB2YXIgcm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpIHx8IHRoaXM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYCAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAgKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlc1xuICAgKiBvciBgZnJvbUluZGV4YCBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbnRhaW5zYCBmb3IgY2FjaGUgb2JqZWN0cyB0aGF0IG1pbWljcyB0aGUgcmV0dXJuXG4gICAqIHNpZ25hdHVyZSBvZiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgY2FjaGUgPSBjYWNoZS5jYWNoZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVbdmFsdWVdID8gMCA6IC0xO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgfVxuICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZTtcbiAgICBjYWNoZSA9IChjYWNoZSA9IGNhY2hlW3R5cGVdKSAmJiBjYWNoZVtrZXldO1xuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCdcbiAgICAgID8gKGNhY2hlICYmIGJhc2VJbmRleE9mKGNhY2hlLCB2YWx1ZSkgPiAtMSA/IDAgOiAtMSlcbiAgICAgIDogKGNhY2hlID8gMCA6IC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZ2l2ZW4gdmFsdWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBjYWNoZVt2YWx1ZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPSAnbnVtYmVyJyAmJiB0eXBlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0eXBlID09ICdudW1iZXInID8gdmFsdWUgOiBrZXlQcmVmaXggKyB2YWx1ZSxcbiAgICAgICAgICB0eXBlQ2FjaGUgPSBjYWNoZVt0eXBlXSB8fCAoY2FjaGVbdHlwZV0gPSB7fSk7XG5cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgICh0eXBlQ2FjaGVba2V5XSB8fCAodHlwZUNhY2hlW2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZUNhY2hlW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgd2hlbiBhIGdpdmVuXG4gICAqIGNvbGxlY3Rpb24gaXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgY2hhcmFjdGVyIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiBnaXZlbiBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyQXRDYWxsYmFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBgY29sbGVjdGlvbmAgZWxlbWVudHMsIHN0YWJsZSBzb3J0aW5nXG4gICAqIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYGFgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBvZiBgMWAgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcoYSwgYikge1xuICAgIHZhciBhYyA9IGEuY3JpdGVyaWEsXG4gICAgICAgIGJjID0gYi5jcml0ZXJpYSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYWMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFjW2luZGV4XSxcbiAgICAgICAgICBvdGhlciA9IGJjW2luZGV4XTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICBpZiAodmFsdWUgPiBvdGhlciB8fCB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBvdGhlciB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAvLyBgYWAgYW5kIGBiYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwXG4gICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCBvciBgbnVsbGAgaWYgY2FjaGluZyBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWNoZShhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gYXJyYXlbMF0sXG4gICAgICAgIG1pZCA9IGFycmF5WyhsZW5ndGggLyAyKSB8IDBdLFxuICAgICAgICBsYXN0ID0gYXJyYXlbbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0ID09ICdvYmplY3QnICYmXG4gICAgICAgIG1pZCAmJiB0eXBlb2YgbWlkID09ICdvYmplY3QnICYmIGxhc3QgJiYgdHlwZW9mIGxhc3QgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gZ2V0T2JqZWN0KCk7XG4gICAgY2FjaGVbJ2ZhbHNlJ10gPSBjYWNoZVsnbnVsbCddID0gY2FjaGVbJ3RydWUnXSA9IGNhY2hlWyd1bmRlZmluZWQnXSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldE9iamVjdCgpO1xuICAgIHJlc3VsdC5hcnJheSA9IGFycmF5O1xuICAgIHJlc3VsdC5jYWNoZSA9IGNhY2hlO1xuICAgIHJlc3VsdC5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgZnJvbSB0aGUgYXJyYXkgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFycmF5KCkge1xuICAgIHJldHVybiBhcnJheVBvb2wucG9wKCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gb2JqZWN0UG9vbC5wb3AoKSB8fCB7XG4gICAgICAnYXJyYXknOiBudWxsLFxuICAgICAgJ2NhY2hlJzogbnVsbCxcbiAgICAgICdjcml0ZXJpYSc6IG51bGwsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICdpbmRleCc6IDAsXG4gICAgICAnbnVsbCc6IGZhbHNlLFxuICAgICAgJ251bWJlcic6IG51bGwsXG4gICAgICAnb2JqZWN0JzogbnVsbCxcbiAgICAgICdwdXNoJzogbnVsbCxcbiAgICAgICdzdHJpbmcnOiBudWxsLFxuICAgICAgJ3RydWUnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBhcnJheSBiYWNrIHRvIHRoZSBhcnJheSBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZUFycmF5KGFycmF5KSB7XG4gICAgYXJyYXkubGVuZ3RoID0gMDtcbiAgICBpZiAoYXJyYXlQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBhcnJheVBvb2wucHVzaChhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBvYmplY3QgYmFjayB0byB0aGUgb2JqZWN0IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBjYWNoZSA9IG9iamVjdC5jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgIH1cbiAgICBvYmplY3QuYXJyYXkgPSBvYmplY3QuY2FjaGUgPSBvYmplY3QuY3JpdGVyaWEgPSBvYmplY3Qub2JqZWN0ID0gb2JqZWN0Lm51bWJlciA9IG9iamVjdC5zdHJpbmcgPSBvYmplY3QudmFsdWUgPSBudWxsO1xuICAgIGlmIChvYmplY3RQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBvYmplY3RQb29sLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpY2VzIHRoZSBgY29sbGVjdGlvbmAgZnJvbSB0aGUgYHN0YXJ0YCBpbmRleCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG4gICAqIHRoZSBgZW5kYCBpbmRleC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGUgbGlzdHNcbiAgICogaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQgfHwgMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGNvbnRleHQgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNS5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIEJvb2xlYW4gPSBjb250ZXh0LkJvb2xlYW4sXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgYEFycmF5YCBtZXRob2QgcmVmZXJlbmNlcy5cbiAgICAgKlxuICAgICAqIE5vcm1hbGx5IGBBcnJheS5wcm90b3R5cGVgIHdvdWxkIHN1ZmZpY2UsIGhvd2V2ZXIsIHVzaW5nIGFuIGFycmF5IGxpdGVyYWxcbiAgICAgKiBhdm9pZHMgaXNzdWVzIGluIE5hcndoYWwuXG4gICAgICovXG4gICAgdmFyIGFycmF5UmVmID0gW107XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gICAgdmFyIG9sZERhc2ggPSBjb250ZXh0Ll87XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBbW0NsYXNzXV0gb2YgdmFsdWVzICovXG4gICAgdmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBnZXRQcm90b3R5cGVPZiA9IGlzTmF0aXZlKGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKSAmJiBnZXRQcm90b3R5cGVPZixcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgcHVzaCA9IGFycmF5UmVmLnB1c2gsXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UmVmLnNwbGljZSxcbiAgICAgICAgdW5zaGlmdCA9IGFycmF5UmVmLnVuc2hpZnQ7XG5cbiAgICAvKiogVXNlZCB0byBzZXQgbWV0YSBkYXRhIG9uIGZ1bmN0aW9ucyAqL1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG8gPSB7fSxcbiAgICAgICAgICAgIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBmdW5jLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhvLCBvLCBvKSAmJiBmdW5jO1xuICAgICAgfSBjYXRjaChlKSB7IH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpKTtcblxuICAgIC8qIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzIGZvciBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzICovXG4gICAgdmFyIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgICAgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUlzTmFOID0gY29udGV4dC5pc05hTixcbiAgICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIGEgYnVpbHQtaW4gY29uc3RydWN0b3IgYnkgW1tDbGFzc11dICovXG4gICAgdmFyIGN0b3JCeUNsYXNzID0ge307XG4gICAgY3RvckJ5Q2xhc3NbYXJyYXlDbGFzc10gPSBBcnJheTtcbiAgICBjdG9yQnlDbGFzc1tib29sQ2xhc3NdID0gQm9vbGVhbjtcbiAgICBjdG9yQnlDbGFzc1tkYXRlQ2xhc3NdID0gRGF0ZTtcbiAgICBjdG9yQnlDbGFzc1tmdW5jQ2xhc3NdID0gRnVuY3Rpb247XG4gICAgY3RvckJ5Q2xhc3Nbb2JqZWN0Q2xhc3NdID0gT2JqZWN0O1xuICAgIGN0b3JCeUNsYXNzW251bWJlckNsYXNzXSA9IE51bWJlcjtcbiAgICBjdG9yQnlDbGFzc1tyZWdleHBDbGFzc10gPSBSZWdFeHA7XG4gICAgY3RvckJ5Q2xhc3Nbc3RyaW5nQ2xhc3NdID0gU3RyaW5nO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB0byBlbmFibGUgaW50dWl0aXZlXG4gICAgICogbWV0aG9kIGNoYWluaW5nLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gTG8tRGFzaCBtZXRob2RzLCB3cmFwcGVycyBhbHNvIGhhdmUgdGhlIGZvbGxvd2luZyBgQXJyYXlgIG1ldGhvZHM6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHJldmVyc2VgLCBgc2hpZnRgLCBgc2xpY2VgLCBgc29ydGAsIGBzcGxpY2VgLFxuICAgICAqIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGB2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhc3NpZ25gLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2hhaW5gLCBgY29tcGFjdGAsXG4gICAgICogYGNvbXBvc2VgLCBgY29uY2F0YCwgYGNvdW50QnlgLCBgY3JlYXRlYCwgYGNyZWF0ZUNhbGxiYWNrYCwgYGN1cnJ5YCxcbiAgICAgKiBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmZXJgLCBgZGVsYXlgLCBgZGlmZmVyZW5jZWAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsXG4gICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcbiAgICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBtYXBgLCBgbWF4YCwgYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWluYCwgYG9iamVjdGAsIGBvbWl0YCxcbiAgICAgKiBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwaWNrYCwgYHBsdWNrYCwgYHB1bGxgLCBgcHVzaGAsXG4gICAgICogYHJhbmdlYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAgICogYHNvcnRCeWAsIGBzcGxpY2VgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdHJhbnNmb3JtYCxcbiAgICAgKiBgdW5pb25gLCBgdW5pcWAsIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHZhbHVlc2AsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLFxuICAgICAqIGFuZCBgemlwYFxuICAgICAqXG4gICAgICogVGhlIG5vbi1jaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgICAqIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgY29udGFpbnNgLCBgZXNjYXBlYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCxcbiAgICAgKiBgZmluZEtleWAsIGBmaW5kTGFzdGAsIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGhhc2AsIGBpZGVudGl0eWAsXG4gICAgICogYGluZGV4T2ZgLCBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsXG4gICAgICogYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsXG4gICAgICogYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgam9pbmAsXG4gICAgICogYGxhc3RJbmRleE9mYCwgYG1peGluYCwgYG5vQ29uZmxpY3RgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLFxuICAgICAqIGByZWR1Y2VSaWdodGAsIGByZXN1bHRgLCBgc2hpZnRgLCBgc2l6ZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHJ1bkluQ29udGV4dGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYW5kIGB2YWx1ZWBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyBgZmlyc3RgIGFuZCBgbGFzdGAgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gYG5gIGlzXG4gICAgICogcHJvdmlkZWQsIG90aGVyd2lzZSB0aGV5IHJldHVybiB1bndyYXBwZWQgdmFsdWVzLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW5pbmcgY2FuIGJlIGVuYWJsZWQgYnkgdXNpbmcgdGhlIGBfLmNoYWluYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gKiBudW07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIC8vIGRvbid0IHdyYXAgaWYgYWxyZWFkeSB3cmFwcGVkLCBldmVuIGlmIHdyYXBwZWQgYnkgYSBkaWZmZXJlbnQgYGxvZGFzaGAgY29uc3RydWN0b3JcbiAgICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmICFpc0FycmF5KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSlcbiAgICAgICA/IHZhbHVlXG4gICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmYXN0IHBhdGggZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hhaW5BbGwgQSBmbGFnIHRvIGVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIG1ldGhvZHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIGBuZXcgbG9kYXNoV3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGxvZGFzaGBcbiAgICBsb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGxvZGFzaC5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdXNlZCB0byBmbGFnIGVudmlyb25tZW50cyBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBmdW5jdGlvbnMgY2FuIGJlIGRlY29tcGlsZWQgYnkgYEZ1bmN0aW9uI3RvU3RyaW5nYFxuICAgICAqIChhbGwgYnV0IFBTMyBhbmQgb2xkZXIgT3BlcmEgbW9iaWxlIGJyb3dzZXJzICYgYXZvaWRlZCBpbiBXaW5kb3dzIDggYXBwcykuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY0RlY29tcCA9ICFpc05hdGl2ZShjb250ZXh0LldpblJURXJyb3IpICYmIHJlVGhpcy50ZXN0KHJ1bkluQ29udGV4dCk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IExvLURhc2ggYXJlIHNpbWlsYXIgdG8gdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpLiBDaGFuZ2UgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmVcbiAgICAgKiBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogLzwlKFtcXHNcXFNdKz8pJT4vZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmJpbmRgIHRoYXQgY3JlYXRlcyB0aGUgYm91bmQgZnVuY3Rpb24gYW5kXG4gICAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VCaW5kKGJpbmREYXRhKSB7XG4gICAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdO1xuXG4gICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgLy8gYEZ1bmN0aW9uI2JpbmRgIHNwZWNcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNVxuICAgICAgICBpZiAocGFydGlhbEFyZ3MpIHtcbiAgICAgICAgICAvLyBhdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgZGVvcHRpbWl6YXRpb25zIGJ5IHVzaW5nIGBzbGljZWAgaW5zdGVhZFxuICAgICAgICAgIC8vIG9mIGBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGAgYW5kIG5vdCBhc3NpZ25pbmcgYGFyZ3VtZW50c2AgdG8gYVxuICAgICAgICAgIC8vIHZhcmlhYmxlIGFzIGEgdGVybmFyeSBleHByZXNzaW9uXG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgYG5ldyBib3VuZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYGZ1bmNgXG4gICAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSksXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MgfHwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwPWZhbHNlXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpbnNwZWN0IFtbQ2xhc3NdXVxuICAgICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKCFjbG9uZWFibGVDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSBjdG9yQnlDbGFzc1tjbGFzc05hbWVdO1xuICAgICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKCt2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IodmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgICAgIHJlc3VsdCA9IGN0b3IodmFsdWUuc291cmNlLCByZUZsYWdzLmV4ZWModmFsdWUpKTtcbiAgICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSB2YWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lXG4gICAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBpc0FyciA/IGN0b3IodmFsdWUubGVuZ3RoKSA6IHt9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gc2xpY2UodmFsdWUpIDogYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbmRleCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGV4ID0gdmFsdWUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdpbnB1dCcpKSB7XG4gICAgICAgICAgcmVzdWx0LmlucHV0ID0gdmFsdWUuaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZm9yIHNoYWxsb3cgY2xvbmVcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBhZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIC8vIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmVcbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKHZhbHVlLCBmdW5jdGlvbihvYmpWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKG9ialZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBpc09iamVjdChwcm90b3R5cGUpID8gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSkgOiB7fTtcbiAgICB9XG4gICAgLy8gZmFsbGJhY2sgZm9yIGJyb3dzZXJzIHdpdGhvdXQgYE9iamVjdC5jcmVhdGVgXG4gICAgaWYgKCFuYXRpdmVDcmVhdGUpIHtcbiAgICAgIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9iamVjdCgpIHt9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgY29udGV4dC5PYmplY3QoKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlQ2FsbGJhY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY3JlYXRpbmdcbiAgICAgKiBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3Igbm8gYHRoaXNBcmdgIG9yIGFscmVhZHkgYm91bmQgYnkgYEZ1bmN0aW9uI2JpbmRgXG4gICAgICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgfHwgISgncHJvdG90eXBlJyBpbiBmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKHR5cGVvZiBiaW5kRGF0YSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICBiaW5kRGF0YSA9ICFmdW5jLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYmluZERhdGEgPSBiaW5kRGF0YSB8fCAhc3VwcG9ydC5mdW5jRGVjb21wO1xuICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGZuVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgICBiaW5kRGF0YSA9ICFyZUZ1bmNOYW1lLnRlc3Qoc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGlmIGBmdW5jYCByZWZlcmVuY2VzIHRoZSBgdGhpc2Aga2V5d29yZCBhbmQgc3RvcmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGJpbmREYXRhID0gcmVUaGlzLnRlc3Qoc291cmNlKTtcbiAgICAgICAgICAgIHNldEJpbmREYXRhKGZ1bmMsIGJpbmREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlcmUgYXJlIG5vIGB0aGlzYCByZWZlcmVuY2VzIG9yIGBmdW5jYCBpcyBib3VuZFxuICAgICAgaWYgKGJpbmREYXRhID09PSBmYWxzZSB8fCAoYmluZERhdGEgIT09IHRydWUgJiYgYmluZERhdGFbMV0gJiAxKSkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYSwgYik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZChmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY3JlYXRlV3JhcHBlcmAgdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGVyIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlV3JhcHBlcihiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBiaXRtYXNrID0gYmluZERhdGFbMV0sXG4gICAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgICBwYXJ0aWFsUmlnaHRBcmdzID0gYmluZERhdGFbM10sXG4gICAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdLFxuICAgICAgICAgIGFyaXR5ID0gYmluZERhdGFbNV07XG5cbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAga2V5ID0gZnVuYztcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzO1xuICAgICAgICBpZiAocGFydGlhbEFyZ3MpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MgfHwgaXNDdXJyeSkge1xuICAgICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncykge1xuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ3VycnkgJiYgYXJncy5sZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgICAgYml0bWFzayB8PSAxNiAmIH4zMjtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ3JlYXRlV3JhcHBlcihbZnVuYywgKGlzQ3VycnlCb3VuZCA/IGJpdG1hc2sgOiBiaXRtYXNrICYgfjMpLCBhcmdzLCBudWxsLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzIHx8IChhcmdzID0gYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGlzQmluZEtleSkge1xuICAgICAgICAgIGZ1bmMgPSB0aGlzQmluZGluZ1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgdGhhdCBhY2NlcHRzIGEgc2luZ2xlIGFycmF5XG4gICAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIGlzTGFyZ2UgPSBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHZhbHVlcyk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgICAgdmFsdWVzID0gY2FjaGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleE9mKHZhbHVlcywgdmFsdWUpIDwgMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZU9iamVjdCh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdD1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzIGFuZCBgYXJndW1lbnRzYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzdGFydCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgaXNTdHJpY3QsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInXG4gICAgICAgICAgICAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlRmxhdHRlbih2YWx1ZSwgaXNTaGFsbG93LCBpc1N0cmljdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWxJbmRleCA9IC0xLFxuICAgICAgICAgICAgICB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgIHJlc0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgIHJlc3VsdC5sZW5ndGggKz0gdmFsTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK3ZhbEluZGV4IDwgdmFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZVt2YWxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCwgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc0FyZ2AgYmluZGluZyxcbiAgICAgKiB0aGF0IGFsbG93cyBwYXJ0aWFsIFwiXy53aGVyZVwiIHN0eWxlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpc1doZXJlPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGFgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgLy8gdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gY29tcGFyaW5nIG9iamVjdHMsIGBhYCBoYXMgYXQgbGVhc3QgdGhlIHByb3BlcnRpZXMgb2YgYGJgXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGEsIGIpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgaWRlbnRpY2FsIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgLy8gdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgcmV0dXJuIGEgIT09IDAgfHwgKDEgLyBhID09IDEgLyBiKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGEsXG4gICAgICAgICAgb3RoZXJUeXBlID0gdHlwZW9mIGI7XG5cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIHVubGlrZSBwcmltaXRpdmUgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYSAmJlxuICAgICAgICAgICEoYSAmJiBvYmplY3RUeXBlc1t0eXBlXSkgJiZcbiAgICAgICAgICAhKGIgJiYgb2JqZWN0VHlwZXNbb3RoZXJUeXBlXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhdm9pZGluZyBFUzMncyBGdW5jdGlvbiNjYWxsIGJlaGF2aW9yXG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC40XG4gICAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH1cbiAgICAgIC8vIGNvbXBhcmUgW1tDbGFzc11dIG5hbWVzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKSxcbiAgICAgICAgICBvdGhlckNsYXNzID0gdG9TdHJpbmcuY2FsbChiKTtcblxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAob3RoZXJDbGFzcyA9PSBhcmdzQ2xhc3MpIHtcbiAgICAgICAgb3RoZXJDbGFzcyA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvdGhlckNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcbiAgICAgICAgICAvLyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICAvLyB0cmVhdCBgTmFOYCB2cy4gYE5hTmAgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gKGEgIT0gK2EpXG4gICAgICAgICAgICA/IGIgIT0gK2JcbiAgICAgICAgICAgIC8vIGJ1dCB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICAgICAgOiAoYSA9PSAwID8gKDEgLyBhID09IDEgLyBiKSA6IGEgPT0gK2IpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgIGNhc2Ugc3RyaW5nQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMC42LjQpXG4gICAgICAgICAgLy8gdHJlYXQgc3RyaW5nIHByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluc3RhbmNlcyBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzO1xuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAvLyB1bndyYXAgYW55IGBsb2Rhc2hgIHdyYXBwZWQgdmFsdWVzXG4gICAgICAgIHZhciBhV3JhcHBlZCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBiV3JhcHBlZCA9IGhhc093blByb3BlcnR5LmNhbGwoYiwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKGFXcmFwcGVkIHx8IGJXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGFXcmFwcGVkID8gYS5fX3dyYXBwZWRfXyA6IGEsIGJXcmFwcGVkID8gYi5fX3dyYXBwZWRfXyA6IGIsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhpdCBmb3IgZnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvYmplY3RDbGFzcykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBPcGVyYSwgYGFyZ3VtZW50c2Agb2JqZWN0cyBoYXZlIGBBcnJheWAgY29uc3RydWN0b3JzXG4gICAgICAgIHZhciBjdG9yQSA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjdG9yQiA9IGIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gbm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWxcbiAgICAgICAgaWYgKGN0b3JBICE9IGN0b3JCICYmXG4gICAgICAgICAgICAgICEoaXNGdW5jdGlvbihjdG9yQSkgJiYgY3RvckEgaW5zdGFuY2VvZiBjdG9yQSAmJiBpc0Z1bmN0aW9uKGN0b3JCKSAmJiBjdG9yQiBpbnN0YW5jZW9mIGN0b3JCKSAmJlxuICAgICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgICAgLy8gdGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpYyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjFcbiAgICAgIC8vIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTIuMylcbiAgICAgIHZhciBpbml0ZWRTdGFjayA9ICFzdGFja0E7XG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IGEpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgLy8gYWRkIGBhYCBhbmQgYGJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgc3RhY2tBLnB1c2goYSk7XG4gICAgICBzdGFja0IucHVzaChiKTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIC8vIGNvbXBhcmUgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5XG4gICAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgICBzaXplID0gYi5sZW5ndGg7XG4gICAgICAgIHJlc3VsdCA9IHNpemUgPT0gbGVuZ3RoO1xuXG4gICAgICAgIGlmIChyZXN1bHQgfHwgaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGRlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXNcbiAgICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiW3NpemVdO1xuXG4gICAgICAgICAgICBpZiAoaXNXaGVyZSkge1xuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtpbmRleF0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtzaXplXSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRlZXAgY29tcGFyZSBvYmplY3RzIHVzaW5nIGBmb3JJbmAsIGluc3RlYWQgb2YgYGZvck93bmAsIHRvIGF2b2lkIGBPYmplY3Qua2V5c2BcbiAgICAgICAgLy8gd2hpY2gsIGluIHRoaXMgY2FzZSwgaXMgbW9yZSBjb3N0bHlcbiAgICAgICAgZm9ySW4oYiwgZnVuY3Rpb24odmFsdWUsIGtleSwgYikge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgIC8vIGRlZXAgY29tcGFyZSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgYmFzZUlzRXF1YWwoYVtrZXldLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmICFpc1doZXJlKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGJvdGggb2JqZWN0cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzXG4gICAgICAgICAgZm9ySW4oYSwgZnVuY3Rpb24odmFsdWUsIGtleSwgYSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgICAgICAgICAvLyBgc2l6ZWAgd2lsbCBiZSBgLTFgIGlmIGBhYCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gYGJgXG4gICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gLS1zaXplID4gLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja0EucG9wKCk7XG4gICAgICBzdGFja0IucG9wKCk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIChpc0FycmF5KHNvdXJjZSkgPyBmb3JFYWNoIDogZm9yT3duKShzb3VyY2UsIGZ1bmN0aW9uKHNvdXJjZSwga2V5KSB7XG4gICAgICAgIHZhciBmb3VuZCxcbiAgICAgICAgICAgIGlzQXJyLFxuICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoc291cmNlICYmICgoaXNBcnIgPSBpc0FycmF5KHNvdXJjZSkpIHx8IGlzUGxhaW5PYmplY3Qoc291cmNlKSkpIHtcbiAgICAgICAgICAvLyBhdm9pZCBtZXJnaW5nIHByZXZpb3VzbHkgbWVyZ2VkIGN5Y2xpYyBzb3VyY2VzXG4gICAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RhY2tMZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKChmb3VuZCA9IHN0YWNrQVtzdGFja0xlbmd0aF0gPT0gc291cmNlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0YWNrQltzdGFja0xlbmd0aF07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgaXNTaGFsbG93O1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICAgICAgICBpZiAoKGlzU2hhbGxvdyA9IHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gaXNBcnJcbiAgICAgICAgICAgICAgICA/IChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pXG4gICAgICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCBgc291cmNlYCBhbmQgYXNzb2NpYXRlZCBgdmFsdWVgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgICAgICAgc3RhY2tBLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHN0YWNrQi5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICAgIGJhc2VNZXJnZSh2YWx1ZSwgc291cmNlLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBtaW4gKyBmbG9vcihuYXRpdmVSYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkPWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBgYXJyYXlgIGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdmFyIGlzTGFyZ2UgPSAhaXNTb3J0ZWQgJiYgbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSAoY2FsbGJhY2sgfHwgaXNMYXJnZSkgPyBnZXRBcnJheSgpIDogcmVzdWx0O1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZShzZWVuKTtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgc2VlbiA9IGNhY2hlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzU29ydGVkXG4gICAgICAgICAgICAgID8gIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gY29tcHV0ZWRcbiAgICAgICAgICAgICAgOiBpbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuLmFycmF5KTtcbiAgICAgICAgcmVsZWFzZU9iamVjdChzZWVuKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggYSBjYWxsYmFjay4gVGhlIGdpdmVuIGBzZXR0ZXJgIGZ1bmN0aW9uIHNldHMgdGhlIGtleXMgYW5kIHZhbHVlc1xuICAgICAqIG9mIHRoZSBjb21wb3NlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgc2V0dGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2BcbiAgICAgKiB3aXRoIGFuIG9wdGlvbmFsIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgbWV0aG9kIGZsYWdzIHRvIGNvbXBvc2UuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAxIC0gYF8uYmluZGBcbiAgICAgKiAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogIDQgLSBgXy5jdXJyeWBcbiAgICAgKiAgOCAtIGBfLmN1cnJ5YCAoYm91bmQpXG4gICAgICogIDE2IC0gYF8ucGFydGlhbGBcbiAgICAgKiAgMzIgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsUmlnaHRBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGlzUGFydGlhbCA9IGJpdG1hc2sgJiAxNixcbiAgICAgICAgICBpc1BhcnRpYWxSaWdodCA9IGJpdG1hc2sgJiAzMjtcblxuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwgJiYgIXBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4xNjtcbiAgICAgICAgaXNQYXJ0aWFsID0gcGFydGlhbEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWxSaWdodCAmJiAhcGFydGlhbFJpZ2h0QXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MzI7XG4gICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0QXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYyAmJiBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmIChiaW5kRGF0YSAmJiBiaW5kRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICAvLyBjbG9uZSBgYmluZERhdGFgXG4gICAgICAgIGJpbmREYXRhID0gc2xpY2UoYmluZERhdGEpO1xuICAgICAgICBpZiAoYmluZERhdGFbMl0pIHtcbiAgICAgICAgICBiaW5kRGF0YVsyXSA9IHNsaWNlKGJpbmREYXRhWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZERhdGFbM10pIHtcbiAgICAgICAgICBiaW5kRGF0YVszXSA9IHNsaWNlKGJpbmREYXRhWzNdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYHRoaXNCaW5kaW5nYCBpcyBub3QgcHJldmlvdXNseSBib3VuZFxuICAgICAgICBpZiAoaXNCaW5kICYmICEoYmluZERhdGFbMV0gJiAxKSkge1xuICAgICAgICAgIGJpbmREYXRhWzRdID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgaWYgcHJldmlvdXNseSBib3VuZCBidXQgbm90IGN1cnJlbnRseSAoc3Vic2VxdWVudCBjdXJyaWVkIGZ1bmN0aW9ucylcbiAgICAgICAgaWYgKCFpc0JpbmQgJiYgYmluZERhdGFbMV0gJiAxKSB7XG4gICAgICAgICAgYml0bWFzayB8PSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBjdXJyaWVkIGFyaXR5IGlmIG5vdCB5ZXQgc2V0XG4gICAgICAgIGlmIChpc0N1cnJ5ICYmICEoYmluZERhdGFbMV0gJiA0KSkge1xuICAgICAgICAgIGJpbmREYXRhWzVdID0gYXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgbGVmdCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgICAgIHB1c2guYXBwbHkoYmluZERhdGFbMl0gfHwgKGJpbmREYXRhWzJdID0gW10pLCBwYXJ0aWFsQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWxSaWdodCkge1xuICAgICAgICAgIHVuc2hpZnQuYXBwbHkoYmluZERhdGFbM10gfHwgKGJpbmREYXRhWzNdID0gW10pLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBmbGFnc1xuICAgICAgICBiaW5kRGF0YVsxXSB8PSBiaXRtYXNrO1xuICAgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlci5hcHBseShudWxsLCBiaW5kRGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBmYXN0IHBhdGggZm9yIGBfLmJpbmRgXG4gICAgICB2YXIgY3JlYXRlciA9IChiaXRtYXNrID09IDEgfHwgYml0bWFzayA9PT0gMTcpID8gYmFzZUJpbmQgOiBiYXNlQ3JlYXRlV3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVyKFtmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBlc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgICAgcmV0dXJuIGh0bWxFc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhPZigpIHtcbiAgICAgIHZhciByZXN1bHQgPSAocmVzdWx0ID0gbG9kYXNoLmluZGV4T2YpID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHJlTmF0aXZlLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYHRoaXNgIGJpbmRpbmcgZGF0YSBvbiBhIGdpdmVuIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzZXQgZGF0YSBvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBUaGUgZGF0YSBhcnJheSB0byBzZXQuXG4gICAgICovXG4gICAgdmFyIHNldEJpbmREYXRhID0gIWRlZmluZVByb3BlcnR5ID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMsIHZhbHVlKSB7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShmdW5jLCAnX19iaW5kRGF0YV9fJywgZGVzY3JpcHRvcik7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWVcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IsIGFzc3VtaW5nIG9iamVjdHMgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gYE9iamVjdC5wcm90b3R5cGVgIGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBjdG9yLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgLy8gYXZvaWQgbm9uIE9iamVjdCBvYmplY3RzLCBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgRE9NIGVsZW1lbnRzXG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykgfHxcbiAgICAgICAgICAoY3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCBpc0Z1bmN0aW9uKGN0b3IpICYmICEoY3RvciBpbnN0YW5jZW9mIGN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB1bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggcHJvZHVjZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBzaGltS2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCEob2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdF0pKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsnb25lJywgJ3R3bycsICd0aHJlZSddIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXM6XG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIGA+YCBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZSBgPmAgYW5kIGAvYFxuICAgICAqIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmcgdW5sZXNzIHRoZXkncmUgcGFydFxuICAgICAqIG9mIGEgdGFnIG9yIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcyAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIilcbiAgICAgKi9cbiAgICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjMzk7J1xuICAgIH07XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycyAqL1xuICAgIHZhciBodG1sVW5lc2NhcGVzID0gaW52ZXJ0KGh0bWxFc2NhcGVzKTtcblxuICAgIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycyAqL1xuICAgIHZhciByZUVzY2FwZWRIdG1sID0gUmVnRXhwKCcoJyArIGtleXMoaHRtbFVuZXNjYXBlcykuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgICAgICByZVVuZXNjYXBlZEh0bWwgPSBSZWdFeHAoJ1snICsga2V5cyhodG1sRXNjYXBlcykuam9pbignJykgKyAnXScsICdnJyk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAgICogc291cmNlcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlXG4gICAgICogYXNzaWduZWQgdmFsdWVzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICduYW1lJzogJ2ZyZWQnIH0sIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIGEgPT0gJ3VuZGVmaW5lZCcgPyBiIDogYTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBkZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGFsc29cbiAgICAgKiBiZSBjbG9uZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShjaGFyYWN0ZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZShjaGFyYWN0ZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLm1peGluKHtcbiAgICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqICAgfSlcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSk7XG4gICAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YFxuICAgICAgLy8gYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHMgZm9yIGBpc0RlZXBgIGFuZCBgY2FsbGJhY2tgXG4gICAgICBpZiAodHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNEZWVwICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZVxuICAgICAqIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobS4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBjbG9uZWQuIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmRcbiAgICAgKiBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKGNoYXJhY3RlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ25vZGUnOiBlbGVtZW50XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmVEZWVwKHZpZXcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY2xvbmUubm9kZSA9PSB2aWV3Lm5vZGU7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHsgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBhc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIGRlZmF1bHRzIG9mIHRoZSBzYW1lIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIHdpdGhvdXQgdXNpbmcgaXRzXG4gICAgICogIGBrZXlgIGFuZCBgb2JqZWN0YCBhcmd1bWVudHMgYXMgc291cmNlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBfLmRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AsIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93blJpZ2h0KG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICAgKiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdtb3ZlJywgJ3knLCBhbmQgJ3gnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG5cbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBwYWlycy5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHBhaXJzW2xlbmd0aC0tXSwgcGFpcnNbbGVuZ3RoXSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd24oeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xlbmd0aCcsICcxJywgYW5kICcwJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCxcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAgICogXCJlbXB0eVwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgKSB8fFxuICAgICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogdG8gY29tcGFyZSB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKGEsIGIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGNvcHkgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gY29weTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgY29weSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHdvcmRzID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbCh3b3Jkcywgb3RoZXJXb3JkcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICAgKiAgICAgICBiR3JlZXQgPSBfLmlzU3RyaW5nKGIpICYmIHJlR3JlZXQudGVzdChiKTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGEsIGIsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICAgKiBib29sZWFucyBhbmQgZW1wdHkgc3RyaW5ncy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBmaW5pdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgtMTAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlSXNGaW5pdGUodmFsdWUpICYmICFuYXRpdmVJc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gIHdoaWNoIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gYE5hTmAgYXMgYSBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmXG4gICAgICAvLyAocGVyZm9ybSB0aGUgW1tDbGFzc11dIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFKVxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IGBOYU5gIGlzIGNvbnNpZGVyZWQgYSBudW1iZXIuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDguNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40ICogNSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTaGFwZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvZnJlZC8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHZhbHVlcyBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG5hbWVzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ25hbWUnOiAnYmFybmV5JyB9LFxuICAgICAqICAgICB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnYWdlJzogMzYgfSxcbiAgICAgKiAgICAgeyAnYWdlJzogNDAgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG5hbWVzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdjaGFyYWN0ZXJzJzogW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRocm91Z2ggYSBjYWxsYmFjaywgd2l0aCBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3F1YXJlcyA9IF8udHJhbnNmb3JtKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtKSB7XG4gICAgICogICBudW0gKj0gbnVtO1xuICAgICAqICAgaWYgKG51bSAlIDIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG51bSkgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4ZXMsIG9yIGtleXMsIG9mIHRoZVxuICAgICAqIGBjb2xsZWN0aW9uYC4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbaW5kZXhdIFRoZSBpbmRleGVzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqICAgdG8gcmV0cmlldmUsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICogIHByb3ZpZGVkIGluZGV4ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgWzAsIDIsIDRdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYycsICdlJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJncywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgIGxlbmd0aCA9IChhcmdzWzJdICYmIGFyZ3NbMl1bYXJnc1sxXV0gPT09IGNvbGxlY3Rpb24pID8gMSA6IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gYSBjb2xsZWN0aW9uIHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXgpIHx8IDA7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IChpc1N0cmluZyhjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIHRydWV5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9ICEhY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gISFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3QsIGZpbmRXaGVyZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgICAqIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyAnMywyLDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltsZW5ndGhdLCBsZW5ndGgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAga2V5ID0gcHJvcHMgPyBwcm9wc1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiByZXN1bHRba2V5XSA9IFtdKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBnaXZlbiBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5cyA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGtleSkgeyB0aGlzLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAqIHdpbGwgYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSAoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChub2FjY3VtKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjb2xsZWN0aW9uWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24gdGhhdCB0aGUgY2FsbGJhY2sgZG9lcyAqKm5vdCoqIHJldHVybiB0cnVleSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgICAqICB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGAgYXJndW1lbnRzIGFzIGBuYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgY29sbGVjdGlvbi5sZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZXkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogY29sbGVjdGlvbi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kXG4gICAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICgocmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY29sbGVjdGlvblxuICAgICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgWyduYW1lJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbKytpbmRleF0gPSBnZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFtsZW5ndGhdO1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAgIHJlbGVhc2VBcnJheShvYmplY3QuY3JpdGVyaWEpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gb2YgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gIHRvIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICB0cnVzdEluZGV4T2YgPSBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2godHJ1c3RJbmRleE9mICYmIHZhbHVlLmxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJlxuICAgICAgICAgICAgY3JlYXRlQ2FjaGUoYXJnc0luZGV4ID8gYXJnc1thcmdzSW5kZXhdIDogc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1swXTtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihzZWVuLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgKGNhY2hlIHx8IHNlZW4pLnB1c2godmFsdWUpO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NMZW5ndGhdO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KGNhY2hlcyk7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PSAnbnVtYmVyJyA/IHN0ZXAgOiAoK3N0ZXAgfHwgMSk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAgIC8vIGh0dHA6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1c1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IHRoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb3JcbiAgICAgKiBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgZWxlbWVudHNcbiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IG5hdGl2ZU1heCgwLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHtcbiAgICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSA6IGlkZW50aXR5O1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWydBJywgJ2InLCAnQycsICdhJywgJ0InLCAnYyddLCBmdW5jdGlvbihsZXR0ZXIpIHsgcmV0dXJuIGxldHRlci50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMi41LCAzLCAxLjUsIDIsIDMuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdKTtcbiAgICAgKiAvLyA9PiBbMywgNSwgNF1cbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCA1XSwgWzIsIDMsIDVdLCBbMywgNCwgNV0pO1xuICAgICAqIC8vID0+IFsxLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VVbmlxKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bnppcFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHMgOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcnJheSwgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSBvZiBrZXlzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAgICogIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKCF2YWx1ZXMgJiYgbGVuZ3RoICYmICFpc0FycmF5KGtleXNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYGZ1bmNgLCB3aXRoICB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kXG4gICAgICogYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCBvbmx5IGFmdGVyIGJlaW5nIGNhbGxlZCBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogIGBmdW5jYCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnRG9uZSBzYXZpbmchJywgYWZ0ZXIgYWxsIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDEsIG51bGwsIG51bGwsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YCB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFttZXRob2ROYW1lXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0b1xuICAgICAqICBiaW5kLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTsgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSA6IGZ1bmN0aW9ucyhvYmplY3QpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIDEsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWBcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmRcbiAgICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihrZXksIDE5LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCBvYmplY3QpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihrZXksIDMsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYWxOYW1lTWFwID0ge1xuICAgICAqICAgJ3BlYmJsZXMnOiAncGVuZWxvcGUnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmb3JtYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICBuYW1lID0gcmVhbE5hbWVNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAqICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAqICAgcmV0dXJuICdIaXlhICcgKyBmb3JtYXR0ZWQgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGdyZWV0LCBmb3JtYXQpO1xuICAgICAqIHdlbGNvbWUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnSGl5YSBQZW5lbG9wZSEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuY3NbbGVuZ3RoXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogaW52b2tlZCBlaXRoZXIgZXhlY3V0ZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEgKyBiICsgYyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHkpIHtcbiAgICAgIGFyaXR5ID0gdHlwZW9mIGFyaXR5ID09ICdudW1iZXInID8gYXJpdHkgOiAoK2FyaXR5IHx8IGZ1bmMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDQsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0sIGZhbHNlKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBuYXRpdmVNYXgoMCwgd2FpdCkgfHwgMDtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChuYXRpdmVNYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50c1xuICAgICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNyZWF0ZUNhbGxiYWNrID0gXy53cmFwKF8uY3JlYXRlQ2FsbGJhY2ssIGZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAoZnVuYyA9PSBudWxsIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBcIl8ucGx1Y2tcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgYCZgLCBgPGAsIGA+YCwgYFwiYCwgYW5kIGAnYCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZCBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2UgfHwgKCFvcHRpb25zICYmICFtZXRob2ROYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IGxvZGFzaDtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gaXNOYXRpdmUobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIHRoZVxuICAgICAqIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgYXZvaWRzIGRpZmZlcmVuY2VzIGluIG5hdGl2ZSBFUzMgYW5kIEVTNSBgcGFyc2VJbnRgXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI0UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdXNlZCB0byBpbnRlcnByZXQgdGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5ldyBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VJbnQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlICsgJzA4JykgPT0gOCA/IG5hdGl2ZVBhcnNlSW50IDogZnVuY3Rpb24odmFsdWUsIHJhZGl4KSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IHRoZSBFUzMgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIG9mIGBwYXJzZUludGBcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zLCAnJykgOiB2YWx1ZSwgcmFkaXggfHwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBcIl8ucGx1Y2tcIiBzdHlsZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyB0aGUgYGtleWAgdmFsdWUgb2YgYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyB0cnVleSBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cyBhXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nPWZhbHNlXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSAnYm9vbGVhbicgJiYgbm9NYXgpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFub01heCAmJiB0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKycnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIGBrZXlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3Rba2V5XSgpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgICAqIHdoaXRlc3BhY2UsIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkLCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWU6XG4gICAgICogaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHNcbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZTpcbiAgICAgKiBodHRwOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vc3RhYmxlL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwuaHRtbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGVdIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzXSBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGxvY2FsIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlVVJMXSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhcmlhYmxlXSBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258c3RyaW5nfSBSZXR1cm5zIGEgY29tcGlsZWQgZnVuY3Rpb24gd2hlbiBubyBgZGF0YWAgb2JqZWN0XG4gICAgICogIGlzIGdpdmVuLCBlbHNlIGl0IHJldHVybnMgdGhlIGludGVycG9sYXRlZCB0ZXh0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAnbmFtZSc6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgSFRNTCBpbiBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nLCB7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGdlbmVyYXRlIEhUTUxcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBfLmZvckVhY2gocGVvcGxlLCBmdW5jdGlvbihuYW1lKSB7ICU+PGxpPjwlLSBuYW1lICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTNiBkZWxpbWl0ZXIgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGRlZmF1bHQgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlclxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvICR7IG5hbWUgfScsIHsgJ25hbWUnOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyBuYW1lKTsgJT4hJywgeyAnbmFtZSc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgKiAgICdpbnRlcnBvbGF0ZSc6IC97eyhbXFxzXFxTXSs/KX19L2dcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8ge3sgbmFtZSB9fSEnLCB7ICduYW1lJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGpRdWVyeVxuICAgICAqIHZhciBsaXN0ID0gJzwlIGpxLmVhY2gocGVvcGxlLCBmdW5jdGlvbihuYW1lKSB7ICU+PGxpPjwlLSBuYW1lICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydmcmVkJywgJ2Jhcm5leSddIH0sIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nLCBudWxsLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEubmFtZSAlPiEnLCBudWxsLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqICAgdmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlO1xuICAgICAqICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEubmFtZSApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqICAgcmV0dXJuIF9fcDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgYSBzdGFjayB0cmFjZVxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAvLyBiYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nL1xuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVFxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG4gICAgICB0ZXh0ID0gU3RyaW5nKHRleHQgfHwgJycpO1xuXG4gICAgICAvLyBhdm9pZCBtaXNzaW5nIGRlcGVuZGVuY2llcyB3aGVuIGBpdGVyYXRvclRlbXBsYXRlYCBpcyBub3QgZGVmaW5lZFxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gZGVmYXVsdHMoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSB2YWx1ZXMoaW1wb3J0cyk7XG5cbiAgICAgIHZhciBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBjb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXJcbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIHRleHQucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzXG4gICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIHJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBpZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQsIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlLFxuICAgICAgICAgIGhhc1ZhcmlhYmxlID0gdmFyaWFibGU7XG5cbiAgICAgIGlmICghaGFzVmFyaWFibGUpIHtcbiAgICAgICAgdmFyaWFibGUgPSAnb2JqJztcbiAgICAgICAgc291cmNlID0gJ3dpdGggKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gY2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIGZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHlcbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgdmFyaWFibGUgKyAnKSB7XFxuJyArXG4gICAgICAgIChoYXNWYXJpYWJsZSA/ICcnIDogdmFyaWFibGUgKyAnIHx8ICgnICsgdmFyaWFibGUgKyAnID0ge30pO1xcbicpICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGVcIiArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICB2YXIgc291cmNlVVJMID0gJ1xcbi8qXFxuLy8jIHNvdXJjZVVSTD0nICsgKG9wdGlvbnMuc291cmNlVVJMIHx8ICcvbG9kYXNoL3RlbXBsYXRlL3NvdXJjZVsnICsgKHRlbXBsYXRlQ291bnRlcisrKSArICddJykgKyAnXFxuKi8nO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24oaW1wb3J0c0tleXMsICdyZXR1cm4gJyArIHNvdXJjZSArIHNvdXJjZVVSTCkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBwcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2QsIGluXG4gICAgICAvLyBzdXBwb3J0ZWQgZW52aXJvbm1lbnRzLCBvciB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAgIC8vIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcyBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjYWxsYmFjayBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNikpO1xuICAgICAqIC8vID0+IFszLCA2LCA0XVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IG1hZ2UuY2FzdFNwZWxsKG4pOyB9KTtcbiAgICAgKiAvLyA9PiBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzLCBwYXNzaW5nIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYCByZXNwZWN0aXZlbHlcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyB0aGlzLmNhc3Qobik7IH0sIG1hZ2UpO1xuICAgICAqIC8vID0+IGFsc28gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBuID0gKG4gPSArbikgPiAtMSA/IG4gOiAwO1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgIHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnRnJlZCwgQmFybmV5ICZhbXA7IFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgQmFybmV5ICYgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCB3aWxsIGJlIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIFN0cmluZyhwcmVmaXggPT0gbnVsbCA/ICcnIDogcHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB3aXRoIGV4cGxpY2l0XG4gICAgICogbWV0aG9kIGNoYWluaW5nIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4oY2hhcmFjdGVycylcbiAgICAgKiAgICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgICAgLm1hcChmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5uYW1lICsgJyBpcyAnICsgY2hyLmFnZTsgfSlcbiAgICAgKiAgICAgLmZpcnN0KClcbiAgICAgKiAgICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgICB2YWx1ZS5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGludGVyY2VwdG9yYCB3aXRoIHRoZSBgdmFsdWVgIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgYHZhbHVlYC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kXG4gICAgICogY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpblxuICAgICAqIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDMsIDRdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7IGFycmF5LnBvcCgpOyB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmZpcnN0KCk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuY2hhaW4oKVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC5waWNrKCdhZ2UnKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIHRoZSBgdG9TdHJpbmdgIHJlc3VsdCBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHRvU3RyaW5nXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcgcmVzdWx0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlT2ZcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB2YWx1ZVxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWVPZigpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZU9mKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX193cmFwcGVkX187XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGNvbXBvc2U7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmNyZWF0ZUNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2s7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbmRleEJ5ID0gaW5kZXhCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmNvbGxlY3QgPSBtYXA7XG4gICAgbG9kYXNoLmRyb3AgPSByZXN0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB6aXA7XG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYFxuICAgIG1peGluKGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBjb250YWlucztcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZmluZFdoZXJlID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBjb250YWlucztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge31cbiAgICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2gudGFrZSA9IGZpcnN0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG5cbiAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2FsbGJhY2thYmxlID0gbWV0aG9kTmFtZSAhPT0gJ3NhbXBsZSc7XG4gICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXT0gZnVuY3Rpb24obiwgZ3VhcmQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyh0aGlzLl9fd3JhcHBlZF9fLCBuLCBndWFyZCk7XG5cbiAgICAgICAgICByZXR1cm4gIWNoYWluQWxsICYmIChuID09IG51bGwgfHwgKGd1YXJkICYmICEoY2FsbGJhY2thYmxlICYmIHR5cGVvZiBuID09ICdmdW5jdGlvbicpKSlcbiAgICAgICAgICAgID8gcmVzdWx0XG4gICAgICAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9ICcyLjQuMic7XG5cbiAgICAvLyBhZGQgXCJDaGFpbmluZ1wiIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlclxuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlT2Y7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gd3JhcHBlclZhbHVlT2Y7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydqb2luJywgJ3BvcCcsICdzaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgICA/IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpXG4gICAgICAgICAgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZSBleGlzdGluZyB3cmFwcGVkIHZhbHVlXG4gICAgZm9yRWFjaChbJ3B1c2gnLCAncmV2ZXJzZScsICdzb3J0JywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gbmV3IHdyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2NvbmNhdCcsICdzbGljZScsICdzcGxpY2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2Rhc2hXcmFwcGVyKGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKSwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIGlzIGxvYWRlZCB3aXRoIGEgUmVxdWlyZUpTIHNoaW0gY29uZmlnLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2FwaS5odG1sI2NvbmZpZy1zaGltXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iXX0=
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
(function (Buffer){
var iconv = require('iconv-lite')
// engineData is an array form descriptor.coffee

var MATCH_TYPE = [  hashStart,
                    hashEnd,
                    multiLineArrayStart,
                    multiLineArrayEnd,
                    property, 
                    propertyWithData,
                    singleLineArray,
                    boolean,
                    number,
                    numberWithDecimal,
                    string];

var nodeStack = [], propertyStack = [];
var currentNode = [];

var paresr = function(engineData){

    nodeStack = propertyStack = currentNode = [];//reset
    textReg(textSegment(codeToString(engineData)));

    return currentNode.shift();
}


function codeToString(engineData){
    return String.fromCharCode.apply(null, engineData);
}

function textSegment(text){
    return text.split('\n');
}

function textReg(textArr){
    textArr.map(function(currentText){
        typeMatch(currentText.replace(/^\t+/g, ''));
    });

}

function typeMatch(currentText){

    for (var currentType in MATCH_TYPE) {
        var t = new MATCH_TYPE[currentType](currentText);
        if (t.match){
            return t.parse();
        }
    }

    return currentText;
}

// helper fun
function Match(reg, text){
    return reg.test(text);
}
function isArray(o){
    return Object.prototype.toString.call(o) === '[object Array]';
}

// tyep reg
function hashStart(text){
    var reg = /^<<$/;

    return {
        match: Match(reg, text),
        parse: function(){
            stackPush({});
        }
    }
}
function hashEnd(text){
    var reg = /^>>$/;

    return {
        match: Match(reg, text),
        parse: function(){
            updateNode();
        }
    }
}
function multiLineArrayStart(text){
    var reg = /^\/(\w+) \[$/;

    return {
        match: Match(reg, text),
        parse: function(){
            propertyStack.push(text.match(reg)[1]);
            stackPush([]);
        }
    }
}
function multiLineArrayEnd(text){
    var reg = /^\]$/;

    return {
        match: Match(reg, text),
        parse: function(){
            updateNode();
        }
    }
}
function property(text){
    var reg = /^\/([A-Z0-9]+)$/i;

    return {
        match: Match(reg, text),
        parse: function(){
            propertyStack.push(text.match(reg)[1]);
        }
    }
}
function propertyWithData(text){
    var reg = /^\/([A-Z0-9]+)\s((.|\r)*)$/i;

    return {
        match: Match(reg, text),
        parse: function(){
            var match = text.match(reg);
            pushKeyValue(match[1], typeMatch(match[2]));
        }
    }
}
// value reg
function boolean(text){
    var reg = /^(true|false)$/;
    return {
        match: Match(reg, text),
        parse: function(){
            return text === 'true'? true:false;
        }
    }
}
function number(text){
    var reg = /^-?\d+$/;
    return {
        match: Match(reg, text),
        parse: function(){
            return Number(text);
        }
    }
}
function numberWithDecimal(text){
    var reg = /^(-?\d*)\.(\d+)$/;
    return {
        match: Match(reg, text),
        parse: function(){
            return Number(text);
        }
    }
}
function singleLineArray(text){
    //
    var reg = /^\[(.*)\]$/;
    return {
        match: Match(reg, text),
        parse: function(){
            var items = text.match(reg)[1].trim().split(' ');
            var tempArr = [];
            for (var i=0, l=items.length; i<l; i++){
                tempArr.push(typeMatch(items[i]));
            }
            return tempArr;
        }
    }
}

function string(text){
    //the text in editor has some encoding issues
    var reg = /^\(((.|\r)*)\)$/;
    return {
        match: Match(reg, text),
        parse: function(){
            var txt = text.match(reg)[1];
            var bf = [];
            for (var i=0,l=txt.length;i<l;i++){
                bf.push(txt.charCodeAt(i));
            }
            return iconv.decode(new Buffer(bf), 'utf-16');//it`s utf-16 with bom
        }
    }
}

// node handle
function stackPush(node){
    nodeStack.push(currentNode);
    currentNode = node;
}
function updateNode(){
    var node = nodeStack.pop();
    if (isArray(node)){
        node.push(currentNode);
    } else {
        node[propertyStack.pop()] = currentNode;
    }
    currentNode = node;
}
function pushKeyValue(key,value){
    currentNode[key] = value;
}

module.exports = paresr;
}).call(this,require("buffer").Buffer)
},{"buffer":68,"iconv-lite":90}],95:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],96:[function(require,module,exports){
(function (process,global){
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.0.21
 */

(function() {
    "use strict";
    function lib$rsvp$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$rsvp$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$rsvp$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$rsvp$utils$$_isArray;
    if (!Array.isArray) {
      lib$rsvp$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$rsvp$utils$$_isArray = Array.isArray;
    }

    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;

    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };

    function lib$rsvp$utils$$F() { }

    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      lib$rsvp$utils$$F.prototype = o;
      return new lib$rsvp$utils$$F();
    });
    function lib$rsvp$events$$indexOf(callbacks, callback) {
      for (var i=0, l=callbacks.length; i<l; i++) {
        if (callbacks[i] === callback) { return i; }
      }

      return -1;
    }

    function lib$rsvp$events$$callbacksFor(object) {
      var callbacks = object._promiseCallbacks;

      if (!callbacks) {
        callbacks = object._promiseCallbacks = {};
      }

      return callbacks;
    }

    var lib$rsvp$events$$default = {

      /**
        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
        Example:

        ```javascript
        var object = {};

        RSVP.EventTarget.mixin(object);

        object.on('finished', function(event) {
          // handle event
        });

        object.trigger('finished', { detail: value });
        ```

        `EventTarget.mixin` also works with prototypes:

        ```javascript
        var Person = function() {};
        RSVP.EventTarget.mixin(Person.prototype);

        var yehuda = new Person();
        var tom = new Person();

        yehuda.on('poke', function(event) {
          console.log('Yehuda says OW');
        });

        tom.on('poke', function(event) {
          console.log('Tom says OW');
        });

        yehuda.trigger('poke');
        tom.trigger('poke');
        ```

        @method mixin
        @for RSVP.EventTarget
        @private
        @param {Object} object object to extend with EventTarget methods
      */
      'mixin': function(object) {
        object['on']      = this['on'];
        object['off']     = this['off'];
        object['trigger'] = this['trigger'];
        object._promiseCallbacks = undefined;
        return object;
      },

      /**
        Registers a callback to be executed when `eventName` is triggered

        ```javascript
        object.on('event', function(eventInfo){
          // handle the event
        });

        object.trigger('event');
        ```

        @method on
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to listen for
        @param {Function} callback function to be called when the event is triggered.
      */
      'on': function(eventName, callback) {
        if (typeof callback !== 'function') {
          throw new TypeError('Callback must be a function');
        }

        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;

        callbacks = allCallbacks[eventName];

        if (!callbacks) {
          callbacks = allCallbacks[eventName] = [];
        }

        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
          callbacks.push(callback);
        }
      },

      /**
        You can use `off` to stop firing a particular callback for an event:

        ```javascript
        function doStuff() { // do stuff! }
        object.on('stuff', doStuff);

        object.trigger('stuff'); // doStuff will be called

        // Unregister ONLY the doStuff callback
        object.off('stuff', doStuff);
        object.trigger('stuff'); // doStuff will NOT be called
        ```

        If you don't pass a `callback` argument to `off`, ALL callbacks for the
        event will not be executed when the event fires. For example:

        ```javascript
        var callback1 = function(){};
        var callback2 = function(){};

        object.on('stuff', callback1);
        object.on('stuff', callback2);

        object.trigger('stuff'); // callback1 and callback2 will be executed.

        object.off('stuff');
        object.trigger('stuff'); // callback1 and callback2 will not be executed!
        ```

        @method off
        @for RSVP.EventTarget
        @private
        @param {String} eventName event to stop listening to
        @param {Function} callback optional argument. If given, only the function
        given will be removed from the event's callback queue. If no `callback`
        argument is given, all callbacks will be removed from the event's callback
        queue.
      */
      'off': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;

        if (!callback) {
          allCallbacks[eventName] = [];
          return;
        }

        callbacks = allCallbacks[eventName];

        index = lib$rsvp$events$$indexOf(callbacks, callback);

        if (index !== -1) { callbacks.splice(index, 1); }
      },

      /**
        Use `trigger` to fire custom events. For example:

        ```javascript
        object.on('foo', function(){
          console.log('foo event happened!');
        });
        object.trigger('foo');
        // 'foo event happened!' logged to the console
        ```

        You can also pass a value as a second argument to `trigger` that will be
        passed as an argument to all event listeners for the event:

        ```javascript
        object.on('foo', function(value){
          console.log(value.name);
        });

        object.trigger('foo', { name: 'bar' });
        // 'bar' logged to the console
        ```

        @method trigger
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to be triggered
        @param {*} options optional value to be passed to any event handlers for
        the given `eventName`
      */
      'trigger': function(eventName, options) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;

        if (callbacks = allCallbacks[eventName]) {
          // Don't cache the callbacks.length since it may grow
          for (var i=0; i<callbacks.length; i++) {
            callback = callbacks[i];

            callback(options);
          }
        }
      }
    };

    var lib$rsvp$config$$config = {
      instrument: false
    };

    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);

    function lib$rsvp$config$$configure(name, value) {
      if (name === 'onerror') {
        // handle for legacy users that expect the actual
        // error to be passed to their function added via
        // `RSVP.configure('onerror', someFunctionHere);`
        lib$rsvp$config$$config['on']('error', value);
        return;
      }

      if (arguments.length === 2) {
        lib$rsvp$config$$config[name] = value;
      } else {
        return lib$rsvp$config$$config[name];
      }
    }

    var lib$rsvp$instrument$$queue = [];

    function lib$rsvp$instrument$$scheduleFlush() {
      setTimeout(function() {
        var entry;
        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
          entry = lib$rsvp$instrument$$queue[i];

          var payload = entry.payload;

          payload.guid = payload.key + payload.id;
          payload.childGuid = payload.key + payload.childId;
          if (payload.error) {
            payload.stack = payload.error.stack;
          }

          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
        }
        lib$rsvp$instrument$$queue.length = 0;
      }, 50);
    }

    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
      if (1 === lib$rsvp$instrument$$queue.push({
        name: eventName,
        payload: {
          key: promise._guidKey,
          id:  promise._id,
          eventName: eventName,
          detail: promise._result,
          childId: child && child._id,
          label: promise._label,
          timeStamp: lib$rsvp$utils$$now(),
          error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
        }})) {
          lib$rsvp$instrument$$scheduleFlush();
        }
      }
    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;

    function  lib$rsvp$$internal$$withOwnPromise() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$rsvp$$internal$$noop() {}

    var lib$rsvp$$internal$$PENDING   = void 0;
    var lib$rsvp$$internal$$FULFILLED = 1;
    var lib$rsvp$$internal$$REJECTED  = 2;

    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
        return lib$rsvp$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
      lib$rsvp$config$$config.async(function(promise) {
        var sealed = false;
        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$rsvp$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$rsvp$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
        thenable._onError = null;
        lib$rsvp$$internal$$reject(promise, thenable._result);
      } else {
        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$rsvp$$internal$$getThen(maybeThenable);

        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$rsvp$utils$$isFunction(then)) {
          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$rsvp$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
        lib$rsvp$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$rsvp$$internal$$fulfill(promise, value);
      }
    }

    function lib$rsvp$$internal$$publishRejection(promise) {
      if (promise._onError) {
        promise._onError(promise._result);
      }

      lib$rsvp$$internal$$publish(promise);
    }

    function lib$rsvp$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$rsvp$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('fulfilled', promise);
        }
      } else {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
      }
    }

    function lib$rsvp$$internal$$reject(promise, reason) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
      promise._state = lib$rsvp$$internal$$REJECTED;
      promise._result = reason;
      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
    }

    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onError = null;

      subscribers[length] = child;
      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
      }
    }

    function lib$rsvp$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
      }

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$rsvp$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$rsvp$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$rsvp$$internal$$tryCatch(callback, detail);

        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$rsvp$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$rsvp$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$rsvp$$internal$$reject(promise, error);
      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (settled === lib$rsvp$$internal$$REJECTED) {
        lib$rsvp$$internal$$reject(promise, value);
      }
    }

    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
      var resolved = false;
      try {
        resolver(function resolvePromise(value){
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$rsvp$$internal$$reject(promise, e);
      }
    }

    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
      if (state === lib$rsvp$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
         return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$rsvp$$internal$$noop, label);
      enumerator._abortOnReject = abortOnReject;

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$rsvp$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;

    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$rsvp$utils$$isArray(input);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;
      var length     = enumerator.length;
      var promise    = enumerator.promise;
      var input      = enumerator._input;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;
      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
          entry._onError = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = enumerator._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$rsvp$$internal$$PENDING) {
        enumerator._remaining--;

        if (enumerator._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = enumerator._makeResult(state, i, value);
        }
      }

      if (enumerator._remaining === 0) {
        lib$rsvp$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
      });
    };
    function lib$rsvp$promise$all$$all(entries, label) {
      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    }
    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
    function lib$rsvp$promise$race$$race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);

      if (!lib$rsvp$utils$$isArray(entries)) {
        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$rsvp$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$rsvp$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
    function lib$rsvp$promise$resolve$$resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
    function lib$rsvp$promise$reject$$reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;

    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
    var lib$rsvp$promise$$counter = 0;

    function lib$rsvp$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$rsvp$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    function lib$rsvp$promise$$Promise(resolver, label) {
      var promise = this;

      promise._id = lib$rsvp$promise$$counter++;
      promise._label = label;
      promise._state = undefined;
      promise._result = undefined;
      promise._subscribers = [];

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default('created', promise);
      }

      if (lib$rsvp$$internal$$noop !== resolver) {
        if (!lib$rsvp$utils$$isFunction(resolver)) {
          lib$rsvp$promise$$needsResolver();
        }

        if (!(promise instanceof lib$rsvp$promise$$Promise)) {
          lib$rsvp$promise$$needsNew();
        }

        lib$rsvp$$internal$$initializePromise(promise, resolver);
      }
    }

    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;

    // deprecated
    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;

    lib$rsvp$promise$$Promise.prototype = {
      constructor: lib$rsvp$promise$$Promise,

      _guidKey: lib$rsvp$promise$$guidKey,

      _onError: function (reason) {
        var promise = this;
        lib$rsvp$config$$config.after(function() {
          if (promise._onError) {
            lib$rsvp$config$$config['trigger']('error', reason);
          }
        });
      },

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfillment
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection, label) {
        var parent = this;
        var state = parent._state;

        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', parent, parent);
          }
          return parent;
        }

        parent._onError = null;

        var child = new parent.constructor(lib$rsvp$$internal$$noop, label);
        var result = parent._result;

        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('chained', parent, child);
        }

        if (state) {
          var callback = arguments[state - 1];
          lib$rsvp$config$$config.async(function(){
            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection, label) {
        return this.then(undefined, onRejection, label);
      },

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves

      Synchronous example:

      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }

      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```

      Asynchronous example:

      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```

      @method finally
      @param {Function} callback
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'finally': function(callback, label) {
        var promise = this;
        var constructor = promise.constructor;

        return promise.then(function(value) {
          return constructor.resolve(callback()).then(function(){
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function(){
            throw reason;
          });
        }, label);
      }
    };

    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
    }

    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
      return new Error('allSettled must be called with an array');
    };

    function lib$rsvp$all$settled$$allSettled(entries, label) {
      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
    }
    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
    function lib$rsvp$all$$all(array, label) {
      return lib$rsvp$promise$$default.all(array, label);
    }
    var lib$rsvp$all$$default = lib$rsvp$all$$all;
    var lib$rsvp$asap$$len = 0;
    var lib$rsvp$asap$$toString = {}.toString;
    var lib$rsvp$asap$$vertxNext;
    function lib$rsvp$asap$$asap(callback, arg) {
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
      lib$rsvp$asap$$len += 2;
      if (lib$rsvp$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        lib$rsvp$asap$$scheduleFlush();
      }
    }

    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;

    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
    var lib$rsvp$asap$$isNode = typeof self === 'undefined' &&
      typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$rsvp$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$rsvp$asap$$flush);
      };
    }

    // vertx
    function lib$rsvp$asap$$useVertxTimer() {
      return function() {
        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
      };
    }

    function lib$rsvp$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$rsvp$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$rsvp$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$rsvp$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$rsvp$asap$$flush, 1);
      };
    }

    var lib$rsvp$asap$$queue = new Array(1000);
    function lib$rsvp$asap$$flush() {
      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
        var callback = lib$rsvp$asap$$queue[i];
        var arg = lib$rsvp$asap$$queue[i+1];

        callback(arg);

        lib$rsvp$asap$$queue[i] = undefined;
        lib$rsvp$asap$$queue[i+1] = undefined;
      }

      lib$rsvp$asap$$len = 0;
    }

    function lib$rsvp$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$rsvp$asap$$useVertxTimer();
      } catch(e) {
        return lib$rsvp$asap$$useSetTimeout();
      }
    }

    var lib$rsvp$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$rsvp$asap$$isNode) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
    } else if (lib$rsvp$asap$$isWorker) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
    } else {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
    }
    function lib$rsvp$defer$$defer(label) {
      var deferred = {};

      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
        deferred['resolve'] = resolve;
        deferred['reject'] = reject;
      }, label);

      return deferred;
    }
    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
    function lib$rsvp$filter$$filter(promises, filterFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(filterFn)) {
          throw new TypeError("You must pass a function as filter's second argument.");
        }

        var length = values.length;
        var filtered = new Array(length);

        for (var i = 0; i < length; i++) {
          filtered[i] = filterFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
          var results = new Array(length);
          var newLength = 0;

          for (var i = 0; i < length; i++) {
            if (filtered[i]) {
              results[newLength] = values[i];
              newLength++;
            }
          }

          results.length = newLength;

          return results;
        });
      });
    }
    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;

    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
      this._superConstructor(Constructor, object, true, label);
    }

    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;

    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
      this._result = {};
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
      return input && typeof input === 'object';
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
      return new Error('Promise.hash must be called with an object');
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
      var enumerator = this;
      var promise    = enumerator.promise;
      var input      = enumerator._input;
      var results    = [];

      for (var key in input) {
        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
          results.push({
            position: key,
            entry: input[key]
          });
        }
      }

      var length = results.length;
      enumerator._remaining = length;
      var result;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        result = results[i];
        enumerator._eachEntry(result.entry, result.position);
      }
    };

    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
      this._superConstructor(Constructor, object, false, label);
    }

    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;

    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
      return new Error('hashSettled must be called with an object');
    };

    function lib$rsvp$hash$settled$$hashSettled(object, label) {
      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
    function lib$rsvp$hash$$hash(object, label) {
      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
    function lib$rsvp$map$$map(promises, mapFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(mapFn)) {
          throw new TypeError("You must pass a function as map's second argument.");
        }

        var length = values.length;
        var results = new Array(length);

        for (var i = 0; i < length; i++) {
          results[i] = mapFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(results, label);
      });
    }
    var lib$rsvp$map$$default = lib$rsvp$map$$map;

    function lib$rsvp$node$$Result() {
      this.value = undefined;
    }

    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();

    function lib$rsvp$node$$getThen(obj) {
      try {
       return obj.then;
      } catch(error) {
        lib$rsvp$node$$ERROR.value= error;
        return lib$rsvp$node$$ERROR;
      }
    }


    function lib$rsvp$node$$tryApply(f, s, a) {
      try {
        f.apply(s, a);
      } catch(error) {
        lib$rsvp$node$$ERROR.value = error;
        return lib$rsvp$node$$ERROR;
      }
    }

    function lib$rsvp$node$$makeObject(_, argumentNames) {
      var obj = {};
      var name;
      var i;
      var length = _.length;
      var args = new Array(length);

      for (var x = 0; x < length; x++) {
        args[x] = _[x];
      }

      for (i = 0; i < argumentNames.length; i++) {
        name = argumentNames[i];
        obj[name] = args[i + 1];
      }

      return obj;
    }

    function lib$rsvp$node$$arrayResult(_) {
      var length = _.length;
      var args = new Array(length - 1);

      for (var i = 1; i < length; i++) {
        args[i - 1] = _[i];
      }

      return args;
    }

    function lib$rsvp$node$$wrapThenable(then, promise) {
      return {
        then: function(onFulFillment, onRejection) {
          return then.call(promise, onFulFillment, onRejection);
        }
      };
    }

    function lib$rsvp$node$$denodeify(nodeFunc, options) {
      var fn = function() {
        var self = this;
        var l = arguments.length;
        var args = new Array(l + 1);
        var arg;
        var promiseInput = false;

        for (var i = 0; i < l; ++i) {
          arg = arguments[i];

          if (!promiseInput) {
            // TODO: clean this up
            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
              return p;
            } else if (promiseInput && promiseInput !== true) {
              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
            }
          }
          args[i] = arg;
        }

        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);

        args[l] = function(err, val) {
          if (err)
            lib$rsvp$$internal$$reject(promise, err);
          else if (options === undefined)
            lib$rsvp$$internal$$resolve(promise, val);
          else if (options === true)
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
          else if (lib$rsvp$utils$$isArray(options))
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
          else
            lib$rsvp$$internal$$resolve(promise, val);
        };

        if (promiseInput) {
          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
        } else {
          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
        }
      };

      fn.__proto__ = nodeFunc;

      return fn;
    }

    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;

    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
      if (result === lib$rsvp$node$$ERROR) {
        lib$rsvp$$internal$$reject(promise, result.value);
      }
      return promise;
    }

    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
      return lib$rsvp$promise$$default.all(args).then(function(args){
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      });
    }

    function lib$rsvp$node$$needsPromiseInput(arg) {
      if (arg && typeof arg === 'object') {
        if (arg.constructor === lib$rsvp$promise$$default) {
          return true;
        } else {
          return lib$rsvp$node$$getThen(arg);
        }
      } else {
        return false;
      }
    }
    var lib$rsvp$platform$$platform;

    /* global self */
    if (typeof self === 'object') {
      lib$rsvp$platform$$platform = self;

    /* global global */
    } else if (typeof global === 'object') {
      lib$rsvp$platform$$platform = global;
    } else {
      throw new Error('no global: `self` or `global` found');
    }

    var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;
    function lib$rsvp$race$$race(array, label) {
      return lib$rsvp$promise$$default.race(array, label);
    }
    var lib$rsvp$race$$default = lib$rsvp$race$$race;
    function lib$rsvp$reject$$reject(reason, label) {
      return lib$rsvp$promise$$default.reject(reason, label);
    }
    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
    function lib$rsvp$resolve$$resolve(value, label) {
      return lib$rsvp$promise$$default.resolve(value, label);
    }
    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
    function lib$rsvp$rethrow$$rethrow(reason) {
      setTimeout(function() {
        throw reason;
      });
      throw reason;
    }
    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;

    // defaults
    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
    lib$rsvp$config$$config.after = function(cb) {
      setTimeout(cb, 0);
    };
    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
    function lib$rsvp$$async(callback, arg) {
      lib$rsvp$config$$config.async(callback, arg);
    }

    function lib$rsvp$$on() {
      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
    }

    function lib$rsvp$$off() {
      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
    }

    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
      lib$rsvp$config$$configure('instrument', true);
      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
        }
      }
    }

    var lib$rsvp$umd$$RSVP = {
      'race': lib$rsvp$race$$default,
      'Promise': lib$rsvp$promise$$default,
      'allSettled': lib$rsvp$all$settled$$default,
      'hash': lib$rsvp$hash$$default,
      'hashSettled': lib$rsvp$hash$settled$$default,
      'denodeify': lib$rsvp$node$$default,
      'on': lib$rsvp$$on,
      'off': lib$rsvp$$off,
      'map': lib$rsvp$map$$default,
      'filter': lib$rsvp$filter$$default,
      'resolve': lib$rsvp$resolve$$default,
      'reject': lib$rsvp$reject$$default,
      'all': lib$rsvp$all$$default,
      'rethrow': lib$rsvp$rethrow$$default,
      'defer': lib$rsvp$defer$$default,
      'EventTarget': lib$rsvp$events$$default,
      'configure': lib$rsvp$config$$configure,
      'async': lib$rsvp$$async
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$rsvp$umd$$RSVP; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$rsvp$umd$$RSVP;
    } else if (typeof lib$rsvp$platform$$default !== 'undefined') {
      lib$rsvp$platform$$default['RSVP'] = lib$rsvp$umd$$RSVP;
    }
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":95}],97:[function(require,module,exports){
(function (process){
/* eslint-disable node/no-deprecated-api */

'use strict'

var buffer = require('buffer')
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

}).call(this,require('_process'))
},{"_process":95,"buffer":68}],98:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":68}],"psd":[function(require,module,exports){
var File, Header, Image, LayerMask, LazyExecute, Module, PSD, RSVP, Resources,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

RSVP = require('rsvp');

Module = require('coffeescript-module').Module;

File = require('./psd/file.coffee');

LazyExecute = require('./psd/lazy_execute.coffee');

Header = require('./psd/header.coffee');

Resources = require('./psd/resources.coffee');

LayerMask = require('./psd/layer_mask.coffee');

Image = require('./psd/image.coffee');

module.exports = PSD = (function(superClass) {
  extend(PSD, superClass);

  PSD.Node = {
    Root: require('./psd/nodes/root.coffee')
  };

  PSD["extends"](require('./psd/init.coffee'));

  function PSD(data) {
    this.file = new File(data);
    this.parsed = false;
    this.header = null;
    Object.defineProperty(this, 'layers', {
      get: function() {
        return this.layerMask.layers;
      }
    });
    RSVP.on('error', function(reason) {
      return console.error(reason);
    });
  }

  PSD.prototype.parse = function() {
    if (this.parsed) {
      return;
    }
    this.parseHeader();
    this.parseResources();
    this.parseLayerMask();
    this.parseImage();
    return this.parsed = true;
  };

  PSD.prototype.parseHeader = function() {
    this.header = new Header(this.file);
    return this.header.parse();
  };

  PSD.prototype.parseResources = function() {
    var resources;
    resources = new Resources(this.file);
    return this.resources = new LazyExecute(resources, this.file).now('skip').later('parse').get();
  };

  PSD.prototype.parseLayerMask = function() {
    var layerMask;
    layerMask = new LayerMask(this.file, this.header);
    return this.layerMask = new LazyExecute(layerMask, this.file).now('skip').later('parse').get();
  };

  PSD.prototype.parseImage = function() {
    var image;
    image = new Image(this.file, this.header);
    return this.image = new LazyExecute(image, this.file).later('parse').ignore('width', 'height').get();
  };

  PSD.prototype.tree = function() {
    return new PSD.Node.Root(this);
  };

  return PSD;

})(Module);

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL1VzZXJzL2JyeWFuL1Byb2plY3RzL3BzZC5qcy9saWIvcHNkLmNvZmZlZSIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icnlhbi9Qcm9qZWN0cy9wc2QuanMvbGliL3BzZC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbUJBLElBQUEseUVBQUE7RUFBQTs7O0FBQUEsSUFBQSxHQUFPLE9BQUEsQ0FBUSxNQUFSOztBQUNOLFNBQVUsT0FBQSxDQUFRLHFCQUFSOztBQUVYLElBQUEsR0FBWSxPQUFBLENBQVEsbUJBQVI7O0FBQ1osV0FBQSxHQUFjLE9BQUEsQ0FBUSwyQkFBUjs7QUFFZCxNQUFBLEdBQVksT0FBQSxDQUFRLHFCQUFSOztBQUNaLFNBQUEsR0FBWSxPQUFBLENBQVEsd0JBQVI7O0FBQ1osU0FBQSxHQUFZLE9BQUEsQ0FBUSx5QkFBUjs7QUFDWixLQUFBLEdBQVksT0FBQSxDQUFRLG9CQUFSOztBQUVaLE1BQU0sQ0FBQyxPQUFQLEdBQXVCOzs7RUFDckIsR0FBQyxDQUFBLElBQUQsR0FDRTtJQUFBLElBQUEsRUFBTSxPQUFBLENBQVEseUJBQVIsQ0FBTjs7O0VBRUYsR0FBQyxFQUFBLE9BQUEsRUFBRCxDQUFTLE9BQUEsQ0FBUSxtQkFBUixDQUFUOztFQUthLGFBQUMsSUFBRDtJQUNYLElBQUMsQ0FBQSxJQUFELEdBQVEsSUFBSSxJQUFKLENBQVMsSUFBVDtJQUNSLElBQUMsQ0FBQSxNQUFELEdBQVU7SUFDVixJQUFDLENBQUEsTUFBRCxHQUFVO0lBRVYsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBeUIsUUFBekIsRUFDRTtNQUFBLEdBQUEsRUFBSyxTQUFBO2VBQUcsSUFBQyxDQUFBLFNBQVMsQ0FBQztNQUFkLENBQUw7S0FERjtJQUdBLElBQUksQ0FBQyxFQUFMLENBQVEsT0FBUixFQUFpQixTQUFDLE1BQUQ7YUFBWSxPQUFPLENBQUMsS0FBUixDQUFjLE1BQWQ7SUFBWixDQUFqQjtFQVJXOztnQkFhYixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQVUsSUFBQyxDQUFBLE1BQVg7QUFBQSxhQUFBOztJQUVBLElBQUMsQ0FBQSxXQUFELENBQUE7SUFDQSxJQUFDLENBQUEsY0FBRCxDQUFBO0lBQ0EsSUFBQyxDQUFBLGNBQUQsQ0FBQTtJQUNBLElBQUMsQ0FBQSxVQUFELENBQUE7V0FFQSxJQUFDLENBQUEsTUFBRCxHQUFVO0VBUkw7O2dCQVlQLFdBQUEsR0FBYSxTQUFBO0lBQ1gsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFJLE1BQUosQ0FBVyxJQUFDLENBQUEsSUFBWjtXQUNWLElBQUMsQ0FBQSxNQUFNLENBQUMsS0FBUixDQUFBO0VBRlc7O2dCQUliLGNBQUEsR0FBZ0IsU0FBQTtBQUNkLFFBQUE7SUFBQSxTQUFBLEdBQVksSUFBSSxTQUFKLENBQWMsSUFBQyxDQUFBLElBQWY7V0FDWixJQUFDLENBQUEsU0FBRCxHQUFhLElBQUksV0FBSixDQUFnQixTQUFoQixFQUEyQixJQUFDLENBQUEsSUFBNUIsQ0FDWCxDQUFDLEdBRFUsQ0FDTixNQURNLENBRVgsQ0FBQyxLQUZVLENBRUosT0FGSSxDQUdYLENBQUMsR0FIVSxDQUFBO0VBRkM7O2dCQU9oQixjQUFBLEdBQWdCLFNBQUE7QUFDZCxRQUFBO0lBQUEsU0FBQSxHQUFZLElBQUksU0FBSixDQUFjLElBQUMsQ0FBQSxJQUFmLEVBQXFCLElBQUMsQ0FBQSxNQUF0QjtXQUNaLElBQUMsQ0FBQSxTQUFELEdBQWEsSUFBSSxXQUFKLENBQWdCLFNBQWhCLEVBQTJCLElBQUMsQ0FBQSxJQUE1QixDQUNYLENBQUMsR0FEVSxDQUNOLE1BRE0sQ0FFWCxDQUFDLEtBRlUsQ0FFSixPQUZJLENBR1gsQ0FBQyxHQUhVLENBQUE7RUFGQzs7Z0JBT2hCLFVBQUEsR0FBWSxTQUFBO0FBQ1YsUUFBQTtJQUFBLEtBQUEsR0FBUSxJQUFJLEtBQUosQ0FBVSxJQUFDLENBQUEsSUFBWCxFQUFpQixJQUFDLENBQUEsTUFBbEI7V0FDUixJQUFDLENBQUEsS0FBRCxHQUFTLElBQUksV0FBSixDQUFnQixLQUFoQixFQUF1QixJQUFDLENBQUEsSUFBeEIsQ0FDUCxDQUFDLEtBRE0sQ0FDQSxPQURBLENBRVAsQ0FBQyxNQUZNLENBRUMsT0FGRCxFQUVVLFFBRlYsQ0FHUCxDQUFDLEdBSE0sQ0FBQTtFQUZDOztnQkFTWixJQUFBLEdBQU0sU0FBQTtXQUFHLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFiLENBQWtCLElBQWxCO0VBQUg7Ozs7R0E3RDJCIn0=

},{"./psd/file.coffee":5,"./psd/header.coffee":6,"./psd/image.coffee":7,"./psd/init.coffee":"./psd/init.coffee","./psd/layer_mask.coffee":48,"./psd/lazy_execute.coffee":49,"./psd/nodes/root.coffee":56,"./psd/resources.coffee":61,"coffeescript-module":70,"rsvp":96}]},{},[]);
